import { openBlock, createBlock, createVNode, resolveComponent, createElementBlock, createElementVNode, createTextVNode, toDisplayString, createCommentVNode, Transition, withCtx, withDirectives, renderSlot, vShow, vModelCheckbox, ref, onMounted, onUnmounted, normalizeClass, withKeys, Fragment, renderList, mergeProps, pushScopeId, popScopeId, cloneVNode, h as h$4, inject, provide, watchEffect, computed, defineComponent, unref, watch, nextTick, toRaw, resolveDynamicComponent, normalizeStyle, getCurrentInstance, getCurrentScope, onScopeDispose, shallowRef, reactive, Teleport, normalizeProps, guardReactiveProps, resolveDirective, markRaw, withModifiers, vModelText, TransitionGroup } from "vue";
function render$m(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "2",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M17 8l4 4m0 0l-4 4m4-4H3"
    })
  ]);
}
function render$l(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "2",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M13 7l5 5m0 0l-5 5m5-5H6"
    })
  ]);
}
function render$k(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "2",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M5 13l4 4L19 7"
    })
  ]);
}
function render$j(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "2",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M19 9l-7 7-7-7"
    })
  ]);
}
function render$i(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "2",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M5 15l7-7 7 7"
    })
  ]);
}
function render$h(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "2",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"
    })
  ]);
}
function render$g(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "2",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M20 12H4"
    })
  ]);
}
function render$f(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "2",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M12 4v16m8-8H4"
    })
  ]);
}
function render$e(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "2",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"
    })
  ]);
}
function render$d(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "2",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M6 18L18 6M6 6l12 12"
    })
  ]);
}
var _export_sfc$1 = (sfc, props2) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props2) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$1Q = {
  name: "Accordion",
  components: { ChevronDownIcon: render$j, ChevronUpIcon: render$i },
  props: { title: { type: String, required: true } },
  data() {
    return {
      open: false
    };
  },
  methods: {
    handleClick: function() {
      this.open = !this.open;
    }
  }
};
function _sfc_render$1Q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ChevronDownIcon = resolveComponent("ChevronDownIcon");
  const _component_ChevronUpIcon = resolveComponent("ChevronUpIcon");
  return openBlock(), createElementBlock("div", null, [
    createElementVNode("div", {
      class: "cursor-pointer flex justify-between select-none",
      onClick: _cache[0] || (_cache[0] = (...args) => $options.handleClick && $options.handleClick(...args))
    }, [
      createTextVNode(toDisplayString($props.title) + " ", 1),
      !$data.open ? (openBlock(), createBlock(_component_ChevronDownIcon, {
        key: 0,
        class: "h-4"
      })) : createCommentVNode("", true),
      $data.open ? (openBlock(), createBlock(_component_ChevronUpIcon, {
        key: 1,
        class: "h-4"
      })) : createCommentVNode("", true)
    ]),
    createVNode(Transition, {
      "enter-active-class": "transition ease-out duration-100",
      "enter-from-class": "transform opacity-0 scale-95",
      "enter-to-class": "transform opacity-100 scale-100",
      "leave-active-class": "transition ease-in duration-75",
      "leave-from-class": "transform opacity-100 scale-100",
      "leave-to-class": "transform opacity-0 scale-95"
    }, {
      default: withCtx(() => [
        withDirectives(createElementVNode("div", null, [
          renderSlot(_ctx.$slots, "default")
        ], 512), [
          [vShow, $data.open]
        ])
      ]),
      _: 3
    })
  ]);
}
var Accordion = /* @__PURE__ */ _export_sfc$1(_sfc_main$1Q, [["render", _sfc_render$1Q]]);
const _sfc_main$1P = {};
function _sfc_render$1P(_ctx, _cache) {
  return openBlock(), createElementBlock("div", null, "Logo");
}
var ApplicationLogo = /* @__PURE__ */ _export_sfc$1(_sfc_main$1P, [["render", _sfc_render$1P]]);
const _sfc_main$1O = {
  props: {
    type: {
      type: String,
      default: "submit"
    }
  }
};
const _hoisted_1$1H = ["type"];
function _sfc_render$1O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    type: $props.type,
    class: "inline-flex items-center px-4 py-2 bg-gray-800 border border-transparent rounded-md font-semibold text-xs text-white uppercase tracking-widest hover:bg-gray-700 active:bg-gray-900 focus:outline-none focus:border-gray-900 focus:shadow-outline-gray transition ease-in-out duration-150"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 8, _hoisted_1$1H);
}
var Button = /* @__PURE__ */ _export_sfc$1(_sfc_main$1O, [["render", _sfc_render$1O]]);
const _sfc_main$1N = {
  props: {
    checked: {
      type: [Array, Boolean],
      default: false
    },
    value: {
      default: null
    }
  },
  emits: ["update:checked"],
  computed: {
    proxyChecked: {
      get() {
        return this.checked;
      },
      set(val) {
        this.$emit("update:checked", val);
      }
    }
  }
};
const _hoisted_1$1G = ["value"];
function _sfc_render$1N(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("input", {
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.proxyChecked = $event),
    type: "checkbox",
    value: $props.value,
    class: "rounded border-gray-300 text-indigo-600 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
  }, null, 8, _hoisted_1$1G)), [
    [vModelCheckbox, $options.proxyChecked]
  ]);
}
var Checkbox = /* @__PURE__ */ _export_sfc$1(_sfc_main$1N, [["render", _sfc_render$1N]]);
const _sfc_main$1M = {};
const _hoisted_1$1F = { class: "rounded bg-dsblue text-white px-4 py-1 flex justify-between items-center focus:outline-none h-9" };
function _sfc_render$1M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", _hoisted_1$1F, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var CustomButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$1M, [["render", _sfc_render$1M]]);
const _sfc_main$1L = {
  props: {
    align: {
      default: "right"
    },
    width: {
      default: "48"
    },
    contentClasses: {
      default: () => ["py-1", "bg-white"]
    }
  },
  setup() {
    let open = ref(false);
    const closeOnEscape = (e2) => {
      if (open.value && e2.keyCode === 27) {
        open.value = false;
      }
    };
    onMounted(() => document.addEventListener("keydown", closeOnEscape));
    onUnmounted(() => document.removeEventListener("keydown", closeOnEscape));
    return {
      open
    };
  },
  computed: {
    widthClass() {
      return {
        "48": "w-48"
      }[this.width.toString()];
    },
    alignmentClasses() {
      if (this.align === "left") {
        return "origin-top-left left-0";
      } else if (this.align === "right") {
        return "origin-top-right right-0";
      } else {
        return "origin-top";
      }
    }
  }
};
const _hoisted_1$1E = { class: "relative" };
function _sfc_render$1L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1E, [
    createElementVNode("div", {
      onClick: _cache[0] || (_cache[0] = ($event) => $setup.open = !$setup.open)
    }, [
      renderSlot(_ctx.$slots, "trigger")
    ]),
    withDirectives(createElementVNode("div", {
      class: "fixed inset-0 z-40",
      onClick: _cache[1] || (_cache[1] = ($event) => $setup.open = false)
    }, null, 512), [
      [vShow, $setup.open]
    ]),
    createVNode(Transition, {
      "enter-active-class": "transition ease-out duration-200",
      "enter-from-class": "transform opacity-0 scale-95",
      "enter-to-class": "transform opacity-100 scale-100",
      "leave-active-class": "transition ease-in duration-75",
      "leave-from-class": "transform opacity-100 scale-100",
      "leave-to-class": "transform opacity-0 scale-95"
    }, {
      default: withCtx(() => [
        withDirectives(createElementVNode("div", {
          class: normalizeClass(["absolute z-50 mt-2 rounded-md shadow-lg", [$options.widthClass, $options.alignmentClasses]]),
          style: { "display": "none" },
          onClick: _cache[2] || (_cache[2] = ($event) => $setup.open = false)
        }, [
          createElementVNode("div", {
            class: normalizeClass(["rounded-md ring-1 ring-black ring-opacity-5", $props.contentClasses])
          }, [
            renderSlot(_ctx.$slots, "content")
          ], 2)
        ], 2), [
          [vShow, $setup.open]
        ])
      ]),
      _: 3
    })
  ]);
}
var Dropdown = /* @__PURE__ */ _export_sfc$1(_sfc_main$1L, [["render", _sfc_render$1L]]);
const _sfc_main$1K = {
  props: {
    modelValue: { type: [String, Number], default: "" },
    min: { type: Number, default: void 0 },
    disabled: { type: Boolean, default: false },
    placeholder: { type: String, default: void 0 },
    required: { type: Boolean, required: false },
    type: { type: String, default: "text" }
  },
  emits: ["update:modelValue"],
  methods: {
    focus() {
      this.$refs.input.focus();
    }
  }
};
const _hoisted_1$1D = ["value", "min", "disabled", "placeholder", "required", "type"];
function _sfc_render$1K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("input", {
    ref: "input",
    class: "border-gray-300 focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50 rounded-md shadow-sm",
    value: $props.modelValue,
    min: $props.min,
    disabled: $props.disabled,
    placeholder: $props.placeholder,
    required: $props.required,
    type: $props.type || "text",
    onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event.target.value))
  }, null, 40, _hoisted_1$1D);
}
var Input = /* @__PURE__ */ _export_sfc$1(_sfc_main$1K, [["render", _sfc_render$1K]]);
const _sfc_main$1J = {
  props: ["message"]
};
const _hoisted_1$1C = { class: "text-sm text-red-600" };
function _sfc_render$1J(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("div", null, [
    createElementVNode("p", _hoisted_1$1C, toDisplayString($props.message), 1)
  ], 512)), [
    [vShow, $props.message]
  ]);
}
var InputError = /* @__PURE__ */ _export_sfc$1(_sfc_main$1J, [["render", _sfc_render$1J]]);
const _sfc_main$1I = {
  props: ["value"]
};
const _hoisted_1$1B = { class: "block font-medium text-sm text-gray-700" };
const _hoisted_2$Y = { key: 0 };
const _hoisted_3$J = { key: 1 };
function _sfc_render$1I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", _hoisted_1$1B, [
    $props.value ? (openBlock(), createElementBlock("span", _hoisted_2$Y, toDisplayString($props.value), 1)) : (openBlock(), createElementBlock("span", _hoisted_3$J, [
      renderSlot(_ctx.$slots, "default")
    ]))
  ]);
}
var Label = /* @__PURE__ */ _export_sfc$1(_sfc_main$1I, [["render", _sfc_render$1I]]);
const _sfc_main$1H = {
  name: "Modal",
  components: {
    XIcon: render$d
  },
  props: {
    buttons: { type: Array, default: null }
  },
  emits: ["close"],
  mounted() {
    this.$refs.overlay.focus();
  }
};
const _hoisted_1$1A = { class: "bg-white pt-2 pb-8 rounded w-full max-w-md" };
const _hoisted_2$X = { class: "text-right px-2" };
const _hoisted_3$I = { class: "px-4" };
const _hoisted_4$t = { class: "text-center" };
const _hoisted_5$p = {
  key: 0,
  class: "flex gap-2 justify-center pt-4"
};
const _hoisted_6$j = ["onClick"];
function _sfc_render$1H(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_XIcon = resolveComponent("XIcon");
  return openBlock(), createElementBlock("div", {
    ref: "overlay",
    class: "fixed top-0 left-0 bottom-0 right-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-50 px-4 focus:ring-0 focus:border-0 focus:outline-none",
    tabindex: "0",
    onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.$emit("close"), ["esc"]))
  }, [
    createElementVNode("div", _hoisted_1$1A, [
      createElementVNode("div", _hoisted_2$X, [
        createElementVNode("button", {
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
        }, [
          createVNode(_component_XIcon, { class: "h-4 fill-current text-gray-500" })
        ])
      ]),
      createElementVNode("div", _hoisted_3$I, [
        createElementVNode("div", _hoisted_4$t, [
          renderSlot(_ctx.$slots, "default")
        ]),
        $props.buttons && $props.buttons.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_5$p, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.buttons, (b2, i2) => {
            return openBlock(), createElementBlock("button", {
              key: `modal-button-${i2}`,
              class: normalizeClass(["border rounded px-6 py-1.5 font-semibold hover:opacity-80 duration-300", [b2.primary ? "bg-blue-600 text-white" : "border-blue-600 text-blue-600"]]),
              onClick: b2.onClick
            }, toDisplayString(b2.text), 11, _hoisted_6$j);
          }), 128))
        ])) : createCommentVNode("", true)
      ])
    ])
  ], 544);
}
var Modal = /* @__PURE__ */ _export_sfc$1(_sfc_main$1H, [["render", _sfc_render$1H]]);
var IconBase_vue_vue_type_style_index_0_scoped_true_lang = "";
const iconProps = {
  width: {
    type: [Number, String],
    default: 18
  },
  height: {
    type: [Number, String],
    default: 18
  },
  iconColor: {
    type: String,
    default: "#050038"
  },
  viewBox: {
    type: String,
    default: "0 0 18 18"
  }
};
const _sfc_main$1G = {
  name: "IconBase",
  props: iconProps
};
const _hoisted_1$1z = ["width", "height", "viewBox"];
const _hoisted_2$W = ["fill"];
function _sfc_render$1G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: _ctx.width,
    height: _ctx.height,
    viewBox: _ctx.viewBox
  }, [
    createElementVNode("g", { fill: _ctx.iconColor }, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ], 8, _hoisted_2$W)
  ], 8, _hoisted_1$1z);
}
var IconBase = /* @__PURE__ */ _export_sfc$1(_sfc_main$1G, [["render", _sfc_render$1G], ["__scopeId", "data-v-f8e238e2"]]);
const _sfc_main$1F = {
  name: "ArrowLeftIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$1y = /* @__PURE__ */ createElementVNode("path", {
  id: "Path_502",
  "data-name": "Path 502",
  d: "M8.752,11,0,2.525,2.606,0,8.752,5.951,14.9,0l2.607,2.525L14.223,5.7Z",
  transform: "translate(11 0.002) rotate(90)",
  fill: "currentColor"
}, null, -1);
function _sfc_render$1F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 11 17.507" }), {
    default: withCtx(() => [
      _hoisted_1$1y
    ]),
    _: 1
  }, 16);
}
var ArrowLeftIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1F, [["render", _sfc_render$1F]]);
const _sfc_main$1E = {
  name: "ArrowRightIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$1x = /* @__PURE__ */ createElementVNode("path", {
  id: "Path_475",
  "data-name": "Path 475",
  d: "M8.752,11,0,2.525,2.606,0,8.752,5.951,14.9,0l2.607,2.525Z",
  transform: "translate(0 17.505) rotate(-90)",
  fill: "currentColor"
}, null, -1);
function _sfc_render$1E(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 11 17.507" }), {
    default: withCtx(() => [
      _hoisted_1$1x
    ]),
    _: 1
  }, 16);
}
var ArrowRightIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1E, [["render", _sfc_render$1E]]);
const _sfc_main$1D = {
  props: {
    page: {
      type: Number,
      default: 1
    },
    active: {
      type: Boolean,
      default: false
    }
  },
  emits: ["change"]
};
function _sfc_render$1D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["cursor-pointer px-2 py-3", $props.active ? "border-t-2 border-dsblue text-dsblue" : "hover:border-t-2 hover:border-dsblue hover:text-dsblue"]),
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("change", $props.page))
  }, toDisplayString($props.page), 3);
}
var PaginationButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$1D, [["render", _sfc_render$1D]]);
const _sfc_main$1C = {
  components: { PaginationButton, ArrowRightIcon, ArrowLeftIcon },
  props: {
    totalPage: {
      type: Number,
      default: 10
    },
    page: {
      type: Number,
      default: 1
    }
  },
  emits: ["change"]
};
const _hoisted_1$1w = { class: "flex justify-between border-t border-gray-200" };
const _hoisted_2$V = /* @__PURE__ */ createElementVNode("div", null, "Previous", -1);
const _hoisted_3$H = {
  key: 0,
  class: "flex space-x-6 text-txtgray"
};
const _hoisted_4$s = {
  key: 1,
  class: "flex space-x-6 text-txtgray"
};
const _hoisted_5$o = /* @__PURE__ */ createElementVNode("div", { class: "py-3 px-2 text-txtgray" }, "...", -1);
const _hoisted_6$i = /* @__PURE__ */ createElementVNode("div", { class: "py-3 px-2 text-txtgray" }, "...", -1);
const _hoisted_7$f = /* @__PURE__ */ createElementVNode("div", null, "Next", -1);
function _sfc_render$1C(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ArrowLeftIcon = resolveComponent("ArrowLeftIcon");
  const _component_PaginationButton = resolveComponent("PaginationButton");
  const _component_ArrowRightIcon = resolveComponent("ArrowRightIcon");
  return openBlock(), createElementBlock("div", _hoisted_1$1w, [
    createElementVNode("div", {
      class: "text-txtgray flex space-x-1 items-center cursor-pointer",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("change", $props.page > 1 ? $props.page - 1 : $props.page))
    }, [
      createVNode(_component_ArrowLeftIcon, { "icon-color": "#808080" }),
      _hoisted_2$V
    ]),
    $props.totalPage <= 5 ? (openBlock(), createElementBlock("div", _hoisted_3$H, [
      (openBlock(true), createElementBlock(Fragment, null, renderList([...Array($props.totalPage)], (_2, index2) => {
        return openBlock(), createBlock(_component_PaginationButton, {
          key: index2,
          page: index2 + 1,
          active: index2 + 1 === $props.page,
          onChange: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("change", $event))
        }, null, 8, ["page", "active"]);
      }), 128))
    ])) : (openBlock(), createElementBlock("div", _hoisted_4$s, [
      $props.page < 5 ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList([...Array(Math.min(5, $props.totalPage))], (_2, index2) => {
        return openBlock(), createBlock(_component_PaginationButton, {
          key: index2,
          page: index2 + 1,
          active: index2 + 1 === $props.page,
          onChange: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("change", $event))
        }, null, 8, ["page", "active"]);
      }), 128)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createVNode(_component_PaginationButton, {
          page: 1,
          onChange: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("change", $event))
        }),
        _hoisted_5$o
      ], 64)),
      $props.page >= 5 && $props.page <= $props.totalPage - 4 ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        createVNode(_component_PaginationButton, {
          page: $props.page - 1,
          onChange: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("change", $event))
        }, null, 8, ["page"]),
        createVNode(_component_PaginationButton, {
          page: $props.page,
          active: true,
          onChange: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("change", $event))
        }, null, 8, ["page"]),
        createVNode(_component_PaginationButton, {
          page: $props.page + 1,
          onChange: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("change", $event))
        }, null, 8, ["page"])
      ], 64)) : createCommentVNode("", true),
      $props.page > $props.totalPage - 4 && $props.page > 4 ? (openBlock(true), createElementBlock(Fragment, { key: 3 }, renderList([...Array(Math.max(5, $props.totalPage - $props.page))], (_2, index2) => {
        return openBlock(), createBlock(_component_PaginationButton, {
          key: $props.totalPage - 4 + index2,
          page: $props.totalPage - 4 + index2,
          active: $props.totalPage - 4 + index2 === $props.page,
          onChange: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("change", $event))
        }, null, 8, ["page", "active"]);
      }), 128)) : (openBlock(), createElementBlock(Fragment, { key: 4 }, [
        _hoisted_6$i,
        createVNode(_component_PaginationButton, {
          page: $props.totalPage,
          onChange: _cache[8] || (_cache[8] = ($event) => _ctx.$emit("change", $event))
        }, null, 8, ["page"])
      ], 64))
    ])),
    createElementVNode("div", {
      class: "text-txtgray flex space-x-1 items-center cursor-pointer",
      onClick: _cache[9] || (_cache[9] = ($event) => _ctx.$emit("change", $props.page < $props.totalPage ? $props.page + 1 : $props.page))
    }, [
      _hoisted_7$f,
      createVNode(_component_ArrowRightIcon, { "icon-color": "#808080" })
    ])
  ]);
}
var Pagination = /* @__PURE__ */ _export_sfc$1(_sfc_main$1C, [["render", _sfc_render$1C]]);
var RadioButton_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$1B = {
  name: "RadioButton",
  props: {
    name: { type: String, required: true },
    label: { type: String, required: true },
    modelValue: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"]
};
const _withScopeId$b = (n2) => (pushScopeId("data-v-236aa504"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1v = { class: "py-1" };
const _hoisted_2$U = { class: "flex gap-2 text-navy cursor-pointer" };
const _hoisted_3$G = ["name", "checked"];
const _hoisted_4$r = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createElementVNode("span", { class: "radio inline-block border border-gray-500 rounded-full relative" }, null, -1));
const _hoisted_5$n = { class: "label-text" };
function _sfc_render$1B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1v, [
    createElementVNode("label", _hoisted_2$U, [
      createElementVNode("input", {
        type: "radio",
        name: $props.name,
        class: "hidden radio-input",
        checked: $props.modelValue,
        onChange: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
      }, null, 40, _hoisted_3$G),
      _hoisted_4$r,
      createElementVNode("span", _hoisted_5$n, toDisplayString($props.label), 1)
    ])
  ]);
}
var RadioButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$1B, [["render", _sfc_render$1B], ["__scopeId", "data-v-236aa504"]]);
function u$4(r2, n2, ...a2) {
  if (r2 in n2) {
    let e2 = n2[r2];
    return typeof e2 == "function" ? e2(...a2) : e2;
  }
  let t2 = new Error(`Tried to handle "${r2}" but there is no handler defined. Only defined handlers are: ${Object.keys(n2).map((e2) => `"${e2}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t2, u$4), t2;
}
var R$2 = ((o2) => (o2[o2.None = 0] = "None", o2[o2.RenderStrategy = 1] = "RenderStrategy", o2[o2.Static = 2] = "Static", o2))(R$2 || {}), O$2 = ((e2) => (e2[e2.Unmount = 0] = "Unmount", e2[e2.Hidden = 1] = "Hidden", e2))(O$2 || {});
function P$4({ visible: r2 = true, features: t2 = 0, ourProps: e2, theirProps: o2, ...i2 }) {
  var a2;
  let n2 = w$4(o2, e2), s2 = Object.assign(i2, { props: n2 });
  if (r2 || t2 & 2 && n2.static)
    return u$3(s2);
  if (t2 & 1) {
    let l2 = (a2 = n2.unmount) == null || a2 ? 0 : 1;
    return u$4(l2, { [0]() {
      return null;
    }, [1]() {
      return u$3({ ...i2, props: { ...n2, hidden: true, style: { display: "none" } } });
    } });
  }
  return u$3(s2);
}
function u$3({ props: r2, attrs: t2, slots: e2, slot: o2, name: i2 }) {
  var f2;
  let { as: n2, ...s2 } = N$3(r2, ["unmount", "static"]), a2 = (f2 = e2.default) == null ? void 0 : f2.call(e2, o2), l2 = {};
  if (n2 === "template") {
    if (a2 = y$2(a2), Object.keys(s2).length > 0 || Object.keys(t2).length > 0) {
      let [c2, ...p2] = a2 != null ? a2 : [];
      if (!k$1(c2) || p2.length > 0)
        throw new Error(['Passing props on "template"!', "", `The current component <${i2} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(s2).concat(Object.keys(t2)).sort((d2, g2) => d2.localeCompare(g2)).map((d2) => `  - ${d2}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map((d2) => `  - ${d2}`).join(`
`)].join(`
`));
      return cloneVNode(c2, Object.assign({}, s2, l2));
    }
    return Array.isArray(a2) && a2.length === 1 ? a2[0] : a2;
  }
  return h$4(n2, Object.assign({}, s2, l2), a2);
}
function y$2(r2) {
  return r2.flatMap((t2) => t2.type === Fragment ? y$2(t2.children) : [t2]);
}
function w$4(...r2) {
  if (r2.length === 0)
    return {};
  if (r2.length === 1)
    return r2[0];
  let t2 = {}, e2 = {};
  for (let i2 of r2)
    for (let n2 in i2)
      n2.startsWith("on") && typeof i2[n2] == "function" ? (e2[n2] != null || (e2[n2] = []), e2[n2].push(i2[n2])) : t2[n2] = i2[n2];
  if (t2.disabled || t2["aria-disabled"])
    return Object.assign(t2, Object.fromEntries(Object.keys(e2).map((i2) => [i2, void 0])));
  for (let i2 in e2)
    Object.assign(t2, { [i2](n2, ...s2) {
      let a2 = e2[i2];
      for (let l2 of a2) {
        if (n2 != null && n2.defaultPrevented)
          return;
        l2(n2, ...s2);
      }
    } });
  return t2;
}
function A$2(r2) {
  let t2 = Object.assign({}, r2);
  for (let e2 in t2)
    t2[e2] === void 0 && delete t2[e2];
  return t2;
}
function N$3(r2, t2 = []) {
  let e2 = Object.assign({}, r2);
  for (let o2 of t2)
    o2 in e2 && delete e2[o2];
  return e2;
}
function k$1(r2) {
  return r2 == null ? false : typeof r2.type == "string" || typeof r2.type == "object" || typeof r2.type == "function";
}
let e$3 = 0;
function n$3() {
  return ++e$3;
}
function t$2() {
  return n$3();
}
var o$3 = ((r2) => (r2.Space = " ", r2.Enter = "Enter", r2.Escape = "Escape", r2.Backspace = "Backspace", r2.Delete = "Delete", r2.ArrowLeft = "ArrowLeft", r2.ArrowUp = "ArrowUp", r2.ArrowRight = "ArrowRight", r2.ArrowDown = "ArrowDown", r2.Home = "Home", r2.End = "End", r2.PageUp = "PageUp", r2.PageDown = "PageDown", r2.Tab = "Tab", r2))(o$3 || {});
function f$3(r2) {
  throw new Error("Unexpected object: " + r2);
}
var a$3 = ((e2) => (e2[e2.First = 0] = "First", e2[e2.Previous = 1] = "Previous", e2[e2.Next = 2] = "Next", e2[e2.Last = 3] = "Last", e2[e2.Specific = 4] = "Specific", e2[e2.Nothing = 5] = "Nothing", e2))(a$3 || {});
function x$2(r2, n2) {
  let t2 = n2.resolveItems();
  if (t2.length <= 0)
    return null;
  let l2 = n2.resolveActiveIndex(), s2 = l2 != null ? l2 : -1, d2 = (() => {
    switch (r2.focus) {
      case 0:
        return t2.findIndex((e2) => !n2.resolveDisabled(e2));
      case 1: {
        let e2 = t2.slice().reverse().findIndex((i2, c2, u2) => s2 !== -1 && u2.length - c2 - 1 >= s2 ? false : !n2.resolveDisabled(i2));
        return e2 === -1 ? e2 : t2.length - 1 - e2;
      }
      case 2:
        return t2.findIndex((e2, i2) => i2 <= s2 ? false : !n2.resolveDisabled(e2));
      case 3: {
        let e2 = t2.slice().reverse().findIndex((i2) => !n2.resolveDisabled(i2));
        return e2 === -1 ? e2 : t2.length - 1 - e2;
      }
      case 4:
        return t2.findIndex((e2) => n2.resolveId(e2) === r2.id);
      case 5:
        return null;
      default:
        f$3(r2);
    }
  })();
  return d2 === -1 ? l2 : d2;
}
function o$2(n2) {
  var l2;
  return n2 == null || n2.value == null ? null : (l2 = n2.value.$el) != null ? l2 : n2.value;
}
let n$2 = Symbol("Context");
var l$2 = ((e2) => (e2[e2.Open = 0] = "Open", e2[e2.Closed = 1] = "Closed", e2))(l$2 || {});
function p$5() {
  return inject(n$2, null);
}
function c$3(o2) {
  provide(n$2, o2);
}
function r$2(t2, e2) {
  if (t2)
    return t2;
  let n2 = e2 != null ? e2 : "button";
  if (typeof n2 == "string" && n2.toLowerCase() === "button")
    return "button";
}
function b$3(t2, e2) {
  let n2 = ref(r$2(t2.value.type, t2.value.as));
  return onMounted(() => {
    n2.value = r$2(t2.value.type, t2.value.as);
  }), watchEffect(() => {
    var o2;
    n2.value || !o$2(e2) || o$2(e2) instanceof HTMLButtonElement && !((o2 = o$2(e2)) != null && o2.hasAttribute("type")) && (n2.value = "button");
  }), n2;
}
function e$2(n2) {
  if (typeof window == "undefined")
    return null;
  if (n2 instanceof Node)
    return n2.ownerDocument;
  if (n2 != null && n2.hasOwnProperty("value")) {
    let o2 = o$2(n2);
    if (o2)
      return o2.ownerDocument;
  }
  return document;
}
let c$2 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e2) => `${e2}:not([tabindex='-1'])`).join(",");
var L$2 = ((o2) => (o2[o2.First = 1] = "First", o2[o2.Previous = 2] = "Previous", o2[o2.Next = 4] = "Next", o2[o2.Last = 8] = "Last", o2[o2.WrapAround = 16] = "WrapAround", o2[o2.NoScroll = 32] = "NoScroll", o2))(L$2 || {}), N$2 = ((n2) => (n2[n2.Error = 0] = "Error", n2[n2.Overflow = 1] = "Overflow", n2[n2.Success = 2] = "Success", n2[n2.Underflow = 3] = "Underflow", n2))(N$2 || {}), T$3 = ((t2) => (t2[t2.Previous = -1] = "Previous", t2[t2.Next = 1] = "Next", t2))(T$3 || {});
var M$2 = ((t2) => (t2[t2.Strict = 0] = "Strict", t2[t2.Loose = 1] = "Loose", t2))(M$2 || {});
function F$2(e2, r2 = 0) {
  var t2;
  return e2 === ((t2 = e$2(e2)) == null ? void 0 : t2.body) ? false : u$4(r2, { [0]() {
    return e2.matches(c$2);
  }, [1]() {
    let l2 = e2;
    for (; l2 !== null; ) {
      if (l2.matches(c$2))
        return true;
      l2 = l2.parentElement;
    }
    return false;
  } });
}
function w$3(e2, r2 = (t2) => t2) {
  return e2.slice().sort((t2, l2) => {
    let n2 = r2(t2), i2 = r2(l2);
    if (n2 === null || i2 === null)
      return 0;
    let o2 = n2.compareDocumentPosition(i2);
    return o2 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : o2 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function w$2(e2, n2, t2) {
  typeof window != "undefined" && watchEffect((o2) => {
    window.addEventListener(e2, n2, t2), o2(() => window.removeEventListener(e2, n2, t2));
  });
}
function T$2(l2, f2, a2 = computed(() => true)) {
  function i2(t2, r2) {
    if (!a2.value || t2.defaultPrevented)
      return;
    let n2 = r2(t2);
    if (n2 === null || !n2.ownerDocument.documentElement.contains(n2))
      return;
    let m2 = function o2(e2) {
      return typeof e2 == "function" ? o2(e2()) : Array.isArray(e2) || e2 instanceof Set ? e2 : [e2];
    }(l2);
    for (let o2 of m2) {
      if (o2 === null)
        continue;
      let e2 = o2 instanceof HTMLElement ? o2 : o$2(o2);
      if (e2 != null && e2.contains(n2))
        return;
    }
    return !F$2(n2, M$2.Loose) && n2.tabIndex !== -1 && t2.preventDefault(), f2(t2, n2);
  }
  w$2("click", (t2) => i2(t2, (r2) => r2.target), true), w$2("blur", (t2) => i2(t2, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}
var p$4 = ((e2) => (e2[e2.None = 1] = "None", e2[e2.Focusable = 2] = "Focusable", e2[e2.Hidden = 4] = "Hidden", e2))(p$4 || {});
let m$2 = defineComponent({ name: "Hidden", props: { as: { type: [Object, String], default: "div" }, features: { type: Number, default: 1 } }, setup(r2, { slots: t2, attrs: o2 }) {
  return () => {
    let { features: e2, ...d2 } = r2, n2 = { "aria-hidden": (e2 & 2) === 2 ? true : void 0, style: { position: "absolute", width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(e2 & 4) === 4 && (e2 & 2) !== 2 && { display: "none" } } };
    return P$4({ ourProps: n2, theirProps: d2, slot: {}, attrs: o2, slots: t2, name: "Hidden" });
  };
} });
function e$1(n2 = {}, r2 = null, t2 = []) {
  for (let [i2, o2] of Object.entries(n2))
    f$2(t2, s$2(r2, i2), o2);
  return t2;
}
function s$2(n2, r2) {
  return n2 ? n2 + "[" + r2 + "]" : r2;
}
function f$2(n2, r2, t2) {
  if (Array.isArray(t2))
    for (let [i2, o2] of t2.entries())
      f$2(n2, s$2(r2, i2.toString()), o2);
  else
    t2 instanceof Date ? n2.push([r2, t2.toISOString()]) : typeof t2 == "boolean" ? n2.push([r2, t2 ? "1" : "0"]) : typeof t2 == "string" ? n2.push([r2, t2]) : typeof t2 == "number" ? n2.push([r2, `${t2}`]) : t2 == null ? n2.push([r2, ""]) : e$1(t2, r2, n2);
}
function p$3(n2) {
  var t2;
  let r2 = (t2 = n2 == null ? void 0 : n2.form) != null ? t2 : n2.closest("form");
  if (!!r2) {
    for (let i2 of r2.elements)
      if (i2.tagName === "INPUT" && i2.type === "submit" || i2.tagName === "BUTTON" && i2.type === "submit" || i2.nodeName === "INPUT" && i2.type === "image") {
        i2.click();
        return;
      }
  }
}
let u$2 = Symbol("DescriptionContext");
function b$2() {
  let t2 = inject(u$2, null);
  if (t2 === null)
    throw new Error("Missing parent");
  return t2;
}
function P$3({ slot: t2 = ref({}), name: o2 = "Description", props: s2 = {} } = {}) {
  let e2 = ref([]);
  function n2(r2) {
    return e2.value.push(r2), () => {
      let i2 = e2.value.indexOf(r2);
      i2 !== -1 && e2.value.splice(i2, 1);
    };
  }
  return provide(u$2, { register: n2, slot: t2, name: o2, props: s2 }), computed(() => e2.value.length > 0 ? e2.value.join(" ") : void 0);
}
let S$2 = defineComponent({ name: "Description", props: { as: { type: [Object, String], default: "p" } }, setup(t2, { attrs: o2, slots: s2 }) {
  let e2 = b$2(), n2 = `headlessui-description-${t$2()}`;
  return onMounted(() => onUnmounted(e2.register(n2))), () => {
    let { name: r2 = "Description", slot: i2 = ref({}), props: l2 = {} } = e2, c2 = t2, d2 = { ...Object.entries(l2).reduce((f2, [a2, g2]) => Object.assign(f2, { [a2]: unref(g2) }), {}), id: n2 };
    return P$4({ ourProps: d2, theirProps: c2, slot: i2.value, attrs: o2, slots: s2, name: r2 });
  };
} });
var le$1 = ((n2) => (n2[n2.Open = 0] = "Open", n2[n2.Closed = 1] = "Closed", n2))(le$1 || {}), ne$1 = ((n2) => (n2[n2.Single = 0] = "Single", n2[n2.Multi = 1] = "Multi", n2))(ne$1 || {}), ue$1 = ((n2) => (n2[n2.Pointer = 0] = "Pointer", n2[n2.Other = 1] = "Other", n2))(ue$1 || {});
function re$1(i2) {
  requestAnimationFrame(() => requestAnimationFrame(i2));
}
let H$1 = Symbol("ListboxContext");
function I$2(i2) {
  let x2 = inject(H$1, null);
  if (x2 === null) {
    let n2 = new Error(`<${i2} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(n2, I$2), n2;
  }
  return x2;
}
let we$1 = defineComponent({ name: "Listbox", emits: { "update:modelValue": (i2) => true }, props: { as: { type: [Object, String], default: "template" }, disabled: { type: [Boolean], default: false }, horizontal: { type: [Boolean], default: false }, modelValue: { type: [Object, String, Number, Boolean] }, name: { type: String, optional: true }, multiple: { type: [Boolean], default: false } }, inheritAttrs: false, setup(i2, { slots: x2, attrs: n2, emit: S2 }) {
  let e2 = ref(1), p2 = ref(null), d2 = ref(null), m2 = ref(null), s2 = ref([]), O2 = ref(""), t2 = ref(null), l2 = ref(1);
  function w2(o2 = (a2) => a2) {
    let a2 = t2.value !== null ? s2.value[t2.value] : null, u2 = w$3(o2(s2.value.slice()), (g2) => o$2(g2.dataRef.domRef)), f2 = a2 ? u2.indexOf(a2) : null;
    return f2 === -1 && (f2 = null), { options: u2, activeOptionIndex: f2 };
  }
  let h2 = computed(() => i2.modelValue), T2 = computed(() => i2.multiple ? 1 : 0), r2 = { listboxState: e2, value: h2, mode: T2, compare(o2, a2) {
    return o2 === a2;
  }, orientation: computed(() => i2.horizontal ? "horizontal" : "vertical"), labelRef: p2, buttonRef: d2, optionsRef: m2, disabled: computed(() => i2.disabled), options: s2, searchQuery: O2, activeOptionIndex: t2, activationTrigger: l2, closeListbox() {
    i2.disabled || e2.value !== 1 && (e2.value = 1, t2.value = null);
  }, openListbox() {
    i2.disabled || e2.value !== 0 && (e2.value = 0);
  }, goToOption(o2, a2, u2) {
    if (i2.disabled || e2.value === 1)
      return;
    let f2 = w2(), g2 = x$2(o2 === a$3.Specific ? { focus: a$3.Specific, id: a2 } : { focus: o2 }, { resolveItems: () => f2.options, resolveActiveIndex: () => f2.activeOptionIndex, resolveId: (y2) => y2.id, resolveDisabled: (y2) => y2.dataRef.disabled });
    O2.value = "", t2.value = g2, l2.value = u2 != null ? u2 : 1, s2.value = f2.options;
  }, search(o2) {
    if (i2.disabled || e2.value === 1)
      return;
    let u2 = O2.value !== "" ? 0 : 1;
    O2.value += o2.toLowerCase();
    let g2 = (t2.value !== null ? s2.value.slice(t2.value + u2).concat(s2.value.slice(0, t2.value + u2)) : s2.value).find((V) => V.dataRef.textValue.startsWith(O2.value) && !V.dataRef.disabled), y2 = g2 ? s2.value.indexOf(g2) : -1;
    y2 === -1 || y2 === t2.value || (t2.value = y2, l2.value = 1);
  }, clearSearch() {
    i2.disabled || e2.value !== 1 && O2.value !== "" && (O2.value = "");
  }, registerOption(o2, a2) {
    let u2 = w2((f2) => [...f2, { id: o2, dataRef: a2 }]);
    s2.value = u2.options, t2.value = u2.activeOptionIndex;
  }, unregisterOption(o2) {
    let a2 = w2((u2) => {
      let f2 = u2.findIndex((g2) => g2.id === o2);
      return f2 !== -1 && u2.splice(f2, 1), u2;
    });
    s2.value = a2.options, t2.value = a2.activeOptionIndex, l2.value = 1;
  }, select(o2) {
    i2.disabled || S2("update:modelValue", u$4(T2.value, { [0]: () => o2, [1]: () => {
      let a2 = toRaw(r2.value.value).slice(), u2 = toRaw(o2), f2 = a2.findIndex((g2) => r2.compare(u2, toRaw(g2)));
      return f2 === -1 ? a2.push(u2) : a2.splice(f2, 1), a2;
    } }));
  } };
  return T$2([d2, m2], (o2, a2) => {
    var u2;
    r2.closeListbox(), F$2(a2, M$2.Loose) || (o2.preventDefault(), (u2 = o$2(d2)) == null || u2.focus());
  }, computed(() => e2.value === 0)), provide(H$1, r2), c$3(computed(() => u$4(e2.value, { [0]: l$2.Open, [1]: l$2.Closed }))), () => {
    let { name: o2, modelValue: a2, disabled: u2, ...f2 } = i2, g2 = { open: e2.value === 0, disabled: u2 };
    return h$4(Fragment, [...o2 != null && a2 != null ? e$1({ [o2]: a2 }).map(([y2, V]) => h$4(m$2, A$2({ features: p$4.Hidden, key: y2, as: "input", type: "hidden", hidden: true, readOnly: true, name: y2, value: V }))) : [], P$4({ ourProps: {}, theirProps: { ...n2, ...N$3(f2, ["onUpdate:modelValue", "horizontal", "multiple", "by"]) }, slot: g2, slots: x2, attrs: n2, name: "Listbox" })]);
  };
} }), Te$1 = defineComponent({ name: "ListboxLabel", props: { as: { type: [Object, String], default: "label" } }, setup(i2, { attrs: x2, slots: n2 }) {
  let S2 = I$2("ListboxLabel"), e2 = `headlessui-listbox-label-${t$2()}`;
  function p2() {
    var d2;
    (d2 = o$2(S2.buttonRef)) == null || d2.focus({ preventScroll: true });
  }
  return () => {
    let d2 = { open: S2.listboxState.value === 0, disabled: S2.disabled.value }, m2 = { id: e2, ref: S2.labelRef, onClick: p2 };
    return P$4({ ourProps: m2, theirProps: i2, slot: d2, attrs: x2, slots: n2, name: "ListboxLabel" });
  };
} }), ke$1 = defineComponent({ name: "ListboxButton", props: { as: { type: [Object, String], default: "button" } }, setup(i2, { attrs: x2, slots: n2, expose: S2 }) {
  let e2 = I$2("ListboxButton"), p2 = `headlessui-listbox-button-${t$2()}`;
  S2({ el: e2.buttonRef, $el: e2.buttonRef });
  function d2(t2) {
    switch (t2.key) {
      case o$3.Space:
      case o$3.Enter:
      case o$3.ArrowDown:
        t2.preventDefault(), e2.openListbox(), nextTick(() => {
          var l2;
          (l2 = o$2(e2.optionsRef)) == null || l2.focus({ preventScroll: true }), e2.value.value || e2.goToOption(a$3.First);
        });
        break;
      case o$3.ArrowUp:
        t2.preventDefault(), e2.openListbox(), nextTick(() => {
          var l2;
          (l2 = o$2(e2.optionsRef)) == null || l2.focus({ preventScroll: true }), e2.value.value || e2.goToOption(a$3.Last);
        });
        break;
    }
  }
  function m2(t2) {
    switch (t2.key) {
      case o$3.Space:
        t2.preventDefault();
        break;
    }
  }
  function s2(t2) {
    e2.disabled.value || (e2.listboxState.value === 0 ? (e2.closeListbox(), nextTick(() => {
      var l2;
      return (l2 = o$2(e2.buttonRef)) == null ? void 0 : l2.focus({ preventScroll: true });
    })) : (t2.preventDefault(), e2.openListbox(), re$1(() => {
      var l2;
      return (l2 = o$2(e2.optionsRef)) == null ? void 0 : l2.focus({ preventScroll: true });
    })));
  }
  let O2 = b$3(computed(() => ({ as: i2.as, type: x2.type })), e2.buttonRef);
  return () => {
    var w2, h2;
    let t2 = { open: e2.listboxState.value === 0, disabled: e2.disabled.value }, l2 = { ref: e2.buttonRef, id: p2, type: O2.value, "aria-haspopup": true, "aria-controls": (w2 = o$2(e2.optionsRef)) == null ? void 0 : w2.id, "aria-expanded": e2.disabled.value ? void 0 : e2.listboxState.value === 0, "aria-labelledby": e2.labelRef.value ? [(h2 = o$2(e2.labelRef)) == null ? void 0 : h2.id, p2].join(" ") : void 0, disabled: e2.disabled.value === true ? true : void 0, onKeydown: d2, onKeyup: m2, onClick: s2 };
    return P$4({ ourProps: l2, theirProps: i2, slot: t2, attrs: x2, slots: n2, name: "ListboxButton" });
  };
} }), Ce$1 = defineComponent({ name: "ListboxOptions", props: { as: { type: [Object, String], default: "ul" }, static: { type: Boolean, default: false }, unmount: { type: Boolean, default: true } }, setup(i2, { attrs: x2, slots: n2, expose: S2 }) {
  let e2 = I$2("ListboxOptions"), p2 = `headlessui-listbox-options-${t$2()}`, d2 = ref(null);
  S2({ el: e2.optionsRef, $el: e2.optionsRef });
  function m2(t2) {
    switch (d2.value && clearTimeout(d2.value), t2.key) {
      case o$3.Space:
        if (e2.searchQuery.value !== "")
          return t2.preventDefault(), t2.stopPropagation(), e2.search(t2.key);
      case o$3.Enter:
        if (t2.preventDefault(), t2.stopPropagation(), e2.activeOptionIndex.value !== null) {
          let l2 = e2.options.value[e2.activeOptionIndex.value];
          e2.select(l2.dataRef.value);
        }
        e2.mode.value === 0 && (e2.closeListbox(), nextTick(() => {
          var l2;
          return (l2 = o$2(e2.buttonRef)) == null ? void 0 : l2.focus({ preventScroll: true });
        }));
        break;
      case u$4(e2.orientation.value, { vertical: o$3.ArrowDown, horizontal: o$3.ArrowRight }):
        return t2.preventDefault(), t2.stopPropagation(), e2.goToOption(a$3.Next);
      case u$4(e2.orientation.value, { vertical: o$3.ArrowUp, horizontal: o$3.ArrowLeft }):
        return t2.preventDefault(), t2.stopPropagation(), e2.goToOption(a$3.Previous);
      case o$3.Home:
      case o$3.PageUp:
        return t2.preventDefault(), t2.stopPropagation(), e2.goToOption(a$3.First);
      case o$3.End:
      case o$3.PageDown:
        return t2.preventDefault(), t2.stopPropagation(), e2.goToOption(a$3.Last);
      case o$3.Escape:
        t2.preventDefault(), t2.stopPropagation(), e2.closeListbox(), nextTick(() => {
          var l2;
          return (l2 = o$2(e2.buttonRef)) == null ? void 0 : l2.focus({ preventScroll: true });
        });
        break;
      case o$3.Tab:
        t2.preventDefault(), t2.stopPropagation();
        break;
      default:
        t2.key.length === 1 && (e2.search(t2.key), d2.value = setTimeout(() => e2.clearSearch(), 350));
        break;
    }
  }
  let s2 = p$5(), O2 = computed(() => s2 !== null ? s2.value === l$2.Open : e2.listboxState.value === 0);
  return () => {
    var h2, T2, r2, o2;
    let t2 = { open: e2.listboxState.value === 0 }, l2 = { "aria-activedescendant": e2.activeOptionIndex.value === null || (h2 = e2.options.value[e2.activeOptionIndex.value]) == null ? void 0 : h2.id, "aria-multiselectable": e2.mode.value === 1 ? true : void 0, "aria-labelledby": (o2 = (T2 = o$2(e2.labelRef)) == null ? void 0 : T2.id) != null ? o2 : (r2 = o$2(e2.buttonRef)) == null ? void 0 : r2.id, "aria-orientation": e2.orientation.value, id: p2, onKeydown: m2, role: "listbox", tabIndex: 0, ref: e2.optionsRef };
    return P$4({ ourProps: l2, theirProps: i2, slot: t2, attrs: x2, slots: n2, features: R$2.RenderStrategy | R$2.Static, visible: O2.value, name: "ListboxOptions" });
  };
} }), Me$1 = defineComponent({ name: "ListboxOption", props: { as: { type: [Object, String], default: "li" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: false } }, setup(i2, { slots: x2, attrs: n2, expose: S2 }) {
  let e2 = I$2("ListboxOption"), p2 = `headlessui-listbox-option-${t$2()}`, d2 = ref(null);
  S2({ el: d2, $el: d2 });
  let m2 = computed(() => e2.activeOptionIndex.value !== null ? e2.options.value[e2.activeOptionIndex.value].id === p2 : false), s2 = computed(() => u$4(e2.mode.value, { [0]: () => e2.compare(toRaw(e2.value.value), toRaw(i2.value)), [1]: () => toRaw(e2.value.value).some((r2) => e2.compare(toRaw(r2), toRaw(i2.value))) })), O2 = computed(() => u$4(e2.mode.value, { [1]: () => {
    var o2;
    let r2 = toRaw(e2.value.value);
    return ((o2 = e2.options.value.find((a2) => r2.some((u2) => e2.compare(toRaw(u2), toRaw(a2.dataRef.value))))) == null ? void 0 : o2.id) === p2;
  }, [0]: () => s2.value })), t2 = computed(() => ({ disabled: i2.disabled, value: i2.value, textValue: "", domRef: d2 }));
  onMounted(() => {
    var o2, a2;
    let r2 = (a2 = (o2 = o$2(d2)) == null ? void 0 : o2.textContent) == null ? void 0 : a2.toLowerCase().trim();
    r2 !== void 0 && (t2.value.textValue = r2);
  }), onMounted(() => e2.registerOption(p2, t2)), onUnmounted(() => e2.unregisterOption(p2)), onMounted(() => {
    watch([e2.listboxState, s2], () => {
      e2.listboxState.value === 0 && (!s2.value || u$4(e2.mode.value, { [1]: () => {
        O2.value && e2.goToOption(a$3.Specific, p2);
      }, [0]: () => {
        e2.goToOption(a$3.Specific, p2);
      } }));
    }, { immediate: true });
  }), watchEffect(() => {
    e2.listboxState.value === 0 && (!m2.value || e2.activationTrigger.value !== 0 && nextTick(() => {
      var r2, o2;
      return (o2 = (r2 = o$2(d2)) == null ? void 0 : r2.scrollIntoView) == null ? void 0 : o2.call(r2, { block: "nearest" });
    }));
  });
  function l2(r2) {
    if (i2.disabled)
      return r2.preventDefault();
    e2.select(i2.value), e2.mode.value === 0 && (e2.closeListbox(), nextTick(() => {
      var o2;
      return (o2 = o$2(e2.buttonRef)) == null ? void 0 : o2.focus({ preventScroll: true });
    }));
  }
  function w2() {
    if (i2.disabled)
      return e2.goToOption(a$3.Nothing);
    e2.goToOption(a$3.Specific, p2);
  }
  function h2() {
    i2.disabled || m2.value || e2.goToOption(a$3.Specific, p2, 0);
  }
  function T2() {
    i2.disabled || !m2.value || e2.goToOption(a$3.Nothing);
  }
  return () => {
    let { disabled: r2 } = i2, o2 = { active: m2.value, selected: s2.value, disabled: r2 }, a2 = { id: p2, ref: d2, role: "option", tabIndex: r2 === true ? void 0 : -1, "aria-disabled": r2 === true ? true : void 0, "aria-selected": s2.value === true ? s2.value : void 0, disabled: void 0, onClick: l2, onFocus: w2, onPointermove: h2, onMousemove: h2, onPointerleave: T2, onMouseleave: T2 };
    return P$4({ ourProps: a2, theirProps: N$3(i2, ["value", "disabled"]), slot: o2, attrs: n2, slots: x2, name: "ListboxOption" });
  };
} });
let a$2 = Symbol("LabelContext");
function p$2() {
  let t2 = inject(a$2, null);
  if (t2 === null) {
    let n2 = new Error("You used a <Label /> component, but it is not inside a parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(n2, p$2), n2;
  }
  return t2;
}
function K$1({ slot: t2 = {}, name: n2 = "Label", props: i2 = {} } = {}) {
  let e2 = ref([]);
  function r2(o2) {
    return e2.value.push(o2), () => {
      let l2 = e2.value.indexOf(o2);
      l2 !== -1 && e2.value.splice(l2, 1);
    };
  }
  return provide(a$2, { register: r2, slot: t2, name: n2, props: i2 }), computed(() => e2.value.length > 0 ? e2.value.join(" ") : void 0);
}
let P$2 = defineComponent({ name: "Label", props: { as: { type: [Object, String], default: "label" }, passive: { type: [Boolean], default: false } }, setup(t2, { slots: n2, attrs: i2 }) {
  let e2 = p$2(), r2 = `headlessui-label-${t$2()}`;
  return onMounted(() => onUnmounted(e2.register(r2))), () => {
    let { name: o2 = "Label", slot: l2 = {}, props: d2 = {} } = e2, { passive: c2, ...s2 } = t2, u2 = { ...Object.entries(d2).reduce((f2, [b2, m2]) => Object.assign(f2, { [b2]: unref(m2) }), {}), id: r2 };
    return c2 && (delete u2.onClick, delete s2.onClick), P$4({ ourProps: u2, theirProps: s2, slot: l2, attrs: i2, slots: n2, name: o2 });
  };
} });
let h$3 = Symbol("GroupContext");
defineComponent({ name: "SwitchGroup", props: { as: { type: [Object, String], default: "template" } }, setup(l2, { slots: a2, attrs: n2 }) {
  let r2 = ref(null), u2 = K$1({ name: "SwitchLabel", props: { onClick() {
    !r2.value || (r2.value.click(), r2.value.focus({ preventScroll: true }));
  } } }), t2 = P$3({ name: "SwitchDescription" });
  return provide(h$3, { switchRef: r2, labelledby: u2, describedby: t2 }), () => P$4({ theirProps: l2, ourProps: {}, slot: {}, slots: a2, attrs: n2, name: "SwitchGroup" });
} });
let Y$2 = defineComponent({ name: "Switch", emits: { "update:modelValue": (l2) => true }, props: { as: { type: [Object, String], default: "button" }, modelValue: { type: Boolean, default: false }, name: { type: String, optional: true }, value: { type: String, optional: true } }, inheritAttrs: false, setup(l2, { emit: a2, attrs: n2, slots: r2, expose: u2 }) {
  let t2 = inject(h$3, null), p2 = `headlessui-switch-${t$2()}`;
  function s2() {
    a2("update:modelValue", !l2.modelValue);
  }
  let b2 = ref(null), i2 = t2 === null ? b2 : t2.switchRef, S2 = b$3(computed(() => ({ as: l2.as, type: n2.type })), i2);
  u2({ el: i2, $el: i2 });
  function w2(e2) {
    e2.preventDefault(), s2();
  }
  function v2(e2) {
    e2.key === o$3.Space ? (e2.preventDefault(), s2()) : e2.key === o$3.Enter && p$3(e2.currentTarget);
  }
  function R2(e2) {
    e2.preventDefault();
  }
  return () => {
    let { name: e2, value: g2, modelValue: o2, ...k2 } = l2, D2 = { checked: o2 }, K = { id: p2, ref: i2, role: "switch", type: S2.value, tabIndex: 0, "aria-checked": o2, "aria-labelledby": t2 == null ? void 0 : t2.labelledby.value, "aria-describedby": t2 == null ? void 0 : t2.describedby.value, onClick: w2, onKeyup: v2, onKeypress: R2 };
    return h$4(Fragment, [e2 != null && o2 != null ? h$4(m$2, A$2({ features: p$4.Hidden, as: "input", type: "checkbox", hidden: true, readOnly: true, checked: o2, name: e2, value: g2 })) : null, P$4({ ourProps: K, theirProps: { ...n2, ...k2 }, slot: D2, attrs: n2, slots: r2, name: "Switch" })]);
  };
} });
P$2;
S$2;
function render$c(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$b(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$a(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$9(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$8(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M15.707 15.707a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 010 1.414zm-6 0a1 1 0 01-1.414 0l-5-5a1 1 0 010-1.414l5-5a1 1 0 011.414 1.414L5.414 10l4.293 4.293a1 1 0 010 1.414z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$7(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M10.293 15.707a1 1 0 010-1.414L14.586 10l-4.293-4.293a1 1 0 111.414-1.414l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0z",
      "clip-rule": "evenodd"
    }),
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M4.293 15.707a1 1 0 010-1.414L8.586 10 4.293 5.707a1 1 0 011.414-1.414l5 5a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$6(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$5(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$4(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$3(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$2(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
      "clip-rule": "evenodd"
    })
  ]);
}
function render$1(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", { d: "M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" })
  ]);
}
function render(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "fill-rule": "evenodd",
      d: "M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z",
      "clip-rule": "evenodd"
    })
  ]);
}
const _sfc_main$1A = {
  name: "QuestionLabel",
  props: {
    centered: { type: Boolean, default: false },
    height: { type: Number, default: 5 },
    width: { type: Number, default: 10 }
  }
};
function _sfc_render$1A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([
      `h-${$props.height} w-${$props.width} rounded-r-full bg-gray-100 flex items-center pl-1 pr-2`,
      $props.centered ? "justify-center" : "justify-between"
    ])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var QuestionLabel = /* @__PURE__ */ _export_sfc$1(_sfc_main$1A, [["render", _sfc_render$1A]]);
const _sfc_main$1z = {
  name: "SelectBox",
  components: {
    QuestionLabel,
    Listbox: we$1,
    ListboxButton: ke$1,
    ListboxLabel: Te$1,
    ListboxOption: Me$1,
    ListboxOptions: Ce$1,
    CheckIcon: render$9,
    ChevronDownIcon: render$6
  },
  props: {
    items: Array,
    modelValue: { type: [String, Number], default: null },
    label: String,
    placeholder: { type: String, default: "Choose option" },
    disabled: Boolean,
    classes: { type: String, default: "" },
    fontSize: { type: Number, default: void 0 }
  },
  emits: ["update:modelValue"],
  computed: {
    selected: function() {
      return this.items.find((i2) => i2.value + "" === this.modelValue + "");
    },
    haveIcons: function() {
      return !!this.items.find((i2) => i2.icon);
    }
  }
};
const _hoisted_1$1u = { class: "relative" };
const _hoisted_2$T = { class: "flex items-center" };
const _hoisted_3$F = { class: "ml-3 absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none" };
const _hoisted_4$q = { class: "flex items-center" };
function _sfc_render$1z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ListboxLabel = resolveComponent("ListboxLabel");
  const _component_QuestionLabel = resolveComponent("QuestionLabel");
  const _component_ChevronDownIcon = resolveComponent("ChevronDownIcon");
  const _component_ListboxButton = resolveComponent("ListboxButton");
  const _component_CheckIcon = resolveComponent("CheckIcon");
  const _component_ListboxOption = resolveComponent("ListboxOption");
  const _component_ListboxOptions = resolveComponent("ListboxOptions");
  const _component_Listbox = resolveComponent("Listbox");
  return openBlock(), createBlock(_component_Listbox, {
    as: "div",
    disabled: $props.disabled,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, {
    default: withCtx(() => [
      $props.label ? (openBlock(), createBlock(_component_ListboxLabel, {
        key: 0,
        class: "block text-txtgray font-semibold mb-3",
        style: { "font-size": "11px" }
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString($props.label) + ": ", 1)
        ]),
        _: 1
      })) : createCommentVNode("", true),
      createElementVNode("div", _hoisted_1$1u, [
        createVNode(_component_ListboxButton, {
          class: normalizeClass(["relative w-full border border-gray-300 rounded-md shadow-sm pl-1 pr-10 py-1 text-left cursor-default focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm", [$props.disabled ? "bg-gray-100" : "bg-white", $props.classes]])
        }, {
          default: withCtx(() => {
            var _a, _b;
            return [
              createElementVNode("span", _hoisted_2$T, [
                !$options.selected && $options.haveIcons ? (openBlock(), createBlock(_component_QuestionLabel, {
                  key: 0,
                  class: "bg-gray-200 mr-3",
                  height: 5,
                  width: 6
                })) : createCommentVNode("", true),
                ((_a = $options.selected) == null ? void 0 : _a.icon) ? (openBlock(), createBlock(_component_QuestionLabel, {
                  key: 1,
                  class: normalizeClass(["bg-gray-300 mr-3", $options.selected.icon.style]),
                  height: 5,
                  width: 6
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent($options.selected.icon.component), {
                      height: $options.selected.icon.height || 9
                    }, null, 8, ["height"]))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("", true),
                createElementVNode("span", {
                  class: "block truncate",
                  style: normalizeStyle({ fontSize: $props.fontSize + "px" })
                }, toDisplayString(((_b = $options.selected) == null ? void 0 : _b.title) || $props.placeholder), 5)
              ]),
              createElementVNode("span", _hoisted_3$F, [
                createVNode(_component_ChevronDownIcon, {
                  class: "h-5 w-5 text-gray-400",
                  "aria-hidden": "true"
                })
              ])
            ];
          }),
          _: 1
        }, 8, ["class"]),
        createVNode(Transition, {
          "leave-active-class": "transition ease-in duration-100",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: withCtx(() => [
            createVNode(_component_ListboxOptions, { class: "absolute z-10 mt-1 w-full bg-white shadow-lg max-h-56 rounded-md py-1 text-base ring-1 ring-black ring-opacity-5 overflow-auto focus:outline-none sm:text-sm" }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList($props.items, (item, i2) => {
                  return openBlock(), createBlock(_component_ListboxOption, {
                    key: `selectbox${i2}${item.value}`,
                    as: "template",
                    value: item.value
                  }, {
                    default: withCtx(({ active, selected }) => [
                      createElementVNode("li", {
                        class: normalizeClass([active ? "text-white bg-indigo-600" : "text-gray-900", "cursor-default select-none relative py-2 pl-3 pr-3 border-gray-100 border-b last:border-0"])
                      }, [
                        createElementVNode("div", _hoisted_4$q, [
                          item.icon ? (openBlock(), createBlock(_component_QuestionLabel, {
                            key: 0,
                            class: normalizeClass(["bg-gray-300 mr-3", item.icon.style]),
                            height: 5,
                            width: 6
                          }, {
                            default: withCtx(() => [
                              (openBlock(), createBlock(resolveDynamicComponent(item.icon.component), {
                                height: item.icon.height || 9
                              }, null, 8, ["height"]))
                            ]),
                            _: 2
                          }, 1032, ["class"])) : createCommentVNode("", true),
                          createElementVNode("span", {
                            class: normalizeClass([selected ? "font-semibold" : "font-normal", "block truncate"])
                          }, toDisplayString(item.title), 3)
                        ]),
                        selected ? (openBlock(), createElementBlock("span", {
                          key: 0,
                          class: normalizeClass([active ? "text-white" : "text-indigo-600", "absolute inset-y-0 right-0 flex items-center pr-4"])
                        }, [
                          createVNode(_component_CheckIcon, {
                            class: "h-5 w-5",
                            "aria-hidden": "true"
                          })
                        ], 2)) : createCommentVNode("", true)
                      ], 2)
                    ]),
                    _: 2
                  }, 1032, ["value"]);
                }), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ])
    ]),
    _: 1
  }, 8, ["disabled"]);
}
var SelectBox = /* @__PURE__ */ _export_sfc$1(_sfc_main$1z, [["render", _sfc_render$1z]]);
const _sfc_main$1y = {
  name: "Switch",
  components: {
    Toggler: Y$2
  },
  props: {
    modelValue: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:modelValue"]
};
const _hoisted_1$1t = /* @__PURE__ */ createElementVNode("span", { class: "sr-only" }, "Use setting", -1);
function _sfc_render$1y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Toggler = resolveComponent("Toggler");
  return openBlock(), createBlock(_component_Toggler, {
    "model-value": $props.modelValue,
    class: normalizeClass([$props.modelValue ? "bg-indigo-600" : "bg-gray-200", "relative inline-flex flex-shrink-0 h-4 w-6 border-2 border-transparent rounded-full cursor-pointer transition-colors ease-in-out duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2"]),
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
  }, {
    default: withCtx(() => [
      _hoisted_1$1t,
      createElementVNode("span", {
        "aria-hidden": "true",
        class: normalizeClass([$props.modelValue ? "translate-x-2" : "translate-x-0", "pointer-events-none inline-block h-3 w-3 rounded-full bg-white shadow transform ring-0 transition ease-in-out duration-200"])
      }, null, 2)
    ]),
    _: 1
  }, 8, ["model-value", "class"]);
}
var Switch = /* @__PURE__ */ _export_sfc$1(_sfc_main$1y, [["render", _sfc_render$1y]]);
const _sfc_main$1x = {
  components: {},
  props: {
    tabs: {
      type: Array,
      default: () => []
    },
    activeTab: {
      type: String,
      default: ""
    }
  },
  methods: {
    onChange(value) {
      this.$emit("onChange", value);
    }
  }
};
const _hoisted_1$1s = { class: "flex space-x-8" };
const _hoisted_2$S = ["onClick"];
function _sfc_render$1x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1s, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.tabs, (tab, index2) => {
      return openBlock(), createElementBlock("div", { key: index2 }, [
        createElementVNode("div", {
          class: normalizeClass(["text-base cursor-pointer", $props.activeTab === tab.value ? "border-b-2 border-dsblue" : ""]),
          onClick: ($event) => $options.onChange(tab.value)
        }, toDisplayString(tab.label), 11, _hoisted_2$S)
      ]);
    }), 128))
  ]);
}
var Tabs = /* @__PURE__ */ _export_sfc$1(_sfc_main$1x, [["render", _sfc_render$1x]]);
const _sfc_main$1w = {
  computed: {
    errors() {
      return this.$page.props.errors;
    },
    hasErrors() {
      return Object.keys(this.errors).length > 0;
    }
  }
};
const _hoisted_1$1r = { key: 0 };
const _hoisted_2$R = /* @__PURE__ */ createElementVNode("div", { class: "font-medium text-red-600" }, "Whoops! Something went wrong.", -1);
const _hoisted_3$E = { class: "mt-3 list-disc list-inside text-sm text-red-600" };
function _sfc_render$1w(_ctx, _cache, $props, $setup, $data, $options) {
  return $options.hasErrors ? (openBlock(), createElementBlock("div", _hoisted_1$1r, [
    _hoisted_2$R,
    createElementVNode("ul", _hoisted_3$E, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.errors, (error, key) => {
        return openBlock(), createElementBlock("li", { key }, toDisplayString(error), 1);
      }), 128))
    ])
  ])) : createCommentVNode("", true);
}
var ValidationErrors = /* @__PURE__ */ _export_sfc$1(_sfc_main$1w, [["render", _sfc_render$1w]]);
const _sfc_main$1v = {
  name: "ActionButtons",
  emits: ["click:ok", "click:cancel"]
};
const _hoisted_1$1q = { class: "flex gap-3" };
function _sfc_render$1v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1q, [
    createElementVNode("button", {
      class: "bg-blue-600 rounded text-white px-9 py-1.5 font-semibold hover:bg-blue-800 duration-300",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click:ok"))
    }, " Ok "),
    createElementVNode("button", {
      type: "button",
      class: "border border-blue-600 rounded text-blue-600 px-6 py-1.5 font-semibold hover:text-blue-800 hover:border-blue-800 duration-300",
      onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click:cancel"))
    }, " Cancel ")
  ]);
}
var ActionButtons = /* @__PURE__ */ _export_sfc$1(_sfc_main$1v, [["render", _sfc_render$1v]]);
function assertNonEmptyString(str) {
  if (typeof str !== "string" || !str) {
    throw new Error("expected a non-empty string, got: " + str);
  }
}
function assertNumber(number) {
  if (typeof number !== "number") {
    throw new Error("expected a number, got: " + number);
  }
}
const DB_VERSION_CURRENT = 1;
const DB_VERSION_INITIAL = 1;
const STORE_EMOJI = "emoji";
const STORE_KEYVALUE = "keyvalue";
const STORE_FAVORITES = "favorites";
const FIELD_TOKENS = "tokens";
const INDEX_TOKENS = "tokens";
const FIELD_UNICODE = "unicode";
const INDEX_COUNT = "count";
const FIELD_GROUP = "group";
const FIELD_ORDER = "order";
const INDEX_GROUP_AND_ORDER = "group-order";
const KEY_ETAG = "eTag";
const KEY_URL = "url";
const KEY_PREFERRED_SKINTONE = "skinTone";
const MODE_READONLY = "readonly";
const MODE_READWRITE = "readwrite";
const INDEX_SKIN_UNICODE = "skinUnicodes";
const FIELD_SKIN_UNICODE = "skinUnicodes";
const DEFAULT_DATA_SOURCE$1 = "https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json";
const DEFAULT_LOCALE$1 = "en";
function uniqBy$1(arr, func) {
  const set2 = /* @__PURE__ */ new Set();
  const res = [];
  for (const item of arr) {
    const key = func(item);
    if (!set2.has(key)) {
      set2.add(key);
      res.push(item);
    }
  }
  return res;
}
function uniqEmoji(emojis) {
  return uniqBy$1(emojis, (_2) => _2.unicode);
}
function initialMigration(db) {
  function createObjectStore(name, keyPath, indexes) {
    const store = keyPath ? db.createObjectStore(name, { keyPath }) : db.createObjectStore(name);
    if (indexes) {
      for (const [indexName, [keyPath2, multiEntry]] of Object.entries(indexes)) {
        store.createIndex(indexName, keyPath2, { multiEntry });
      }
    }
    return store;
  }
  createObjectStore(STORE_KEYVALUE);
  createObjectStore(STORE_EMOJI, FIELD_UNICODE, {
    [INDEX_TOKENS]: [FIELD_TOKENS, true],
    [INDEX_GROUP_AND_ORDER]: [[FIELD_GROUP, FIELD_ORDER]],
    [INDEX_SKIN_UNICODE]: [FIELD_SKIN_UNICODE, true]
  });
  createObjectStore(STORE_FAVORITES, void 0, {
    [INDEX_COUNT]: [""]
  });
}
const openReqs = {};
const databaseCache = {};
const onCloseListeners = {};
function handleOpenOrDeleteReq(resolve, reject, req) {
  req.onerror = () => reject(req.error);
  req.onblocked = () => reject(new Error("IDB blocked"));
  req.onsuccess = () => resolve(req.result);
}
async function createDatabase(dbName) {
  const db = await new Promise((resolve, reject) => {
    const req = indexedDB.open(dbName, DB_VERSION_CURRENT);
    openReqs[dbName] = req;
    req.onupgradeneeded = (e2) => {
      if (e2.oldVersion < DB_VERSION_INITIAL) {
        initialMigration(req.result);
      }
    };
    handleOpenOrDeleteReq(resolve, reject, req);
  });
  db.onclose = () => closeDatabase(dbName);
  return db;
}
function openDatabase(dbName) {
  if (!databaseCache[dbName]) {
    databaseCache[dbName] = createDatabase(dbName);
  }
  return databaseCache[dbName];
}
function dbPromise(db, storeName, readOnlyOrReadWrite, cb) {
  return new Promise((resolve, reject) => {
    const txn = db.transaction(storeName, readOnlyOrReadWrite, { durability: "relaxed" });
    const store = typeof storeName === "string" ? txn.objectStore(storeName) : storeName.map((name) => txn.objectStore(name));
    let res;
    cb(store, txn, (result) => {
      res = result;
    });
    txn.oncomplete = () => resolve(res);
    txn.onerror = () => reject(txn.error);
  });
}
function closeDatabase(dbName) {
  const req = openReqs[dbName];
  const db = req && req.result;
  if (db) {
    db.close();
    const listeners = onCloseListeners[dbName];
    if (listeners) {
      for (const listener of listeners) {
        listener();
      }
    }
  }
  delete openReqs[dbName];
  delete databaseCache[dbName];
  delete onCloseListeners[dbName];
}
function deleteDatabase(dbName) {
  return new Promise((resolve, reject) => {
    closeDatabase(dbName);
    const req = indexedDB.deleteDatabase(dbName);
    handleOpenOrDeleteReq(resolve, reject, req);
  });
}
function addOnCloseListener(dbName, listener) {
  let listeners = onCloseListeners[dbName];
  if (!listeners) {
    listeners = onCloseListeners[dbName] = [];
  }
  listeners.push(listener);
}
const irregularEmoticons = /* @__PURE__ */ new Set([
  ":D",
  "XD",
  ":'D",
  "O:)",
  ":X",
  ":P",
  ";P",
  "XP",
  ":L",
  ":Z",
  ":j",
  "8D",
  "XO",
  "8)",
  ":B",
  ":O",
  ":S",
  ":'o",
  "Dx",
  "X(",
  "D:",
  ":C",
  ">0)",
  ":3",
  "</3",
  "<3",
  "\\M/",
  ":E",
  "8#"
]);
function extractTokens(str) {
  return str.split(/[\s_]+/).map((word) => {
    if (!word.match(/\w/) || irregularEmoticons.has(word)) {
      return word.toLowerCase();
    }
    return word.replace(/[)(:,]/g, "").replace(//g, "'").toLowerCase();
  }).filter(Boolean);
}
const MIN_SEARCH_TEXT_LENGTH$1 = 2;
function normalizeTokens(str) {
  return str.filter(Boolean).map((_2) => _2.toLowerCase()).filter((_2) => _2.length >= MIN_SEARCH_TEXT_LENGTH$1);
}
function transformEmojiData(emojiData) {
  const res = emojiData.map(({ annotation, emoticon, group, order: order2, shortcodes, skins, tags, emoji, version: version2 }) => {
    const tokens2 = [...new Set(
      normalizeTokens([
        ...(shortcodes || []).map(extractTokens).flat(),
        ...tags.map(extractTokens).flat(),
        ...extractTokens(annotation),
        emoticon
      ])
    )].sort();
    const res2 = {
      annotation,
      group,
      order: order2,
      tags,
      tokens: tokens2,
      unicode: emoji,
      version: version2
    };
    if (emoticon) {
      res2.emoticon = emoticon;
    }
    if (shortcodes) {
      res2.shortcodes = shortcodes;
    }
    if (skins) {
      res2.skinTones = [];
      res2.skinUnicodes = [];
      res2.skinVersions = [];
      for (const { tone, emoji: emoji2, version: version3 } of skins) {
        res2.skinTones.push(tone);
        res2.skinUnicodes.push(emoji2);
        res2.skinVersions.push(version3);
      }
    }
    return res2;
  });
  return res;
}
function callStore(store, method, key, cb) {
  store[method](key).onsuccess = (e2) => cb && cb(e2.target.result);
}
function getIDB(store, key, cb) {
  callStore(store, "get", key, cb);
}
function getAllIDB(store, key, cb) {
  callStore(store, "getAll", key, cb);
}
function commit(txn) {
  if (txn.commit) {
    txn.commit();
  }
}
function minBy(array, func) {
  let minItem = array[0];
  for (let i2 = 1; i2 < array.length; i2++) {
    const item = array[i2];
    if (func(minItem) > func(item)) {
      minItem = item;
    }
  }
  return minItem;
}
function findCommonMembers(arrays, uniqByFunc) {
  const shortestArray = minBy(arrays, (_2) => _2.length);
  const results = [];
  for (const item of shortestArray) {
    if (!arrays.some((array) => array.findIndex((_2) => uniqByFunc(_2) === uniqByFunc(item)) === -1)) {
      results.push(item);
    }
  }
  return results;
}
async function isEmpty(db) {
  return !await get$3(db, STORE_KEYVALUE, KEY_URL);
}
async function hasData(db, url, eTag) {
  const [oldETag, oldUrl] = await Promise.all([KEY_ETAG, KEY_URL].map((key) => get$3(db, STORE_KEYVALUE, key)));
  return oldETag === eTag && oldUrl === url;
}
async function doFullDatabaseScanForSingleResult(db, predicate) {
  const BATCH_SIZE = 50;
  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {
    let lastKey;
    const processNextBatch = () => {
      emojiStore.getAll(lastKey && IDBKeyRange.lowerBound(lastKey, true), BATCH_SIZE).onsuccess = (e2) => {
        const results = e2.target.result;
        for (const result of results) {
          lastKey = result.unicode;
          if (predicate(result)) {
            return cb(result);
          }
        }
        if (results.length < BATCH_SIZE) {
          return cb();
        }
        processNextBatch();
      };
    };
    processNextBatch();
  });
}
async function loadData(db, emojiData, url, eTag) {
  try {
    const transformedData = transformEmojiData(emojiData);
    await dbPromise(db, [STORE_EMOJI, STORE_KEYVALUE], MODE_READWRITE, ([emojiStore, metaStore], txn) => {
      let oldETag;
      let oldUrl;
      let todo = 0;
      function checkFetched() {
        if (++todo === 2) {
          onFetched();
        }
      }
      function onFetched() {
        if (oldETag === eTag && oldUrl === url) {
          return;
        }
        emojiStore.clear();
        for (const data2 of transformedData) {
          emojiStore.put(data2);
        }
        metaStore.put(eTag, KEY_ETAG);
        metaStore.put(url, KEY_URL);
        commit(txn);
      }
      getIDB(metaStore, KEY_ETAG, (result) => {
        oldETag = result;
        checkFetched();
      });
      getIDB(metaStore, KEY_URL, (result) => {
        oldUrl = result;
        checkFetched();
      });
    });
  } finally {
  }
}
async function getEmojiByGroup(db, group) {
  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {
    const range = IDBKeyRange.bound([group, 0], [group + 1, 0], false, true);
    getAllIDB(emojiStore.index(INDEX_GROUP_AND_ORDER), range, cb);
  });
}
async function getEmojiBySearchQuery(db, query) {
  const tokens2 = normalizeTokens(extractTokens(query));
  if (!tokens2.length) {
    return [];
  }
  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => {
    const intermediateResults = [];
    const checkDone = () => {
      if (intermediateResults.length === tokens2.length) {
        onDone();
      }
    };
    const onDone = () => {
      const results = findCommonMembers(intermediateResults, (_2) => _2.unicode);
      cb(results.sort((a2, b2) => a2.order < b2.order ? -1 : 1));
    };
    for (let i2 = 0; i2 < tokens2.length; i2++) {
      const token2 = tokens2[i2];
      const range = i2 === tokens2.length - 1 ? IDBKeyRange.bound(token2, token2 + "\uFFFF", false, true) : IDBKeyRange.only(token2);
      getAllIDB(emojiStore.index(INDEX_TOKENS), range, (result) => {
        intermediateResults.push(result);
        checkDone();
      });
    }
  });
}
async function getEmojiByShortcode(db, shortcode) {
  const emojis = await getEmojiBySearchQuery(db, shortcode);
  if (!emojis.length) {
    const predicate = (_2) => (_2.shortcodes || []).includes(shortcode.toLowerCase());
    return await doFullDatabaseScanForSingleResult(db, predicate) || null;
  }
  return emojis.filter((_2) => {
    const lowerShortcodes = (_2.shortcodes || []).map((_3) => _3.toLowerCase());
    return lowerShortcodes.includes(shortcode.toLowerCase());
  })[0] || null;
}
async function getEmojiByUnicode(db, unicode) {
  return dbPromise(db, STORE_EMOJI, MODE_READONLY, (emojiStore, txn, cb) => getIDB(emojiStore, unicode, (result) => {
    if (result) {
      return cb(result);
    }
    getIDB(emojiStore.index(INDEX_SKIN_UNICODE), unicode, (result2) => cb(result2 || null));
  }));
}
function get$3(db, storeName, key) {
  return dbPromise(db, storeName, MODE_READONLY, (store, txn, cb) => getIDB(store, key, cb));
}
function set$2(db, storeName, key, value) {
  return dbPromise(db, storeName, MODE_READWRITE, (store, txn) => {
    store.put(value, key);
    commit(txn);
  });
}
function incrementFavoriteEmojiCount(db, unicode) {
  return dbPromise(db, STORE_FAVORITES, MODE_READWRITE, (store, txn) => getIDB(store, unicode, (result) => {
    store.put((result || 0) + 1, unicode);
    commit(txn);
  }));
}
function getTopFavoriteEmoji(db, customEmojiIndex2, limit) {
  if (limit === 0) {
    return [];
  }
  return dbPromise(db, [STORE_FAVORITES, STORE_EMOJI], MODE_READONLY, ([favoritesStore, emojiStore], txn, cb) => {
    const results = [];
    favoritesStore.index(INDEX_COUNT).openCursor(void 0, "prev").onsuccess = (e2) => {
      const cursor2 = e2.target.result;
      if (!cursor2) {
        return cb(results);
      }
      function addResult(result) {
        results.push(result);
        if (results.length === limit) {
          return cb(results);
        }
        cursor2.continue();
      }
      const unicodeOrName = cursor2.primaryKey;
      const custom = customEmojiIndex2.byName(unicodeOrName);
      if (custom) {
        return addResult(custom);
      }
      getIDB(emojiStore, unicodeOrName, (emoji) => {
        if (emoji) {
          return addResult(emoji);
        }
        cursor2.continue();
      });
    };
  });
}
const CODA_MARKER = "";
function trie(arr, itemToTokens) {
  const map2 = /* @__PURE__ */ new Map();
  for (const item of arr) {
    const tokens2 = itemToTokens(item);
    for (const token2 of tokens2) {
      let currentMap = map2;
      for (let i2 = 0; i2 < token2.length; i2++) {
        const char = token2.charAt(i2);
        let nextMap = currentMap.get(char);
        if (!nextMap) {
          nextMap = /* @__PURE__ */ new Map();
          currentMap.set(char, nextMap);
        }
        currentMap = nextMap;
      }
      let valuesAtCoda = currentMap.get(CODA_MARKER);
      if (!valuesAtCoda) {
        valuesAtCoda = [];
        currentMap.set(CODA_MARKER, valuesAtCoda);
      }
      valuesAtCoda.push(item);
    }
  }
  const search = (query, exact) => {
    let currentMap = map2;
    for (let i2 = 0; i2 < query.length; i2++) {
      const char = query.charAt(i2);
      const nextMap = currentMap.get(char);
      if (nextMap) {
        currentMap = nextMap;
      } else {
        return [];
      }
    }
    if (exact) {
      const results2 = currentMap.get(CODA_MARKER);
      return results2 || [];
    }
    const results = [];
    const queue = [currentMap];
    while (queue.length) {
      const currentMap2 = queue.shift();
      const entriesSortedByKey = [...currentMap2.entries()].sort((a2, b2) => a2[0] < b2[0] ? -1 : 1);
      for (const [key, value] of entriesSortedByKey) {
        if (key === CODA_MARKER) {
          results.push(...value);
        } else {
          queue.push(value);
        }
      }
    }
    return results;
  };
  return search;
}
const requiredKeys$1 = [
  "name",
  "url"
];
function assertCustomEmojis(customEmojis) {
  const isArray2 = customEmojis && Array.isArray(customEmojis);
  const firstItemIsFaulty = isArray2 && customEmojis.length && (!customEmojis[0] || requiredKeys$1.some((key) => !(key in customEmojis[0])));
  if (!isArray2 || firstItemIsFaulty) {
    throw new Error("Custom emojis are in the wrong format");
  }
}
function customEmojiIndex(customEmojis) {
  assertCustomEmojis(customEmojis);
  const sortByName = (a2, b2) => a2.name.toLowerCase() < b2.name.toLowerCase() ? -1 : 1;
  const all2 = customEmojis.sort(sortByName);
  const emojiToTokens = (emoji) => [...new Set((emoji.shortcodes || []).map((shortcode) => extractTokens(shortcode)).flat())];
  const searchTrie = trie(customEmojis, emojiToTokens);
  const searchByExactMatch = (_2) => searchTrie(_2, true);
  const searchByPrefix = (_2) => searchTrie(_2, false);
  const search = (query) => {
    const tokens2 = extractTokens(query);
    const intermediateResults = tokens2.map((token2, i2) => (i2 < tokens2.length - 1 ? searchByExactMatch : searchByPrefix)(token2));
    return findCommonMembers(intermediateResults, (_2) => _2.name).sort(sortByName);
  };
  const shortcodeToEmoji = /* @__PURE__ */ new Map();
  const nameToEmoji = /* @__PURE__ */ new Map();
  for (const customEmoji of customEmojis) {
    nameToEmoji.set(customEmoji.name.toLowerCase(), customEmoji);
    for (const shortcode of customEmoji.shortcodes || []) {
      shortcodeToEmoji.set(shortcode.toLowerCase(), customEmoji);
    }
  }
  const byShortcode = (shortcode) => shortcodeToEmoji.get(shortcode.toLowerCase());
  const byName = (name) => nameToEmoji.get(name.toLowerCase());
  return {
    all: all2,
    search,
    byShortcode,
    byName
  };
}
function cleanEmoji(emoji) {
  if (!emoji) {
    return emoji;
  }
  delete emoji.tokens;
  if (emoji.skinTones) {
    const len = emoji.skinTones.length;
    emoji.skins = Array(len);
    for (let i2 = 0; i2 < len; i2++) {
      emoji.skins[i2] = {
        tone: emoji.skinTones[i2],
        unicode: emoji.skinUnicodes[i2],
        version: emoji.skinVersions[i2]
      };
    }
    delete emoji.skinTones;
    delete emoji.skinUnicodes;
    delete emoji.skinVersions;
  }
  return emoji;
}
function warnETag(eTag) {
  if (!eTag) {
    console.warn("emoji-picker-element is more efficient if the dataSource server exposes an ETag header.");
  }
}
const requiredKeys = [
  "annotation",
  "emoji",
  "group",
  "order",
  "tags",
  "version"
];
function assertEmojiData(emojiData) {
  if (!emojiData || !Array.isArray(emojiData) || !emojiData[0] || typeof emojiData[0] !== "object" || requiredKeys.some((key) => !(key in emojiData[0]))) {
    throw new Error("Emoji data is in the wrong format");
  }
}
function assertStatus(response, dataSource) {
  if (Math.floor(response.status / 100) !== 2) {
    throw new Error("Failed to fetch: " + dataSource + ":  " + response.status);
  }
}
async function getETag(dataSource) {
  const response = await fetch(dataSource, { method: "HEAD" });
  assertStatus(response, dataSource);
  const eTag = response.headers.get("etag");
  warnETag(eTag);
  return eTag;
}
async function getETagAndData(dataSource) {
  const response = await fetch(dataSource);
  assertStatus(response, dataSource);
  const eTag = response.headers.get("etag");
  warnETag(eTag);
  const emojiData = await response.json();
  assertEmojiData(emojiData);
  return [eTag, emojiData];
}
function arrayBufferToBinaryString(buffer) {
  var binary = "";
  var bytes = new Uint8Array(buffer);
  var length = bytes.byteLength;
  var i2 = -1;
  while (++i2 < length) {
    binary += String.fromCharCode(bytes[i2]);
  }
  return binary;
}
function binaryStringToArrayBuffer(binary) {
  var length = binary.length;
  var buf = new ArrayBuffer(length);
  var arr = new Uint8Array(buf);
  var i2 = -1;
  while (++i2 < length) {
    arr[i2] = binary.charCodeAt(i2);
  }
  return buf;
}
async function jsonChecksum(object) {
  const inString = JSON.stringify(object);
  const inBuffer = binaryStringToArrayBuffer(inString);
  const outBuffer = await crypto.subtle.digest("SHA-1", inBuffer);
  const outBinString = arrayBufferToBinaryString(outBuffer);
  const res = btoa(outBinString);
  return res;
}
async function checkForUpdates(db, dataSource) {
  let emojiData;
  let eTag = await getETag(dataSource);
  if (!eTag) {
    const eTagAndData = await getETagAndData(dataSource);
    eTag = eTagAndData[0];
    emojiData = eTagAndData[1];
    if (!eTag) {
      eTag = await jsonChecksum(emojiData);
    }
  }
  if (await hasData(db, dataSource, eTag))
    ;
  else {
    if (!emojiData) {
      const eTagAndData = await getETagAndData(dataSource);
      emojiData = eTagAndData[1];
    }
    await loadData(db, emojiData, dataSource, eTag);
  }
}
async function loadDataForFirstTime(db, dataSource) {
  let [eTag, emojiData] = await getETagAndData(dataSource);
  if (!eTag) {
    eTag = await jsonChecksum(emojiData);
  }
  await loadData(db, emojiData, dataSource, eTag);
}
class Database {
  constructor({ dataSource = DEFAULT_DATA_SOURCE$1, locale: locale2 = DEFAULT_LOCALE$1, customEmoji = [] } = {}) {
    this.dataSource = dataSource;
    this.locale = locale2;
    this._dbName = `emoji-picker-element-${this.locale}`;
    this._db = void 0;
    this._lazyUpdate = void 0;
    this._custom = customEmojiIndex(customEmoji);
    this._clear = this._clear.bind(this);
    this._ready = this._init();
  }
  async _init() {
    const db = this._db = await openDatabase(this._dbName);
    addOnCloseListener(this._dbName, this._clear);
    const dataSource = this.dataSource;
    const empty = await isEmpty(db);
    if (empty) {
      await loadDataForFirstTime(db, dataSource);
    } else {
      this._lazyUpdate = checkForUpdates(db, dataSource);
    }
  }
  async ready() {
    const checkReady = async () => {
      if (!this._ready) {
        this._ready = this._init();
      }
      return this._ready;
    };
    await checkReady();
    if (!this._db) {
      await checkReady();
    }
  }
  async getEmojiByGroup(group) {
    assertNumber(group);
    await this.ready();
    return uniqEmoji(await getEmojiByGroup(this._db, group)).map(cleanEmoji);
  }
  async getEmojiBySearchQuery(query) {
    assertNonEmptyString(query);
    await this.ready();
    const customs = this._custom.search(query);
    const natives = uniqEmoji(await getEmojiBySearchQuery(this._db, query)).map(cleanEmoji);
    return [
      ...customs,
      ...natives
    ];
  }
  async getEmojiByShortcode(shortcode) {
    assertNonEmptyString(shortcode);
    await this.ready();
    const custom = this._custom.byShortcode(shortcode);
    if (custom) {
      return custom;
    }
    return cleanEmoji(await getEmojiByShortcode(this._db, shortcode));
  }
  async getEmojiByUnicodeOrName(unicodeOrName) {
    assertNonEmptyString(unicodeOrName);
    await this.ready();
    const custom = this._custom.byName(unicodeOrName);
    if (custom) {
      return custom;
    }
    return cleanEmoji(await getEmojiByUnicode(this._db, unicodeOrName));
  }
  async getPreferredSkinTone() {
    await this.ready();
    return await get$3(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE) || 0;
  }
  async setPreferredSkinTone(skinTone) {
    assertNumber(skinTone);
    await this.ready();
    return set$2(this._db, STORE_KEYVALUE, KEY_PREFERRED_SKINTONE, skinTone);
  }
  async incrementFavoriteEmojiCount(unicodeOrName) {
    assertNonEmptyString(unicodeOrName);
    await this.ready();
    return incrementFavoriteEmojiCount(this._db, unicodeOrName);
  }
  async getTopFavoriteEmoji(limit) {
    assertNumber(limit);
    await this.ready();
    return (await getTopFavoriteEmoji(this._db, this._custom, limit)).map(cleanEmoji);
  }
  set customEmoji(customEmojis) {
    this._custom = customEmojiIndex(customEmojis);
  }
  get customEmoji() {
    return this._custom.all;
  }
  async _shutdown() {
    await this.ready();
    try {
      await this._lazyUpdate;
    } catch (err) {
    }
  }
  _clear() {
    this._db = this._ready = this._lazyUpdate = void 0;
  }
  async close() {
    await this._shutdown();
    await closeDatabase(this._dbName);
  }
  async delete() {
    await this._shutdown();
    await deleteDatabase(this._dbName);
  }
}
function noop$1() {
}
function run(fn3) {
  return fn3();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function element(name) {
  return document.createElement(name);
}
function text(data2) {
  return document.createTextNode(data2);
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_data(text2, data2) {
  data2 = "" + data2;
  if (text2.wholeText !== data2)
    text2.data = data2;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn3) {
  render_callbacks.push(fn3);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
const outroing = /* @__PURE__ */ new Set();
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
const globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function destroy_block(block, lookup) {
  block.d(1);
  lookup.delete(block.key);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy2, create_each_block2, next, get_context) {
  let o2 = old_blocks.length;
  let n2 = list.length;
  let i2 = o2;
  const old_indexes = {};
  while (i2--)
    old_indexes[old_blocks[i2].key] = i2;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  i2 = n2;
  while (i2--) {
    const child_ctx = get_context(ctx, list, i2);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block2(key, child_ctx);
      block.c();
    } else if (dynamic) {
      block.p(child_ctx, dirty);
    }
    new_lookup.set(key, new_blocks[i2] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i2 - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n2--;
  }
  while (o2 && n2) {
    const new_block = new_blocks[n2 - 1];
    const old_block = old_blocks[o2 - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o2--;
      n2--;
    } else if (!new_lookup.has(old_key)) {
      destroy2(old_block, lookup);
      o2--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o2--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o2--;
    }
  }
  while (o2--) {
    const old_block = old_blocks[o2];
    if (!new_lookup.has(old_block.key))
      destroy2(old_block, lookup);
  }
  while (n2)
    insert2(new_blocks[n2 - 1]);
  return new_blocks;
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props2, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props: props2,
    update: noop$1,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(parent_component ? parent_component.$$.context : []),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    {
      $$.fragment && $$.fragment.c();
    }
    mount_component(component, options.target, void 0, void 0);
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop$1;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index2 = callbacks.indexOf(callback);
      if (index2 !== -1)
        callbacks.splice(index2, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
}
const allGroups = [
  [-1, "\u2728", "custom"],
  [0, "\u{1F600}", "smileys-emotion"],
  [1, "\u{1F44B}", "people-body"],
  [3, "\u{1F431}", "animals-nature"],
  [4, "\u{1F34E}", "food-drink"],
  [5, "\u{1F3E0}\uFE0F", "travel-places"],
  [6, "\u26BD", "activities"],
  [7, "\u{1F4DD}", "objects"],
  [8, "\u26D4\uFE0F", "symbols"],
  [9, "\u{1F3C1}", "flags"]
].map(([id, emoji, name]) => ({ id, emoji, name }));
const groups = allGroups.slice(1);
const customGroup = allGroups[0];
const MIN_SEARCH_TEXT_LENGTH = 2;
const NUM_SKIN_TONES = 6;
const rIC = typeof requestIdleCallback === "function" ? requestIdleCallback : setTimeout;
function hasZwj(emoji) {
  return emoji.unicode.includes("\u200D");
}
const versionsAndTestEmoji = {
  "\u{1FAE0}": 14,
  "\u{1F972}": 13.1,
  "\u{1F97B}": 12.1,
  "\u{1F970}": 11,
  "\u{1F929}": 5,
  "\u{1F471}\u200D\u2640\uFE0F": 4,
  "\u{1F923}": 3,
  "\u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F": 2,
  "\u{1F600}": 1,
  "\u{1F610}\uFE0F": 0.7,
  "\u{1F603}": 0.6
};
const TIMEOUT_BEFORE_LOADING_MESSAGE = 1e3;
const DEFAULT_SKIN_TONE_EMOJI = "\u{1F590}\uFE0F";
const DEFAULT_NUM_COLUMNS = 8;
const MOST_COMMONLY_USED_EMOJI = [
  "\u{1F60A}",
  "\u{1F612}",
  "\u2665\uFE0F",
  "\u{1F44D}\uFE0F",
  "\u{1F60D}",
  "\u{1F602}",
  "\u{1F62D}",
  "\u263A\uFE0F",
  "\u{1F614}",
  "\u{1F629}",
  "\u{1F60F}",
  "\u{1F495}",
  "\u{1F64C}",
  "\u{1F618}"
];
const FONT_FAMILY = '"Twemoji Mozilla","Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji","EmojiOne Color","Android Emoji",sans-serif';
const DEFAULT_CATEGORY_SORTING = (a2, b2) => a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
const getTextFeature = (text2, color) => {
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = 1;
  const ctx = canvas.getContext("2d");
  ctx.textBaseline = "top";
  ctx.font = `100px ${FONT_FAMILY}`;
  ctx.fillStyle = color;
  ctx.scale(0.01, 0.01);
  ctx.fillText(text2, 0, 0);
  return ctx.getImageData(0, 0, 1, 1).data;
};
const compareFeatures = (feature1, feature2) => {
  const feature1Str = [...feature1].join(",");
  const feature2Str = [...feature2].join(",");
  return feature1Str === feature2Str && !feature1Str.startsWith("0,0,0,");
};
function testColorEmojiSupported(text2) {
  const feature1 = getTextFeature(text2, "#000");
  const feature2 = getTextFeature(text2, "#fff");
  return feature1 && feature2 && compareFeatures(feature1, feature2);
}
function determineEmojiSupportLevel() {
  const entries = Object.entries(versionsAndTestEmoji);
  try {
    for (const [emoji, version2] of entries) {
      if (testColorEmojiSupported(emoji)) {
        return version2;
      }
    }
  } catch (e2) {
  } finally {
  }
  return entries[0][1];
}
const emojiSupportLevelPromise = new Promise((resolve) => rIC(() => resolve(determineEmojiSupportLevel())));
const supportedZwjEmojis = /* @__PURE__ */ new Map();
const VARIATION_SELECTOR = "\uFE0F";
const SKINTONE_MODIFIER = "\uD83C";
const ZWJ = "\u200D";
const LIGHT_SKIN_TONE = 127995;
const LIGHT_SKIN_TONE_MODIFIER = 57339;
function applySkinTone(str, skinTone) {
  if (skinTone === 0) {
    return str;
  }
  const zwjIndex = str.indexOf(ZWJ);
  if (zwjIndex !== -1) {
    return str.substring(0, zwjIndex) + String.fromCodePoint(LIGHT_SKIN_TONE + skinTone - 1) + str.substring(zwjIndex);
  }
  if (str.endsWith(VARIATION_SELECTOR)) {
    str = str.substring(0, str.length - 1);
  }
  return str + SKINTONE_MODIFIER + String.fromCodePoint(LIGHT_SKIN_TONE_MODIFIER + skinTone - 1);
}
function halt(event) {
  event.preventDefault();
  event.stopPropagation();
}
function incrementOrDecrement(decrement, val, arr) {
  val += decrement ? -1 : 1;
  if (val < 0) {
    val = arr.length - 1;
  } else if (val >= arr.length) {
    val = 0;
  }
  return val;
}
function uniqBy(arr, func) {
  const set2 = /* @__PURE__ */ new Set();
  const res = [];
  for (const item of arr) {
    const key = func(item);
    if (!set2.has(key)) {
      set2.add(key);
      res.push(item);
    }
  }
  return res;
}
function summarizeEmojisForUI(emojis, emojiSupportLevel) {
  const toSimpleSkinsMap = (skins) => {
    const res = {};
    for (const skin of skins) {
      if (typeof skin.tone === "number" && skin.version <= emojiSupportLevel) {
        res[skin.tone] = skin.unicode;
      }
    }
    return res;
  };
  return emojis.map(({ unicode, skins, shortcodes, url, name, category }) => ({
    unicode,
    name,
    shortcodes,
    url,
    category,
    id: unicode || name,
    skins: skins && toSimpleSkinsMap(skins),
    title: (shortcodes || []).join(", ")
  }));
}
const rAF = requestAnimationFrame;
let resizeObserverSupported = typeof ResizeObserver === "function";
function calculateWidth(node, onUpdate) {
  let resizeObserver;
  if (resizeObserverSupported) {
    resizeObserver = new ResizeObserver((entries) => onUpdate(entries[0].contentRect.width));
    resizeObserver.observe(node);
  } else {
    rAF(() => onUpdate(node.getBoundingClientRect().width));
  }
  return {
    destroy() {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    }
  };
}
function calculateTextWidth(node) {
  {
    const range = document.createRange();
    range.selectNode(node.firstChild);
    return range.getBoundingClientRect().width;
  }
}
let baselineEmojiWidth;
function checkZwjSupport(zwjEmojisToCheck, baselineEmoji, emojiToDomNode) {
  for (const emoji of zwjEmojisToCheck) {
    const domNode = emojiToDomNode(emoji);
    const emojiWidth = calculateTextWidth(domNode);
    if (typeof baselineEmojiWidth === "undefined") {
      baselineEmojiWidth = calculateTextWidth(baselineEmoji);
    }
    const supported = emojiWidth / 1.8 < baselineEmojiWidth;
    supportedZwjEmojis.set(emoji.unicode, supported);
  }
}
function uniq(arr) {
  return uniqBy(arr, (_2) => _2);
}
const { Map: Map_1 } = globals;
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[63] = list[i2];
  child_ctx[65] = i2;
  return child_ctx;
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[66] = list[i2];
  child_ctx[65] = i2;
  return child_ctx;
}
function get_each_context_2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[63] = list[i2];
  child_ctx[65] = i2;
  return child_ctx;
}
function get_each_context_3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[69] = list[i2];
  return child_ctx;
}
function get_each_context_4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[72] = list[i2];
  child_ctx[65] = i2;
  return child_ctx;
}
function create_each_block_4(key_1, ctx) {
  let div;
  let t_value = ctx[72] + "";
  let t2;
  let div_id_value;
  let div_class_value;
  let div_aria_selected_value;
  let div_title_value;
  let div_aria_label_value;
  return {
    key: key_1,
    first: null,
    c() {
      div = element("div");
      t2 = text(t_value);
      attr(div, "id", div_id_value = "skintone-" + ctx[65]);
      attr(div, "class", div_class_value = "emoji hide-focus " + (ctx[65] === ctx[20] ? "active" : ""));
      attr(div, "aria-selected", div_aria_selected_value = ctx[65] === ctx[20]);
      attr(div, "role", "option");
      attr(div, "title", div_title_value = ctx[0].skinTones[ctx[65]]);
      attr(div, "tabindex", "-1");
      attr(div, "aria-label", div_aria_label_value = ctx[0].skinTones[ctx[65]]);
      this.first = div;
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t2);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 512 && t_value !== (t_value = ctx[72] + ""))
        set_data(t2, t_value);
      if (dirty[0] & 512 && div_id_value !== (div_id_value = "skintone-" + ctx[65])) {
        attr(div, "id", div_id_value);
      }
      if (dirty[0] & 1049088 && div_class_value !== (div_class_value = "emoji hide-focus " + (ctx[65] === ctx[20] ? "active" : ""))) {
        attr(div, "class", div_class_value);
      }
      if (dirty[0] & 1049088 && div_aria_selected_value !== (div_aria_selected_value = ctx[65] === ctx[20])) {
        attr(div, "aria-selected", div_aria_selected_value);
      }
      if (dirty[0] & 513 && div_title_value !== (div_title_value = ctx[0].skinTones[ctx[65]])) {
        attr(div, "title", div_title_value);
      }
      if (dirty[0] & 513 && div_aria_label_value !== (div_aria_label_value = ctx[0].skinTones[ctx[65]])) {
        attr(div, "aria-label", div_aria_label_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_each_block_3(key_1, ctx) {
  let button;
  let div;
  let t_value = ctx[69].emoji + "";
  let t2;
  let button_aria_controls_value;
  let button_aria_label_value;
  let button_aria_selected_value;
  let button_title_value;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[49](ctx[69]);
  }
  return {
    key: key_1,
    first: null,
    c() {
      button = element("button");
      div = element("div");
      t2 = text(t_value);
      attr(div, "class", "nav-emoji emoji");
      attr(button, "role", "tab");
      attr(button, "class", "nav-button");
      attr(button, "aria-controls", button_aria_controls_value = "tab-" + ctx[69].id);
      attr(button, "aria-label", button_aria_label_value = ctx[0].categories[ctx[69].name]);
      attr(button, "aria-selected", button_aria_selected_value = !ctx[4] && ctx[13].id === ctx[69].id);
      attr(button, "title", button_title_value = ctx[0].categories[ctx[69].name]);
      this.first = button;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, div);
      append(div, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 4096 && t_value !== (t_value = ctx[69].emoji + ""))
        set_data(t2, t_value);
      if (dirty[0] & 4096 && button_aria_controls_value !== (button_aria_controls_value = "tab-" + ctx[69].id)) {
        attr(button, "aria-controls", button_aria_controls_value);
      }
      if (dirty[0] & 4097 && button_aria_label_value !== (button_aria_label_value = ctx[0].categories[ctx[69].name])) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (dirty[0] & 12304 && button_aria_selected_value !== (button_aria_selected_value = !ctx[4] && ctx[13].id === ctx[69].id)) {
        attr(button, "aria-selected", button_aria_selected_value);
      }
      if (dirty[0] & 4097 && button_title_value !== (button_title_value = ctx[0].categories[ctx[69].name])) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_1(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      attr(img, "class", "custom-emoji");
      if (!src_url_equal(img.src, img_src_value = ctx[63].url))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "loading", "lazy");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 32768 && !src_url_equal(img.src, img_src_value = ctx2[63].url)) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_if_block_1(ctx) {
  let t_value = ctx[27](ctx[63], ctx[8]) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 33024 && t_value !== (t_value = ctx2[27](ctx2[63], ctx2[8]) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t2);
    }
  };
}
function create_each_block_2(key_1, ctx) {
  let button;
  let button_role_value;
  let button_aria_selected_value;
  let button_aria_label_value;
  let button_title_value;
  let button_class_value;
  let button_id_value;
  function select_block_type(ctx2, dirty) {
    if (ctx2[63].unicode)
      return create_if_block_1;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      button = element("button");
      if_block.c();
      attr(button, "role", button_role_value = ctx[4] ? "option" : "menuitem");
      attr(button, "aria-selected", button_aria_selected_value = ctx[4] ? ctx[65] == ctx[5] : "");
      attr(button, "aria-label", button_aria_label_value = ctx[28](ctx[63], ctx[8]));
      attr(button, "title", button_title_value = ctx[63].title);
      attr(button, "class", button_class_value = "emoji " + (ctx[4] && ctx[65] === ctx[5] ? "active" : ""));
      attr(button, "id", button_id_value = "emo-" + ctx[63].id);
      this.first = button;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty[0] & 16 && button_role_value !== (button_role_value = ctx[4] ? "option" : "menuitem")) {
        attr(button, "role", button_role_value);
      }
      if (dirty[0] & 32816 && button_aria_selected_value !== (button_aria_selected_value = ctx[4] ? ctx[65] == ctx[5] : "")) {
        attr(button, "aria-selected", button_aria_selected_value);
      }
      if (dirty[0] & 33024 && button_aria_label_value !== (button_aria_label_value = ctx[28](ctx[63], ctx[8]))) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (dirty[0] & 32768 && button_title_value !== (button_title_value = ctx[63].title)) {
        attr(button, "title", button_title_value);
      }
      if (dirty[0] & 32816 && button_class_value !== (button_class_value = "emoji " + (ctx[4] && ctx[65] === ctx[5] ? "active" : ""))) {
        attr(button, "class", button_class_value);
      }
      if (dirty[0] & 32768 && button_id_value !== (button_id_value = "emo-" + ctx[63].id)) {
        attr(button, "id", button_id_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if_block.d();
    }
  };
}
function create_each_block_1(key_1, ctx) {
  let div0;
  let t_value = (ctx[4] ? ctx[0].searchResultsLabel : ctx[66].category ? ctx[66].category : ctx[15].length > 1 ? ctx[0].categories.custom : ctx[0].categories[ctx[13].name]) + "";
  let t2;
  let div0_id_value;
  let div0_class_value;
  let div1;
  let each_blocks = [];
  let each_1_lookup = new Map_1();
  let div1_role_value;
  let div1_aria_labelledby_value;
  let div1_id_value;
  let each_value_2 = ctx[66].emojis;
  const get_key = (ctx2) => ctx2[63].id;
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    let child_ctx = get_each_context_2(ctx, each_value_2, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_2(key, child_ctx));
  }
  return {
    key: key_1,
    first: null,
    c() {
      div0 = element("div");
      t2 = text(t_value);
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div0, "id", div0_id_value = "menu-label-" + ctx[65]);
      attr(div0, "class", div0_class_value = "category " + (ctx[15].length === 1 && ctx[15][0].category === "" ? "gone" : ""));
      attr(div0, "aria-hidden", "true");
      attr(div1, "class", "emoji-menu");
      attr(div1, "role", div1_role_value = ctx[4] ? "listbox" : "menu");
      attr(div1, "aria-labelledby", div1_aria_labelledby_value = "menu-label-" + ctx[65]);
      attr(div1, "id", div1_id_value = ctx[4] ? "search-results" : "");
      this.first = div0;
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append(div0, t2);
      insert(target, div1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div1, null);
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 40977 && t_value !== (t_value = (ctx[4] ? ctx[0].searchResultsLabel : ctx[66].category ? ctx[66].category : ctx[15].length > 1 ? ctx[0].categories.custom : ctx[0].categories[ctx[13].name]) + ""))
        set_data(t2, t_value);
      if (dirty[0] & 32768 && div0_id_value !== (div0_id_value = "menu-label-" + ctx[65])) {
        attr(div0, "id", div0_id_value);
      }
      if (dirty[0] & 32768 && div0_class_value !== (div0_class_value = "category " + (ctx[15].length === 1 && ctx[15][0].category === "" ? "gone" : ""))) {
        attr(div0, "class", div0_class_value);
      }
      if (dirty[0] & 402686256) {
        each_value_2 = ctx[66].emojis;
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, div1, destroy_block, create_each_block_2, null, get_each_context_2);
      }
      if (dirty[0] & 16 && div1_role_value !== (div1_role_value = ctx[4] ? "listbox" : "menu")) {
        attr(div1, "role", div1_role_value);
      }
      if (dirty[0] & 32768 && div1_aria_labelledby_value !== (div1_aria_labelledby_value = "menu-label-" + ctx[65])) {
        attr(div1, "aria-labelledby", div1_aria_labelledby_value);
      }
      if (dirty[0] & 16 && div1_id_value !== (div1_id_value = ctx[4] ? "search-results" : "")) {
        attr(div1, "id", div1_id_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(div1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_else_block(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      attr(img, "class", "custom-emoji");
      if (!src_url_equal(img.src, img_src_value = ctx[63].url))
        attr(img, "src", img_src_value);
      attr(img, "alt", "");
      attr(img, "loading", "lazy");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1024 && !src_url_equal(img.src, img_src_value = ctx2[63].url)) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(img);
    }
  };
}
function create_if_block(ctx) {
  let t_value = ctx[27](ctx[63], ctx[8]) + "";
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    m(target, anchor) {
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1280 && t_value !== (t_value = ctx2[27](ctx2[63], ctx2[8]) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(t2);
    }
  };
}
function create_each_block(key_1, ctx) {
  let button;
  let button_aria_label_value;
  let button_title_value;
  let button_id_value;
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[63].unicode)
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      button = element("button");
      if_block.c();
      attr(button, "role", "menuitem");
      attr(button, "aria-label", button_aria_label_value = ctx[28](ctx[63], ctx[8]));
      attr(button, "title", button_title_value = ctx[63].title);
      attr(button, "class", "emoji");
      attr(button, "id", button_id_value = "fav-" + ctx[63].id);
      this.first = button;
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty[0] & 1280 && button_aria_label_value !== (button_aria_label_value = ctx[28](ctx[63], ctx[8]))) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (dirty[0] & 1024 && button_title_value !== (button_title_value = ctx[63].title)) {
        attr(button, "title", button_title_value);
      }
      if (dirty[0] & 1024 && button_id_value !== (button_id_value = "fav-" + ctx[63].id)) {
        attr(button, "id", button_id_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if_block.d();
    }
  };
}
function create_fragment(ctx) {
  let section;
  let div0;
  let div4;
  let div1;
  let input;
  let input_placeholder_value;
  let input_aria_expanded_value;
  let input_aria_activedescendant_value;
  let label;
  let t0_value = ctx[0].searchLabel + "";
  let t0;
  let span0;
  let t1_value = ctx[0].searchDescription + "";
  let t1;
  let div2;
  let button0;
  let t2;
  let button0_class_value;
  let div2_class_value;
  let span1;
  let t3_value = ctx[0].skinToneDescription + "";
  let t3;
  let div3;
  let each_blocks_3 = [];
  let each0_lookup = new Map_1();
  let div3_class_value;
  let div3_aria_label_value;
  let div3_aria_activedescendant_value;
  let div3_aria_hidden_value;
  let div5;
  let each_blocks_2 = [];
  let each1_lookup = new Map_1();
  let div5_aria_label_value;
  let div7;
  let div6;
  let div8;
  let t4;
  let div8_class_value;
  let div10;
  let div9;
  let each_blocks_1 = [];
  let each2_lookup = new Map_1();
  let div10_class_value;
  let div10_role_value;
  let div10_aria_label_value;
  let div10_id_value;
  let div11;
  let each_blocks = [];
  let each3_lookup = new Map_1();
  let div11_class_value;
  let div11_aria_label_value;
  let button1;
  let section_aria_label_value;
  let mounted;
  let dispose;
  let each_value_4 = ctx[9];
  const get_key = (ctx2) => ctx2[72];
  for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
    let child_ctx = get_each_context_4(ctx, each_value_4, i2);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_3[i2] = create_each_block_4(key, child_ctx));
  }
  let each_value_3 = ctx[12];
  const get_key_1 = (ctx2) => ctx2[69].id;
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    let child_ctx = get_each_context_3(ctx, each_value_3, i2);
    let key = get_key_1(child_ctx);
    each1_lookup.set(key, each_blocks_2[i2] = create_each_block_3(key, child_ctx));
  }
  let each_value_1 = ctx[15];
  const get_key_2 = (ctx2) => ctx2[66].category;
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i2);
    let key = get_key_2(child_ctx);
    each2_lookup.set(key, each_blocks_1[i2] = create_each_block_1(key, child_ctx));
  }
  let each_value = ctx[10];
  const get_key_3 = (ctx2) => ctx2[63].id;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context(ctx, each_value, i2);
    let key = get_key_3(child_ctx);
    each3_lookup.set(key, each_blocks[i2] = create_each_block(key, child_ctx));
  }
  return {
    c() {
      section = element("section");
      div0 = element("div");
      div4 = element("div");
      div1 = element("div");
      input = element("input");
      label = element("label");
      t0 = text(t0_value);
      span0 = element("span");
      t1 = text(t1_value);
      div2 = element("div");
      button0 = element("button");
      t2 = text(ctx[21]);
      span1 = element("span");
      t3 = text(t3_value);
      div3 = element("div");
      for (let i2 = 0; i2 < each_blocks_3.length; i2 += 1) {
        each_blocks_3[i2].c();
      }
      div5 = element("div");
      for (let i2 = 0; i2 < each_blocks_2.length; i2 += 1) {
        each_blocks_2[i2].c();
      }
      div7 = element("div");
      div6 = element("div");
      div8 = element("div");
      t4 = text(ctx[18]);
      div10 = element("div");
      div9 = element("div");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      div11 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      button1 = element("button");
      button1.textContent = "\u{1F600}";
      attr(div0, "class", "pad-top");
      attr(input, "id", "search");
      attr(input, "class", "search");
      attr(input, "type", "search");
      attr(input, "role", "combobox");
      attr(input, "enterkeyhint", "search");
      attr(input, "placeholder", input_placeholder_value = ctx[0].searchLabel);
      attr(input, "autocapitalize", "none");
      attr(input, "autocomplete", "off");
      attr(input, "spellcheck", "true");
      attr(input, "aria-expanded", input_aria_expanded_value = !!(ctx[4] && ctx[1].length));
      attr(input, "aria-controls", "search-results");
      attr(input, "aria-describedby", "search-description");
      attr(input, "aria-autocomplete", "list");
      attr(input, "aria-activedescendant", input_aria_activedescendant_value = ctx[26] ? `emo-${ctx[26]}` : "");
      attr(label, "class", "sr-only");
      attr(label, "for", "search");
      attr(span0, "id", "search-description");
      attr(span0, "class", "sr-only");
      attr(div1, "class", "search-wrapper");
      attr(button0, "id", "skintone-button");
      attr(button0, "class", button0_class_value = "emoji " + (ctx[6] ? "hide-focus" : ""));
      attr(button0, "aria-label", ctx[23]);
      attr(button0, "title", ctx[23]);
      attr(button0, "aria-describedby", "skintone-description");
      attr(button0, "aria-haspopup", "listbox");
      attr(button0, "aria-expanded", ctx[6]);
      attr(button0, "aria-controls", "skintone-list");
      attr(div2, "class", div2_class_value = "skintone-button-wrapper " + (ctx[19] ? "expanded" : ""));
      attr(span1, "id", "skintone-description");
      attr(span1, "class", "sr-only");
      attr(div3, "id", "skintone-list");
      attr(div3, "class", div3_class_value = "skintone-list " + (ctx[6] ? "" : "hidden no-animate"));
      set_style(div3, "transform", "translateY(" + (ctx[6] ? 0 : "calc(-1 * var(--num-skintones) * var(--total-emoji-size))") + ")");
      attr(div3, "role", "listbox");
      attr(div3, "aria-label", div3_aria_label_value = ctx[0].skinTonesLabel);
      attr(div3, "aria-activedescendant", div3_aria_activedescendant_value = "skintone-" + ctx[20]);
      attr(div3, "aria-hidden", div3_aria_hidden_value = !ctx[6]);
      attr(div4, "class", "search-row");
      attr(div5, "class", "nav");
      attr(div5, "role", "tablist");
      set_style(div5, "grid-template-columns", "repeat(" + ctx[12].length + ", 1fr)");
      attr(div5, "aria-label", div5_aria_label_value = ctx[0].categoriesLabel);
      attr(div6, "class", "indicator");
      set_style(div6, "transform", "translateX(" + (ctx[24] ? -1 : 1) * ctx[11] * 100 + "%)");
      attr(div7, "class", "indicator-wrapper");
      attr(div8, "class", div8_class_value = "message " + (ctx[18] ? "" : "gone"));
      attr(div8, "role", "alert");
      attr(div8, "aria-live", "polite");
      attr(div10, "class", div10_class_value = "tabpanel " + (!ctx[14] || ctx[18] ? "gone" : ""));
      attr(div10, "role", div10_role_value = ctx[4] ? "region" : "tabpanel");
      attr(div10, "aria-label", div10_aria_label_value = ctx[4] ? ctx[0].searchResultsLabel : ctx[0].categories[ctx[13].name]);
      attr(div10, "id", div10_id_value = ctx[4] ? "" : `tab-${ctx[13].id}`);
      attr(div10, "tabindex", "0");
      attr(div11, "class", div11_class_value = "favorites emoji-menu " + (ctx[18] ? "gone" : ""));
      attr(div11, "role", "menu");
      attr(div11, "aria-label", div11_aria_label_value = ctx[0].favoritesLabel);
      set_style(div11, "padding-inline-end", ctx[25] + "px");
      attr(button1, "aria-hidden", "true");
      attr(button1, "tabindex", "-1");
      attr(button1, "class", "abs-pos hidden emoji");
      attr(section, "class", "picker");
      attr(section, "aria-label", section_aria_label_value = ctx[0].regionLabel);
      attr(section, "style", ctx[22]);
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div0);
      append(section, div4);
      append(div4, div1);
      append(div1, input);
      set_input_value(input, ctx[2]);
      append(div1, label);
      append(label, t0);
      append(div1, span0);
      append(span0, t1);
      append(div4, div2);
      append(div2, button0);
      append(button0, t2);
      append(div4, span1);
      append(span1, t3);
      append(div4, div3);
      for (let i2 = 0; i2 < each_blocks_3.length; i2 += 1) {
        each_blocks_3[i2].m(div3, null);
      }
      ctx[48](div3);
      append(section, div5);
      for (let i2 = 0; i2 < each_blocks_2.length; i2 += 1) {
        each_blocks_2[i2].m(div5, null);
      }
      append(section, div7);
      append(div7, div6);
      append(section, div8);
      append(div8, t4);
      append(section, div10);
      append(div10, div9);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].m(div9, null);
      }
      ctx[50](div10);
      append(section, div11);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(div11, null);
      }
      append(section, button1);
      ctx[51](button1);
      ctx[52](section);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[47]),
          listen(input, "keydown", ctx[30]),
          listen(button0, "click", ctx[35]),
          listen(div3, "focusout", ctx[38]),
          listen(div3, "click", ctx[34]),
          listen(div3, "keydown", ctx[36]),
          listen(div3, "keyup", ctx[37]),
          listen(div5, "keydown", ctx[32]),
          action_destroyer(ctx[29].call(null, div9)),
          listen(div10, "click", ctx[33]),
          listen(div11, "click", ctx[33])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 1 && input_placeholder_value !== (input_placeholder_value = ctx2[0].searchLabel)) {
        attr(input, "placeholder", input_placeholder_value);
      }
      if (dirty[0] & 18 && input_aria_expanded_value !== (input_aria_expanded_value = !!(ctx2[4] && ctx2[1].length))) {
        attr(input, "aria-expanded", input_aria_expanded_value);
      }
      if (dirty[0] & 67108864 && input_aria_activedescendant_value !== (input_aria_activedescendant_value = ctx2[26] ? `emo-${ctx2[26]}` : "")) {
        attr(input, "aria-activedescendant", input_aria_activedescendant_value);
      }
      if (dirty[0] & 4) {
        set_input_value(input, ctx2[2]);
      }
      if (dirty[0] & 1 && t0_value !== (t0_value = ctx2[0].searchLabel + ""))
        set_data(t0, t0_value);
      if (dirty[0] & 1 && t1_value !== (t1_value = ctx2[0].searchDescription + ""))
        set_data(t1, t1_value);
      if (dirty[0] & 2097152)
        set_data(t2, ctx2[21]);
      if (dirty[0] & 64 && button0_class_value !== (button0_class_value = "emoji " + (ctx2[6] ? "hide-focus" : ""))) {
        attr(button0, "class", button0_class_value);
      }
      if (dirty[0] & 8388608) {
        attr(button0, "aria-label", ctx2[23]);
      }
      if (dirty[0] & 8388608) {
        attr(button0, "title", ctx2[23]);
      }
      if (dirty[0] & 64) {
        attr(button0, "aria-expanded", ctx2[6]);
      }
      if (dirty[0] & 524288 && div2_class_value !== (div2_class_value = "skintone-button-wrapper " + (ctx2[19] ? "expanded" : ""))) {
        attr(div2, "class", div2_class_value);
      }
      if (dirty[0] & 1 && t3_value !== (t3_value = ctx2[0].skinToneDescription + ""))
        set_data(t3, t3_value);
      if (dirty[0] & 1049089) {
        each_value_4 = ctx2[9];
        each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key, 1, ctx2, each_value_4, each0_lookup, div3, destroy_block, create_each_block_4, null, get_each_context_4);
      }
      if (dirty[0] & 64 && div3_class_value !== (div3_class_value = "skintone-list " + (ctx2[6] ? "" : "hidden no-animate"))) {
        attr(div3, "class", div3_class_value);
      }
      if (dirty[0] & 64) {
        set_style(div3, "transform", "translateY(" + (ctx2[6] ? 0 : "calc(-1 * var(--num-skintones) * var(--total-emoji-size))") + ")");
      }
      if (dirty[0] & 1 && div3_aria_label_value !== (div3_aria_label_value = ctx2[0].skinTonesLabel)) {
        attr(div3, "aria-label", div3_aria_label_value);
      }
      if (dirty[0] & 1048576 && div3_aria_activedescendant_value !== (div3_aria_activedescendant_value = "skintone-" + ctx2[20])) {
        attr(div3, "aria-activedescendant", div3_aria_activedescendant_value);
      }
      if (dirty[0] & 64 && div3_aria_hidden_value !== (div3_aria_hidden_value = !ctx2[6])) {
        attr(div3, "aria-hidden", div3_aria_hidden_value);
      }
      if (dirty[0] & 12305 | dirty[1] & 1) {
        each_value_3 = ctx2[12];
        each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_1, 1, ctx2, each_value_3, each1_lookup, div5, destroy_block, create_each_block_3, null, get_each_context_3);
      }
      if (dirty[0] & 4096) {
        set_style(div5, "grid-template-columns", "repeat(" + ctx2[12].length + ", 1fr)");
      }
      if (dirty[0] & 1 && div5_aria_label_value !== (div5_aria_label_value = ctx2[0].categoriesLabel)) {
        attr(div5, "aria-label", div5_aria_label_value);
      }
      if (dirty[0] & 16779264) {
        set_style(div6, "transform", "translateX(" + (ctx2[24] ? -1 : 1) * ctx2[11] * 100 + "%)");
      }
      if (dirty[0] & 262144)
        set_data(t4, ctx2[18]);
      if (dirty[0] & 262144 && div8_class_value !== (div8_class_value = "message " + (ctx2[18] ? "" : "gone"))) {
        attr(div8, "class", div8_class_value);
      }
      if (dirty[0] & 402694449) {
        each_value_1 = ctx2[15];
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_2, 1, ctx2, each_value_1, each2_lookup, div9, destroy_block, create_each_block_1, null, get_each_context_1);
      }
      if (dirty[0] & 278528 && div10_class_value !== (div10_class_value = "tabpanel " + (!ctx2[14] || ctx2[18] ? "gone" : ""))) {
        attr(div10, "class", div10_class_value);
      }
      if (dirty[0] & 16 && div10_role_value !== (div10_role_value = ctx2[4] ? "region" : "tabpanel")) {
        attr(div10, "role", div10_role_value);
      }
      if (dirty[0] & 8209 && div10_aria_label_value !== (div10_aria_label_value = ctx2[4] ? ctx2[0].searchResultsLabel : ctx2[0].categories[ctx2[13].name])) {
        attr(div10, "aria-label", div10_aria_label_value);
      }
      if (dirty[0] & 8208 && div10_id_value !== (div10_id_value = ctx2[4] ? "" : `tab-${ctx2[13].id}`)) {
        attr(div10, "id", div10_id_value);
      }
      if (dirty[0] & 402654464) {
        each_value = ctx2[10];
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_3, 1, ctx2, each_value, each3_lookup, div11, destroy_block, create_each_block, null, get_each_context);
      }
      if (dirty[0] & 262144 && div11_class_value !== (div11_class_value = "favorites emoji-menu " + (ctx2[18] ? "gone" : ""))) {
        attr(div11, "class", div11_class_value);
      }
      if (dirty[0] & 1 && div11_aria_label_value !== (div11_aria_label_value = ctx2[0].favoritesLabel)) {
        attr(div11, "aria-label", div11_aria_label_value);
      }
      if (dirty[0] & 33554432) {
        set_style(div11, "padding-inline-end", ctx2[25] + "px");
      }
      if (dirty[0] & 1 && section_aria_label_value !== (section_aria_label_value = ctx2[0].regionLabel)) {
        attr(section, "aria-label", section_aria_label_value);
      }
      if (dirty[0] & 4194304) {
        attr(section, "style", ctx2[22]);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching)
        detach(section);
      for (let i2 = 0; i2 < each_blocks_3.length; i2 += 1) {
        each_blocks_3[i2].d();
      }
      ctx[48](null);
      for (let i2 = 0; i2 < each_blocks_2.length; i2 += 1) {
        each_blocks_2[i2].d();
      }
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].d();
      }
      ctx[50](null);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      ctx[51](null);
      ctx[52](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { skinToneEmoji } = $$props;
  let { i18n } = $$props;
  let { database } = $$props;
  let { customEmoji } = $$props;
  let { customCategorySorting } = $$props;
  let initialLoad = true;
  let currentEmojis = [];
  let currentEmojisWithCategories = [];
  let rawSearchText = "";
  let searchText = "";
  let rootElement;
  let baselineEmoji;
  let tabpanelElement;
  let searchMode = false;
  let activeSearchItem = -1;
  let message;
  let skinTonePickerExpanded = false;
  let skinTonePickerExpandedAfterAnimation = false;
  let skinToneDropdown;
  let currentSkinTone = 0;
  let activeSkinTone = 0;
  let skinToneButtonText;
  let pickerStyle;
  let skinToneButtonLabel = "";
  let skinTones = [];
  let currentFavorites = [];
  let defaultFavoriteEmojis;
  let numColumns = DEFAULT_NUM_COLUMNS;
  let isRtl = false;
  let scrollbarWidth = 0;
  let currentGroupIndex = 0;
  let groups$1 = groups;
  let currentGroup;
  let databaseLoaded = false;
  let activeSearchItemId;
  const focus = (id) => {
    rootElement.getRootNode().getElementById(id).focus();
  };
  const fireEvent = (name, detail) => {
    rootElement.dispatchEvent(new CustomEvent(name, { detail, bubbles: true, composed: true }));
  };
  const unicodeWithSkin = (emoji, currentSkinTone2) => currentSkinTone2 && emoji.skins && emoji.skins[currentSkinTone2] || emoji.unicode;
  const labelWithSkin = (emoji, currentSkinTone2) => uniq([
    emoji.name || unicodeWithSkin(emoji, currentSkinTone2),
    ...emoji.shortcodes || []
  ]).join(", ");
  const isSkinToneOption = (element2) => /^skintone-/.test(element2.id);
  emojiSupportLevelPromise.then((level) => {
    if (!level) {
      $$invalidate(18, message = i18n.emojiUnsupportedMessage);
    }
  });
  function calculateEmojiGridStyle(node) {
    return calculateWidth(node, (width) => {
      {
        const style2 = getComputedStyle(rootElement);
        const newNumColumns = parseInt(style2.getPropertyValue("--num-columns"), 10);
        const newIsRtl = style2.getPropertyValue("direction") === "rtl";
        const parentWidth = node.parentElement.getBoundingClientRect().width;
        const newScrollbarWidth = parentWidth - width;
        $$invalidate(46, numColumns = newNumColumns);
        $$invalidate(25, scrollbarWidth = newScrollbarWidth);
        $$invalidate(24, isRtl = newIsRtl);
      }
    });
  }
  function checkZwjSupportAndUpdate(zwjEmojisToCheck) {
    const rootNode = rootElement.getRootNode();
    const emojiToDomNode = (emoji) => rootNode.getElementById(`emo-${emoji.id}`);
    checkZwjSupport(zwjEmojisToCheck, baselineEmoji, emojiToDomNode);
    $$invalidate(1, currentEmojis = currentEmojis);
  }
  function isZwjSupported(emoji) {
    return !emoji.unicode || !hasZwj(emoji) || supportedZwjEmojis.get(emoji.unicode);
  }
  async function filterEmojisByVersion(emojis) {
    const emojiSupportLevel = await emojiSupportLevelPromise;
    return emojis.filter(({ version: version2 }) => !version2 || version2 <= emojiSupportLevel);
  }
  async function summarizeEmojis(emojis) {
    return summarizeEmojisForUI(emojis, await emojiSupportLevelPromise);
  }
  async function getEmojisByGroup(group) {
    if (typeof group === "undefined") {
      return [];
    }
    const emoji = group === -1 ? customEmoji : await database.getEmojiByGroup(group);
    return summarizeEmojis(await filterEmojisByVersion(emoji));
  }
  async function getEmojisBySearchQuery(query) {
    return summarizeEmojis(await filterEmojisByVersion(await database.getEmojiBySearchQuery(query)));
  }
  function onSearchKeydown(event) {
    if (!searchMode || !currentEmojis.length) {
      return;
    }
    const goToNextOrPrevious = (previous) => {
      halt(event);
      $$invalidate(5, activeSearchItem = incrementOrDecrement(previous, activeSearchItem, currentEmojis));
    };
    switch (event.key) {
      case "ArrowDown":
        return goToNextOrPrevious(false);
      case "ArrowUp":
        return goToNextOrPrevious(true);
      case "Enter":
        if (activeSearchItem !== -1) {
          halt(event);
          return clickEmoji(currentEmojis[activeSearchItem].id);
        } else if (currentEmojis.length) {
          $$invalidate(5, activeSearchItem = 0);
        }
    }
  }
  function onNavClick(group) {
    $$invalidate(2, rawSearchText = "");
    $$invalidate(44, searchText = "");
    $$invalidate(5, activeSearchItem = -1);
    $$invalidate(11, currentGroupIndex = groups$1.findIndex((_2) => _2.id === group.id));
  }
  function onNavKeydown(event) {
    const { target, key } = event;
    const doFocus = (el) => {
      if (el) {
        halt(event);
        el.focus();
      }
    };
    switch (key) {
      case "ArrowLeft":
        return doFocus(target.previousSibling);
      case "ArrowRight":
        return doFocus(target.nextSibling);
      case "Home":
        return doFocus(target.parentElement.firstChild);
      case "End":
        return doFocus(target.parentElement.lastChild);
    }
  }
  async function clickEmoji(unicodeOrName) {
    const emoji = await database.getEmojiByUnicodeOrName(unicodeOrName);
    const emojiSummary = [...currentEmojis, ...currentFavorites].find((_2) => _2.id === unicodeOrName);
    const skinTonedUnicode = emojiSummary.unicode && unicodeWithSkin(emojiSummary, currentSkinTone);
    await database.incrementFavoriteEmojiCount(unicodeOrName);
    fireEvent("emoji-click", {
      emoji,
      skinTone: currentSkinTone,
      ...skinTonedUnicode && { unicode: skinTonedUnicode },
      ...emojiSummary.name && { name: emojiSummary.name }
    });
  }
  async function onEmojiClick(event) {
    const { target } = event;
    if (!target.classList.contains("emoji")) {
      return;
    }
    halt(event);
    const id = target.id.substring(4);
    clickEmoji(id);
  }
  async function onSkinToneOptionsClick(event) {
    const { target } = event;
    if (!isSkinToneOption(target)) {
      return;
    }
    halt(event);
    const skinTone = parseInt(target.id.slice(9), 10);
    $$invalidate(8, currentSkinTone = skinTone);
    $$invalidate(6, skinTonePickerExpanded = false);
    focus("skintone-button");
    fireEvent("skin-tone-change", { skinTone });
    database.setPreferredSkinTone(skinTone);
  }
  async function onClickSkinToneButton(event) {
    $$invalidate(6, skinTonePickerExpanded = !skinTonePickerExpanded);
    $$invalidate(20, activeSkinTone = currentSkinTone);
    if (skinTonePickerExpanded) {
      halt(event);
      rAF(() => focus(`skintone-${activeSkinTone}`));
    }
  }
  function onSkinToneOptionsKeydown(event) {
    if (!skinTonePickerExpanded) {
      return;
    }
    const changeActiveSkinTone = async (nextSkinTone) => {
      halt(event);
      $$invalidate(20, activeSkinTone = nextSkinTone);
      await tick();
      focus(`skintone-${activeSkinTone}`);
    };
    switch (event.key) {
      case "ArrowUp":
        return changeActiveSkinTone(incrementOrDecrement(true, activeSkinTone, skinTones));
      case "ArrowDown":
        return changeActiveSkinTone(incrementOrDecrement(false, activeSkinTone, skinTones));
      case "Home":
        return changeActiveSkinTone(0);
      case "End":
        return changeActiveSkinTone(skinTones.length - 1);
      case "Enter":
        return onSkinToneOptionsClick(event);
      case "Escape":
        halt(event);
        $$invalidate(6, skinTonePickerExpanded = false);
        return focus("skintone-button");
    }
  }
  function onSkinToneOptionsKeyup(event) {
    if (!skinTonePickerExpanded) {
      return;
    }
    switch (event.key) {
      case " ":
        return onSkinToneOptionsClick(event);
    }
  }
  async function onSkinToneOptionsFocusOut(event) {
    const { relatedTarget } = event;
    if (!relatedTarget || !isSkinToneOption(relatedTarget)) {
      $$invalidate(6, skinTonePickerExpanded = false);
    }
  }
  function input_input_handler() {
    rawSearchText = this.value;
    $$invalidate(2, rawSearchText);
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      skinToneDropdown = $$value;
      $$invalidate(7, skinToneDropdown);
    });
  }
  const click_handler = (group) => onNavClick(group);
  function div10_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tabpanelElement = $$value;
      $$invalidate(3, tabpanelElement);
    });
  }
  function button1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      baselineEmoji = $$value;
      $$invalidate(17, baselineEmoji);
    });
  }
  function section_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rootElement = $$value;
      $$invalidate(16, rootElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("skinToneEmoji" in $$props2)
      $$invalidate(40, skinToneEmoji = $$props2.skinToneEmoji);
    if ("i18n" in $$props2)
      $$invalidate(0, i18n = $$props2.i18n);
    if ("database" in $$props2)
      $$invalidate(39, database = $$props2.database);
    if ("customEmoji" in $$props2)
      $$invalidate(41, customEmoji = $$props2.customEmoji);
    if ("customCategorySorting" in $$props2)
      $$invalidate(42, customCategorySorting = $$props2.customCategorySorting);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & 1280) {
      {
        if (customEmoji && database) {
          $$invalidate(39, database.customEmoji = customEmoji, database);
        }
      }
    }
    if ($$self.$$.dirty[0] & 1 | $$self.$$.dirty[1] & 256) {
      {
        async function handleDatabaseLoading() {
          let showingLoadingMessage = false;
          const timeoutHandle = setTimeout(
            () => {
              showingLoadingMessage = true;
              $$invalidate(18, message = i18n.loadingMessage);
            },
            TIMEOUT_BEFORE_LOADING_MESSAGE
          );
          try {
            await database.ready();
            $$invalidate(14, databaseLoaded = true);
          } catch (err) {
            console.error(err);
            $$invalidate(18, message = i18n.networkErrorMessage);
          } finally {
            clearTimeout(timeoutHandle);
            if (showingLoadingMessage) {
              showingLoadingMessage = false;
              $$invalidate(18, message = "");
            }
          }
        }
        if (database) {
          handleDatabaseLoading();
        }
      }
    }
    if ($$self.$$.dirty[0] & 6144 | $$self.$$.dirty[1] & 1024) {
      {
        if (customEmoji && customEmoji.length) {
          $$invalidate(12, groups$1 = [customGroup, ...groups]);
        } else if (groups$1 !== groups) {
          if (currentGroupIndex) {
            $$invalidate(11, currentGroupIndex--, currentGroupIndex);
          }
          $$invalidate(12, groups$1 = groups);
        }
      }
    }
    if ($$self.$$.dirty[0] & 4) {
      {
        rIC(() => {
          $$invalidate(44, searchText = (rawSearchText || "").trim());
          $$invalidate(5, activeSearchItem = -1);
        });
      }
    }
    if ($$self.$$.dirty[0] & 6144) {
      $$invalidate(13, currentGroup = groups$1[currentGroupIndex]);
    }
    if ($$self.$$.dirty[0] & 24576 | $$self.$$.dirty[1] & 8192) {
      {
        async function updateEmojis() {
          if (!databaseLoaded) {
            $$invalidate(1, currentEmojis = []);
            $$invalidate(4, searchMode = false);
          } else if (searchText.length >= MIN_SEARCH_TEXT_LENGTH) {
            const currentSearchText = searchText;
            const newEmojis = await getEmojisBySearchQuery(currentSearchText);
            if (currentSearchText === searchText) {
              $$invalidate(1, currentEmojis = newEmojis);
              $$invalidate(4, searchMode = true);
            }
          } else if (currentGroup) {
            const currentGroupId = currentGroup.id;
            const newEmojis = await getEmojisByGroup(currentGroupId);
            if (currentGroupId === currentGroup.id) {
              $$invalidate(1, currentEmojis = newEmojis);
              $$invalidate(4, searchMode = false);
            }
          }
        }
        updateEmojis();
      }
    }
    if ($$self.$$.dirty[0] & 4112) {
      $$invalidate(22, pickerStyle = `
  --font-family: ${FONT_FAMILY};
  --num-groups: ${groups$1.length}; 
  --indicator-opacity: ${searchMode ? 0 : 1}; 
  --num-skintones: ${NUM_SKIN_TONES};`);
    }
    if ($$self.$$.dirty[0] & 16384 | $$self.$$.dirty[1] & 256) {
      {
        async function updatePreferredSkinTone() {
          if (databaseLoaded) {
            $$invalidate(8, currentSkinTone = await database.getPreferredSkinTone());
          }
        }
        updatePreferredSkinTone();
      }
    }
    if ($$self.$$.dirty[1] & 512) {
      $$invalidate(9, skinTones = Array(NUM_SKIN_TONES).fill().map((_2, i2) => applySkinTone(skinToneEmoji, i2)));
    }
    if ($$self.$$.dirty[0] & 768) {
      $$invalidate(21, skinToneButtonText = skinTones[currentSkinTone]);
    }
    if ($$self.$$.dirty[0] & 257) {
      $$invalidate(23, skinToneButtonLabel = i18n.skinToneLabel.replace("{skinTone}", i18n.skinTones[currentSkinTone]));
    }
    if ($$self.$$.dirty[0] & 16384 | $$self.$$.dirty[1] & 256) {
      {
        async function updateDefaultFavoriteEmojis() {
          $$invalidate(45, defaultFavoriteEmojis = (await Promise.all(MOST_COMMONLY_USED_EMOJI.map((unicode) => database.getEmojiByUnicodeOrName(unicode)))).filter(Boolean));
        }
        if (databaseLoaded) {
          updateDefaultFavoriteEmojis();
        }
      }
    }
    if ($$self.$$.dirty[0] & 16384 | $$self.$$.dirty[1] & 49408) {
      {
        async function updateFavorites() {
          const dbFavorites = await database.getTopFavoriteEmoji(numColumns);
          const favorites = await summarizeEmojis(uniqBy([...dbFavorites, ...defaultFavoriteEmojis], (_2) => _2.unicode || _2.name).slice(0, numColumns));
          $$invalidate(10, currentFavorites = favorites);
        }
        if (databaseLoaded && defaultFavoriteEmojis) {
          updateFavorites();
        }
      }
    }
    if ($$self.$$.dirty[0] & 10) {
      {
        const zwjEmojisToCheck = currentEmojis.filter((emoji) => emoji.unicode).filter((emoji) => hasZwj(emoji) && !supportedZwjEmojis.has(emoji.unicode));
        if (zwjEmojisToCheck.length) {
          rAF(() => checkZwjSupportAndUpdate(zwjEmojisToCheck));
        } else {
          $$invalidate(1, currentEmojis = currentEmojis.filter(isZwjSupported));
          rAF(() => {
            (tabpanelElement || {}).scrollTop = 0;
          });
        }
      }
    }
    if ($$self.$$.dirty[0] & 1026 | $$self.$$.dirty[1] & 4096)
      ;
    if ($$self.$$.dirty[0] & 18 | $$self.$$.dirty[1] & 2048) {
      {
        let calculateCurrentEmojisWithCategories = function() {
          if (searchMode) {
            return [{ category: "", emojis: currentEmojis }];
          }
          const categoriesToEmoji = /* @__PURE__ */ new Map();
          for (const emoji of currentEmojis) {
            const category = emoji.category || "";
            let emojis = categoriesToEmoji.get(category);
            if (!emojis) {
              emojis = [];
              categoriesToEmoji.set(category, emojis);
            }
            emojis.push(emoji);
          }
          return [...categoriesToEmoji.entries()].map(([category, emojis]) => ({ category, emojis })).sort((a2, b2) => customCategorySorting(a2.category, b2.category));
        };
        $$invalidate(15, currentEmojisWithCategories = calculateCurrentEmojisWithCategories());
      }
    }
    if ($$self.$$.dirty[0] & 34) {
      $$invalidate(26, activeSearchItemId = activeSearchItem !== -1 && currentEmojis[activeSearchItem].id);
    }
    if ($$self.$$.dirty[0] & 192) {
      {
        if (skinTonePickerExpanded) {
          skinToneDropdown.addEventListener(
            "transitionend",
            () => {
              $$invalidate(19, skinTonePickerExpandedAfterAnimation = true);
            },
            { once: true }
          );
        } else {
          $$invalidate(19, skinTonePickerExpandedAfterAnimation = false);
        }
      }
    }
  };
  return [
    i18n,
    currentEmojis,
    rawSearchText,
    tabpanelElement,
    searchMode,
    activeSearchItem,
    skinTonePickerExpanded,
    skinToneDropdown,
    currentSkinTone,
    skinTones,
    currentFavorites,
    currentGroupIndex,
    groups$1,
    currentGroup,
    databaseLoaded,
    currentEmojisWithCategories,
    rootElement,
    baselineEmoji,
    message,
    skinTonePickerExpandedAfterAnimation,
    activeSkinTone,
    skinToneButtonText,
    pickerStyle,
    skinToneButtonLabel,
    isRtl,
    scrollbarWidth,
    activeSearchItemId,
    unicodeWithSkin,
    labelWithSkin,
    calculateEmojiGridStyle,
    onSearchKeydown,
    onNavClick,
    onNavKeydown,
    onEmojiClick,
    onSkinToneOptionsClick,
    onClickSkinToneButton,
    onSkinToneOptionsKeydown,
    onSkinToneOptionsKeyup,
    onSkinToneOptionsFocusOut,
    database,
    skinToneEmoji,
    customEmoji,
    customCategorySorting,
    initialLoad,
    searchText,
    defaultFavoriteEmojis,
    numColumns,
    input_input_handler,
    div3_binding,
    click_handler,
    div10_binding,
    button1_binding,
    section_binding
  ];
}
class Picker extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        skinToneEmoji: 40,
        i18n: 0,
        database: 39,
        customEmoji: 41,
        customCategorySorting: 42
      },
      null,
      [-1, -1, -1]
    );
  }
}
const DEFAULT_DATA_SOURCE = "https://cdn.jsdelivr.net/npm/emoji-picker-element-data@^1/en/emojibase/data.json";
const DEFAULT_LOCALE = "en";
var enI18n = {
  categoriesLabel: "Categories",
  emojiUnsupportedMessage: "Your browser does not support color emoji.",
  favoritesLabel: "Favorites",
  loadingMessage: "Loading\u2026",
  networkErrorMessage: "Could not load emoji.",
  regionLabel: "Emoji picker",
  searchDescription: "When search results are available, press up or down to select and enter to choose.",
  searchLabel: "Search",
  searchResultsLabel: "Search results",
  skinToneDescription: "When expanded, press up or down to select and enter to choose.",
  skinToneLabel: "Choose a skin tone (currently {skinTone})",
  skinTonesLabel: "Skin tones",
  skinTones: [
    "Default",
    "Light",
    "Medium-Light",
    "Medium",
    "Medium-Dark",
    "Dark"
  ],
  categories: {
    custom: "Custom",
    "smileys-emotion": "Smileys and emoticons",
    "people-body": "People and body",
    "animals-nature": "Animals and nature",
    "food-drink": "Food and drink",
    "travel-places": "Travel and places",
    activities: "Activities",
    objects: "Objects",
    symbols: "Symbols",
    flags: "Flags"
  }
};
const PROPS = [
  "customEmoji",
  "customCategorySorting",
  "database",
  "dataSource",
  "i18n",
  "locale",
  "skinToneEmoji"
];
class PickerElement extends HTMLElement {
  constructor(props2) {
    super();
    this.attachShadow({ mode: "open" });
    const style2 = document.createElement("style");
    style2.textContent = ":host{--emoji-size:1.375rem;--emoji-padding:0.5rem;--category-emoji-size:var(--emoji-size);--category-emoji-padding:var(--emoji-padding);--indicator-height:3px;--input-border-radius:0.5rem;--input-border-size:1px;--input-font-size:1rem;--input-line-height:1.5;--input-padding:0.25rem;--num-columns:8;--outline-size:2px;--border-size:1px;--skintone-border-radius:1rem;--category-font-size:1rem;display:flex;width:min-content;height:400px}:host,:host(.light){--background:#fff;--border-color:#e0e0e0;--indicator-color:#385ac1;--input-border-color:#999;--input-font-color:#111;--input-placeholder-color:#999;--outline-color:#999;--category-font-color:#111;--button-active-background:#e6e6e6;--button-hover-background:#d9d9d9}:host(.dark){--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}@media (prefers-color-scheme:dark){:host{--background:#222;--border-color:#444;--indicator-color:#5373ec;--input-border-color:#ccc;--input-font-color:#efefef;--input-placeholder-color:#ccc;--outline-color:#fff;--category-font-color:#efefef;--button-active-background:#555555;--button-hover-background:#484848}}:host([hidden]){display:none}button{margin:0;padding:0;border:0;background:0 0;box-shadow:none;-webkit-tap-highlight-color:transparent}button::-moz-focus-inner{border:0}input{padding:0;margin:0;line-height:1.15;font-family:inherit}input[type=search]{-webkit-appearance:none}:focus{outline:var(--outline-color) solid var(--outline-size);outline-offset:calc(-1*var(--outline-size))}:host([data-js-focus-visible]) :focus:not([data-focus-visible-added]){outline:0}:focus:not(:focus-visible){outline:0}.hide-focus{outline:0}*{box-sizing:border-box}.picker{contain:content;display:flex;flex-direction:column;background:var(--background);border:var(--border-size) solid var(--border-color);width:100%;height:100%;overflow:hidden;--total-emoji-size:calc(var(--emoji-size) + (2 * var(--emoji-padding)));--total-category-emoji-size:calc(var(--category-emoji-size) + (2 * var(--category-emoji-padding)))}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.hidden{opacity:0;pointer-events:none}.abs-pos{position:absolute;left:0;top:0}.gone{display:none!important}.skintone-button-wrapper,.skintone-list{background:var(--background);z-index:3}.skintone-button-wrapper.expanded{z-index:1}.skintone-list{position:absolute;inset-inline-end:0;top:0;z-index:2;overflow:visible;border-bottom:var(--border-size) solid var(--border-color);border-radius:0 0 var(--skintone-border-radius) var(--skintone-border-radius);will-change:transform;transition:transform .2s ease-in-out;transform-origin:center 0}@media (prefers-reduced-motion:reduce){.skintone-list{transition-duration:.001s}}@supports not (inset-inline-end:0){.skintone-list{right:0}}.skintone-list.no-animate{transition:none}.tabpanel{overflow-y:auto;-webkit-overflow-scrolling:touch;will-change:transform;min-height:0;flex:1;contain:content}.emoji-menu{display:grid;grid-template-columns:repeat(var(--num-columns),var(--total-emoji-size));justify-content:space-around;align-items:flex-start;width:100%}.category{padding:var(--emoji-padding);font-size:var(--category-font-size);color:var(--category-font-color)}.custom-emoji,.emoji,button.emoji{height:var(--total-emoji-size);width:var(--total-emoji-size)}.emoji,button.emoji{font-size:var(--emoji-size);display:flex;align-items:center;justify-content:center;border-radius:100%;line-height:1;overflow:hidden;font-family:var(--font-family);cursor:pointer}@media (hover:hover) and (pointer:fine){.emoji:hover,button.emoji:hover{background:var(--button-hover-background)}}.emoji.active,.emoji:active,button.emoji.active,button.emoji:active{background:var(--button-active-background)}.custom-emoji{padding:var(--emoji-padding);object-fit:contain;pointer-events:none;background-repeat:no-repeat;background-position:center center;background-size:var(--emoji-size) var(--emoji-size)}.nav,.nav-button{align-items:center}.nav{display:grid;justify-content:space-between;contain:content}.nav-button{display:flex;justify-content:center}.nav-emoji{font-size:var(--category-emoji-size);width:var(--total-category-emoji-size);height:var(--total-category-emoji-size)}.indicator-wrapper{display:flex;border-bottom:1px solid var(--border-color)}.indicator{width:calc(100%/var(--num-groups));height:var(--indicator-height);opacity:var(--indicator-opacity);background-color:var(--indicator-color);will-change:transform,opacity;transition:opacity .1s linear,transform .25s ease-in-out}@media (prefers-reduced-motion:reduce){.indicator{will-change:opacity;transition:opacity .1s linear}}.pad-top,input.search{background:var(--background);width:100%}.pad-top{height:var(--emoji-padding);z-index:3}.search-row{display:flex;align-items:center;position:relative;padding-inline-start:var(--emoji-padding);padding-bottom:var(--emoji-padding)}.search-wrapper{flex:1;min-width:0}input.search{padding:var(--input-padding);border-radius:var(--input-border-radius);border:var(--input-border-size) solid var(--input-border-color);color:var(--input-font-color);font-size:var(--input-font-size);line-height:var(--input-line-height)}input.search::placeholder{color:var(--input-placeholder-color)}.favorites{display:flex;flex-direction:row;border-top:var(--border-size) solid var(--border-color);contain:content}.message{padding:var(--emoji-padding)}";
    this.shadowRoot.appendChild(style2);
    this._ctx = {
      locale: DEFAULT_LOCALE,
      dataSource: DEFAULT_DATA_SOURCE,
      skinToneEmoji: DEFAULT_SKIN_TONE_EMOJI,
      customCategorySorting: DEFAULT_CATEGORY_SORTING,
      customEmoji: null,
      i18n: enI18n,
      ...props2
    };
    for (const prop of PROPS) {
      if (prop !== "database" && Object.prototype.hasOwnProperty.call(this, prop)) {
        this._ctx[prop] = this[prop];
        delete this[prop];
      }
    }
    this._dbFlush();
  }
  connectedCallback() {
    this._cmp = new Picker({
      target: this.shadowRoot,
      props: this._ctx
    });
  }
  disconnectedCallback() {
    this._cmp.$destroy();
    this._cmp = void 0;
    const { database } = this._ctx;
    if (database) {
      database.close().catch((err) => console.error(err));
    }
  }
  static get observedAttributes() {
    return ["locale", "data-source", "skin-tone-emoji"];
  }
  attributeChangedCallback(attrName, oldValue, newValue) {
    this._set(
      attrName.replace(/-([a-z])/g, (_2, up) => up.toUpperCase()),
      newValue
    );
  }
  _set(prop, newValue) {
    this._ctx[prop] = newValue;
    if (this._cmp) {
      this._cmp.$set({ [prop]: newValue });
    }
    if (["locale", "dataSource"].includes(prop)) {
      this._dbFlush();
    }
  }
  _dbCreate() {
    const { locale: locale2, dataSource, database } = this._ctx;
    if (!database || database.locale !== locale2 || database.dataSource !== dataSource) {
      this._set("database", new Database({ locale: locale2, dataSource }));
    }
  }
  _dbFlush() {
    Promise.resolve().then(() => this._dbCreate());
  }
}
const definitions = {};
for (const prop of PROPS) {
  definitions[prop] = {
    get() {
      if (prop === "database") {
        this._dbCreate();
      }
      return this._ctx[prop];
    },
    set(val) {
      if (prop === "database") {
        throw new Error("database is read-only");
      }
      this._set(prop, val);
    }
  };
}
Object.defineProperties(PickerElement.prototype, definitions);
if (!customElements.get("emoji-picker")) {
  customElements.define("emoji-picker", PickerElement);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
const adaptOnsV3 = (ons) => {
  if (!ons)
    return null;
  return Object.entries(ons).reduce((ret, [key, handler]) => {
    key = key.charAt(0).toUpperCase() + key.slice(1);
    key = `on${key}`;
    return Object.assign(Object.assign({}, ret), { [key]: handler });
  }, {});
};
const h$2 = (type, options = {}, chidren) => {
  const { props: props2, domProps, on: on2 } = options, extraOptions = __rest(options, ["props", "domProps", "on"]);
  let ons = adaptOnsV3(on2);
  const params = Object.assign(Object.assign(Object.assign(Object.assign({}, extraOptions), props2), domProps), ons);
  return h$4(type, params, chidren);
};
function isDarkMode() {
  return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
}
function toDashes(key) {
  return key.replace(/[A-Z]/g, (m2) => "-" + m2.toLowerCase());
}
var VuemojiPicker = defineComponent({
  props: {
    isDark: {
      type: Boolean,
      required: false,
      default: isDarkMode()
    },
    skinToneEmoji: String,
    customEmoji: Array,
    dataSource: String,
    locale: String,
    customCategorySorting: Function,
    i18n: Object,
    pickerStyle: Object
  },
  emits: ["emojiClick", "skinToneChange"],
  data: () => ({
    picker: new PickerElement()
  }),
  methods: {
    handleClick(event) {
      this.$emit("emojiClick", event.detail);
    },
    handleSkinToneChange(event) {
      this.$emit("skinToneChange", event.detail);
    },
    updatePickerProps() {
      const { skinToneEmoji, dataSource, locale: locale2, customEmoji, i18n, customCategorySorting, isDark } = this.$props;
      if (skinToneEmoji) {
        this.picker.skinToneEmoji = skinToneEmoji;
      }
      if (dataSource) {
        this.picker.dataSource = dataSource;
      }
      if (locale2) {
        this.picker.locale = locale2;
      }
      if (customEmoji) {
        this.picker.customEmoji = customEmoji;
      }
      if (i18n) {
        this.picker.i18n = i18n;
      }
      if (customCategorySorting) {
        this.picker.customCategorySorting = customCategorySorting;
      }
      this.picker.classList.toggle("dark", isDark);
      this.picker.classList.toggle("light", !isDark);
      this.updatePickerStyle();
    },
    updatePickerStyle() {
      if (this.pickerStyle && typeof this.pickerStyle === "object") {
        Object.keys(this.pickerStyle).forEach((key) => {
          var _a, _b;
          if (key === "height" && ((_a = this.pickerStyle) === null || _a === void 0 ? void 0 : _a.height)) {
            this.picker.style.setProperty("height", this.pickerStyle.height);
          } else if (key === "width" && ((_b = this.pickerStyle) === null || _b === void 0 ? void 0 : _b.width)) {
            this.picker.style.setProperty("width", this.pickerStyle.width);
          } else {
            this.picker.style.setProperty(`--${toDashes(key)}`, this.pickerStyle[key]);
          }
        });
      }
    }
  },
  mounted() {
    const root2 = this.$refs.root;
    this.updatePickerProps();
    root2.appendChild(this.picker);
    this.picker.addEventListener("emoji-click", this.handleClick);
    this.picker.addEventListener("skin-tone-change", this.handleSkinToneChange);
  },
  beforeUnmount() {
    this.picker.removeEventListener("emoji-click", this.handleClick);
    this.picker.removeEventListener("skin-tone-change", this.handleSkinToneChange);
  },
  watch: {
    $props: {
      handler() {
        this.updatePickerProps();
      },
      deep: true
    }
  },
  render() {
    return h$2("div", {
      ref: "root"
    });
  }
});
const _sfc_main$1u = {
  name: "AddEmoji",
  components: {
    VuemojiPicker
  },
  props: {
    questions: { type: Array, default: () => [] },
    question: { type: Object, default: null },
    logic: { type: Array, default: () => [] },
    forms: { type: Array, default: () => [] },
    questionCategory: { type: String, default: "" },
    formCategory: { type: String, default: "" }
  },
  emits: ["update:questionCategory", "update:question", "click:addMedia", "click:emoji", "update:currentQuestion", "update:logic"]
};
const _hoisted_1$1p = { class: "px-3 py-4" };
function _sfc_render$1u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VuemojiPicker = resolveComponent("VuemojiPicker");
  return openBlock(), createElementBlock("div", _hoisted_1$1p, [
    createVNode(_component_VuemojiPicker, {
      "is-dark": false,
      "picker-style": { width: "100%", "num-columns": 6, borderSize: 0 },
      onEmojiClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click:emoji", $event.unicode))
    })
  ]);
}
var AddEmoji = /* @__PURE__ */ _export_sfc$1(_sfc_main$1u, [["render", _sfc_render$1u]]);
const _sfc_main$1t = {
  name: "SettingSwitch",
  components: {
    Switch
  },
  props: {
    modelValue: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"]
};
const _hoisted_1$1o = { class: "text-xs text-navy" };
const _hoisted_2$Q = { class: "flex justify-between" };
function _sfc_render$1t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Switch = resolveComponent("Switch");
  return openBlock(), createElementBlock("div", _hoisted_1$1o, [
    createElementVNode("label", _hoisted_2$Q, [
      createElementVNode("span", null, [
        renderSlot(_ctx.$slots, "default")
      ]),
      createVNode(_component_Switch, {
        "model-value": $props.modelValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
      }, null, 8, ["model-value"])
    ])
  ]);
}
var SettingSwitch = /* @__PURE__ */ _export_sfc$1(_sfc_main$1t, [["render", _sfc_render$1t]]);
var SettingCheckboxes_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$1s = {
  name: "SettingCheckboxes",
  components: { Checkbox },
  props: {
    settings: {
      type: Object,
      default: () => ({
        options: []
      })
    },
    modelValue: { type: Array, default: () => ["days"] }
  },
  emits: ["update:modelValue"],
  methods: {
    handleChange: function(option2, checked) {
      const newValue = (checked ? [...this.modelValue, option2] : this.modelValue.filter((o2) => o2 !== option2)).filter((v2, i2, a2) => a2.indexOf(v2) === i2);
      if (newValue.length === 0) {
        return alert("You must choose at least one of the options");
      }
      this.$emit("update:modelValue", newValue);
    }
  }
};
const _hoisted_1$1n = { class: "text-xs text-navy" };
const _hoisted_2$P = { class: "flex justify-between" };
const _hoisted_3$D = { class: "flex gap-1 items-center" };
const _hoisted_4$p = { class: "capitalize checkbox-label" };
function _sfc_render$1s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Checkbox = resolveComponent("Checkbox");
  return openBlock(), createElementBlock("div", _hoisted_1$1n, [
    createElementVNode("div", _hoisted_2$P, [
      createElementVNode("span", null, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ]),
      createElementVNode("div", null, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.settings.options, (o2) => {
          return openBlock(), createElementBlock("div", {
            key: `setting-checkboxes${o2}`
          }, [
            createElementVNode("label", _hoisted_3$D, [
              createVNode(_component_Checkbox, {
                class: "h-3 w-3",
                style: { "border-radius": "0" },
                checked: $props.modelValue.indexOf(o2) !== -1,
                "onUpdate:checked": ($event) => $options.handleChange(o2, $event)
              }, null, 8, ["checked", "onUpdate:checked"]),
              createElementVNode("span", _hoisted_4$p, toDisplayString(o2), 1)
            ])
          ]);
        }), 128))
      ])
    ])
  ]);
}
var SettingCheckboxes = /* @__PURE__ */ _export_sfc$1(_sfc_main$1s, [["render", _sfc_render$1s], ["__scopeId", "data-v-4ac465ec"]]);
const _sfc_main$1r = {
  name: "SettingInput",
  components: { Input },
  props: { modelValue: { type: [String, Number], default: "" } },
  emits: ["update:modelValue"]
};
const _hoisted_1$1m = { class: "text-xs text-navy" };
const _hoisted_2$O = { class: "flex justify-between" };
function _sfc_render$1r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Input = resolveComponent("Input");
  return openBlock(), createElementBlock("div", _hoisted_1$1m, [
    createElementVNode("div", _hoisted_2$O, [
      createElementVNode("span", null, [
        renderSlot(_ctx.$slots, "default")
      ]),
      createElementVNode("div", null, [
        createVNode(_component_Input, {
          type: "text",
          class: "h-6 w-32 pl-1 pr-0 text-xxs text-gray-600",
          "model-value": $props.modelValue,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
        }, null, 8, ["model-value"])
      ])
    ])
  ]);
}
var SettingInput = /* @__PURE__ */ _export_sfc$1(_sfc_main$1r, [["render", _sfc_render$1r]]);
const _sfc_main$1q = {
  name: "SettingInputNumber",
  components: { Input },
  props: { modelValue: { type: [String, Number], default: "" } },
  emits: ["update:modelValue"]
};
const _hoisted_1$1l = { class: "text-xs text-navy" };
const _hoisted_2$N = { class: "flex justify-between" };
function _sfc_render$1q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Input = resolveComponent("Input");
  return openBlock(), createElementBlock("div", _hoisted_1$1l, [
    createElementVNode("div", _hoisted_2$N, [
      createElementVNode("span", null, [
        renderSlot(_ctx.$slots, "default")
      ]),
      createElementVNode("div", null, [
        createVNode(_component_Input, {
          type: "number",
          class: "h-6 w-16 pl-1 pr-0 text-xxs text-gray-600",
          min: 1,
          "model-value": $props.modelValue,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
        }, null, 8, ["model-value"])
      ])
    ])
  ]);
}
var SettingInputNumber = /* @__PURE__ */ _export_sfc$1(_sfc_main$1q, [["render", _sfc_render$1q]]);
const QUESTION_CATEGORY_KICK_OFF = "kick_off";
const QUESTION_CATEGORY_FOLLOW_UP = "follow_up";
const QUESTION_CATEGORY_TYP = "typ";
const QUESTION_CATEGORY_NAME = {
  [QUESTION_CATEGORY_KICK_OFF]: "Kick-off Question",
  [QUESTION_CATEGORY_FOLLOW_UP]: "Follow-up Question",
  [QUESTION_CATEGORY_TYP]: "Thank You Page"
};
const QUESTION_TYPE_OPEN = "open";
const QUESTION_TYPE_MULTIPLE_CHOICE = "multiple_choice";
const QUESTION_TYPE_YES_NO = "yes_no";
const QUESTION_TYPE_DELAY = "delay";
const QUESTION_TYPE_RATING_SCORE = "rating_score";
const QUESTION_TYPE_PURCHASED_ITEMS_CHOICE = "purchased_items_choice";
const QUESTION_TYPE_UPLOAD_FILES = "upload_files";
const QUESTION_TYPE_NAME = {
  [QUESTION_TYPE_OPEN]: "Open",
  [QUESTION_TYPE_MULTIPLE_CHOICE]: "Multiple choice",
  [QUESTION_TYPE_YES_NO]: "Yes/No",
  [QUESTION_TYPE_DELAY]: "Delay",
  [QUESTION_TYPE_RATING_SCORE]: "Rating score"
};
const PURCHASED_ITEMS_CHOICE_QUESTION = {
  id: QUESTION_TYPE_PURCHASED_ITEMS_CHOICE,
  type: QUESTION_TYPE_PURCHASED_ITEMS_CHOICE,
  title: "Which of your purchases would you like to review?"
};
const uploadFilesQuestion = (itemId) => ({
  id: QUESTION_TYPE_UPLOAD_FILES + itemId,
  type: QUESTION_TYPE_UPLOAD_FILES,
  title: "Do you have any photos or videos to add to your review?",
  order_item_id: itemId
});
const COMMON_SETTINGS = {
  required: { c: SettingSwitch }
};
const SETTINGS = {
  [QUESTION_TYPE_OPEN]: COMMON_SETTINGS,
  [QUESTION_TYPE_MULTIPLE_CHOICE]: {
    ...COMMON_SETTINGS,
    allow_multiple_selection: { c: SettingSwitch },
    randomize: { c: SettingSwitch },
    allow_other_choice: { c: SettingSwitch }
  },
  [QUESTION_TYPE_YES_NO]: COMMON_SETTINGS,
  [QUESTION_TYPE_DELAY]: {
    ...COMMON_SETTINGS,
    period: { c: SettingCheckboxes, s: { options: ["days", "weeks", "months"] } },
    restrict_delay: { c: SettingSwitch },
    max_delay: { c: SettingInputNumber, depends: "restrict_delay" }
  },
  [QUESTION_TYPE_RATING_SCORE]: {
    ...COMMON_SETTINGS,
    label_left: { c: SettingInput },
    label_middle: { c: SettingInput },
    label_right: { c: SettingInput }
  }
};
const SETTING_TITLE = {
  required: "Is question required?",
  allow_multiple_selection: "Multiple selection possible?",
  allow_other_choice: 'Include "other" answer option',
  randomize: "Randomize answer options?",
  period: "Period selector",
  restrict_delay: "Restrict maximum time delay",
  max_delay: "Max delay in days",
  label_left: "Label left",
  label_right: "Label right",
  label_middle: "Label middle",
  from: "From",
  to: "To"
};
var questions = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  QUESTION_CATEGORY_KICK_OFF,
  QUESTION_CATEGORY_FOLLOW_UP,
  QUESTION_CATEGORY_TYP,
  QUESTION_CATEGORY_NAME,
  QUESTION_TYPE_OPEN,
  QUESTION_TYPE_MULTIPLE_CHOICE,
  QUESTION_TYPE_YES_NO,
  QUESTION_TYPE_DELAY,
  QUESTION_TYPE_RATING_SCORE,
  QUESTION_TYPE_PURCHASED_ITEMS_CHOICE,
  QUESTION_TYPE_UPLOAD_FILES,
  QUESTION_TYPE_NAME,
  PURCHASED_ITEMS_CHOICE_QUESTION,
  uploadFilesQuestion,
  COMMON_SETTINGS,
  SETTINGS,
  SETTING_TITLE
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$1p = {
  name: "QuestionIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$1k = /* @__PURE__ */ createElementVNode("path", {
  d: "M5.25,6.033H6.57A1.277,1.277,0,0,1,7.93,4.649,1.161,1.161,0,0,1,9.243,5.817c0,.635-.374.927-.965,1.371A2.277,2.277,0,0,0,7.11,9.175l.007.463H8.424V9.283c0-.718.273-.927,1.01-1.486a2.44,2.44,0,0,0,1.244-2.056C10.678,4.23,9.4,3.5,8,3.5c-1.326,0-2.786.647-2.754,2.533Zm1.562,5.516a.942.942,0,0,0,1.01.927.938.938,0,1,0,0-1.867A.94.94,0,0,0,6.812,11.549Z",
  transform: "translate(-5.25 -3.5)"
}, null, -1);
function _sfc_render$1p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 5.428 8.976" }), {
    default: withCtx(() => [
      _hoisted_1$1k
    ]),
    _: 1
  }, 16);
}
var QuestionIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1p, [["render", _sfc_render$1p]]);
var QuestionAddIcon_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$1o = {
  name: "QuestionIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _withScopeId$a = (n2) => (pushScopeId("data-v-0f11abcf"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1j = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createElementVNode("g", { transform: "translate(-19.374 -10.551)" }, [
  /* @__PURE__ */ createElementVNode("g", { transform: "translate(14.124 9.294)" }, [
    /* @__PURE__ */ createElementVNode("path", {
      class: "cls-1",
      d: "M5.25,6.033H6.57A1.277,1.277,0,0,1,7.93,4.649,1.161,1.161,0,0,1,9.243,5.817c0,.635-.374.927-.965,1.371A2.277,2.277,0,0,0,7.11,9.175l.007.463H8.424V9.283c0-.718.273-.927,1.01-1.486a2.44,2.44,0,0,0,1.244-2.056C10.678,4.23,9.4,3.5,8,3.5c-1.326,0-2.786.647-2.754,2.533Zm1.562,5.516a.942.942,0,0,0,1.01.927.938.938,0,1,0,0-1.867A.94.94,0,0,0,6.812,11.549Z"
    })
  ]),
  /* @__PURE__ */ createElementVNode("g", { transform: "translate(-26.972 -296.199)" }, [
    /* @__PURE__ */ createElementVNode("g", { transform: "translate(52 307)" }, [
      /* @__PURE__ */ createElementVNode("path", {
        class: "cls-2",
        d: "M8,3.5V6.443",
        transform: "translate(-6.528 -3.5)"
      }),
      /* @__PURE__ */ createElementVNode("path", {
        class: "cls-2",
        d: "M6.443,8H3.5",
        transform: "translate(-3.5 -6.528)"
      })
    ])
  ])
], -1));
function _sfc_render$1o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 8.848 11.219" }), {
    default: withCtx(() => [
      _hoisted_1$1j
    ]),
    _: 1
  }, 16);
}
var QuestionAddIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1o, [["render", _sfc_render$1o], ["__scopeId", "data-v-0f11abcf"]]);
const _sfc_main$1n = {
  name: "HandshakeIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$1i = /* @__PURE__ */ createElementVNode("path", {
  d: "M8.374,3.485a2.773,2.773,0,0,0-.719.079A2.567,2.567,0,0,0,6.9,3.91a2.615,2.615,0,0,0-.945-.387A7.788,7.788,0,0,0,4.821,3.51a3.818,3.818,0,0,0-1.305.452,5.545,5.545,0,0,1-2.09.387H1v4.1l.239.12.785.387,2.8,3.115.013.013a1.456,1.456,0,0,0,1.131.373,2.236,2.236,0,0,0,1.025-.306c.63-.38,2.343-1.571,2.343-1.571l.04-.027.027-.026a1.492,1.492,0,0,0,.373-.705L11.408,9l1.225-.412.293-.094V4.35H12.5a5.469,5.469,0,0,1-2.09-.4,3.731,3.731,0,0,0-1.3-.452C8.846,3.493,8.61,3.482,8.374,3.485Zm.013.852c.192,0,.413.009.693.013.044,0,.454.176,1.025.4a6.671,6.671,0,0,0,1.97.412V7.877l-.986.333h-.026l-.027.013-1.291.653a1.512,1.512,0,0,0-.319-.532L9.4,8.3,7.588,6.081l-.267-.333-.333.267-1.144.932a.9.9,0,0,1-1.012.04.83.83,0,0,1-.16-.106L6.615,5.269l.026-.026a2.868,2.868,0,0,1,1.238-.852,2.01,2.01,0,0,1,.506-.054ZM5.42,4.35a3.106,3.106,0,0,1,.426.013,1.871,1.871,0,0,1,.346.147c-.043.04-.075.063-.12.106l-.026.027-2.33,1.93-.36.293.319.333a2.806,2.806,0,0,0,.785.559,1.857,1.857,0,0,0,1.877-.106l.027-.027.826-.678,1.571,1.93.013.027.013.013a.7.7,0,0,1,0,1s0,.009,0,.013l-.066.041-.559-.759-.693.506.546.732c-.221.15-.321.228-.559.387l-.572-.772-.693.506.546.732c-.049.03-.148.1-.187.12a1.523,1.523,0,0,1-.626.186A.7.7,0,0,1,5.46,11.5l-.013-.013L2.6,8.331l-.054-.067-.693-.347V5.162a6.875,6.875,0,0,0,1.97-.4c.569-.218.975-.4,1.025-.4Z",
  transform: "translate(-1 -3.485)"
}, null, -1);
function _sfc_render$1n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 11.926 8.976" }), {
    default: withCtx(() => [
      _hoisted_1$1i
    ]),
    _: 1
  }, 16);
}
var HandshakeIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1n, [["render", _sfc_render$1n]]);
const _sfc_main$1m = {
  name: "MultipleChoiceIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$1h = /* @__PURE__ */ createElementVNode("path", {
  d: "M9.763,2v.913H11.4L7.48,6.834,3.559,2.913H5.2V2H2V5.2h.913V3.559l4.11,4.11V12.96h.913V7.669l4.11-4.11V5.2h.913V2Z",
  transform: "translate(-2 -2)"
}, null, -1);
function _sfc_render$1m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 10 10" }), {
    default: withCtx(() => [
      _hoisted_1$1h
    ]),
    _: 1
  }, 16);
}
var MultipleChoiceIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1m, [["render", _sfc_render$1m]]);
const _sfc_main$1l = {
  name: "ClockIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$1g = ["fill"];
const _hoisted_2$M = ["fill"];
function _sfc_render$1l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 15 15" }), {
    default: withCtx(() => [
      createElementVNode("path", {
        fill: _ctx.iconColor,
        d: "M8,15a7,7,0,1,1,7-7,7,7,0,0,1-7,7ZM8,2a6,6,0,1,0,6,6A6,6,0,0,0,8,2Z"
      }, null, 8, _hoisted_1$1g),
      createElementVNode("path", {
        fill: _ctx.iconColor,
        d: "M10.3,11,7.5,8.2V3.5h1V7.79L11,10.3Z"
      }, null, 8, _hoisted_2$M)
    ]),
    _: 1
  }, 16);
}
var ClockIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1l, [["render", _sfc_render$1l]]);
const FORM_CATEGORY_PRE_REVIEW = "pre_review";
const FORM_CATEGORY_REVIEW = "review";
const FORM_TYPE_PRODUCT = "products";
const FORM_TYPE_COMPANY = "company";
const FORM_CATEGORY_TITLE = {
  [FORM_CATEGORY_PRE_REVIEW]: "Pre-Review",
  [FORM_CATEGORY_REVIEW]: "Review"
};
const formCategoryTitle = (c2) => FORM_CATEGORY_TITLE[c2] || c2;
const UNAVAILABLE_QUESTIONS_BY_FORM_CATEGORY = {
  [FORM_CATEGORY_REVIEW]: [],
  [FORM_CATEGORY_PRE_REVIEW]: [QUESTION_TYPE_RATING_SCORE]
};
const PREVIEW_TYPE_QUESTION = "question";
const PREVIEW_TYPE_FORM = "form";
var form = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FORM_CATEGORY_PRE_REVIEW,
  FORM_CATEGORY_REVIEW,
  FORM_TYPE_PRODUCT,
  FORM_TYPE_COMPANY,
  FORM_CATEGORY_TITLE,
  formCategoryTitle,
  UNAVAILABLE_QUESTIONS_BY_FORM_CATEGORY,
  PREVIEW_TYPE_QUESTION,
  PREVIEW_TYPE_FORM
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$1k = {
  name: "QuestionCategoryAndType",
  components: {
    SelectBox
  },
  props: {
    category: { type: String, default: null },
    type: { type: String, default: null },
    formCategory: { type: String, required: true }
  },
  emits: ["update:category", "update:type"],
  data: function() {
    return {
      categoriesOptions: Object.freeze([
        { value: QUESTION_CATEGORY_KICK_OFF, title: "Kick-off question", icon: { component: QuestionIcon, style: "bg-kick_off" } },
        { value: QUESTION_CATEGORY_FOLLOW_UP, title: "Follow up question", icon: { component: QuestionAddIcon, height: 11 } },
        { value: QUESTION_CATEGORY_TYP, title: "Thank you page", icon: { component: HandshakeIcon, style: "bg-typ" } }
      ]),
      questionCategory: this.category,
      questionType: this.type,
      QUESTION_CATEGORY_TYP
    };
  },
  computed: {
    typesOptions: function() {
      return [
        { value: QUESTION_TYPE_MULTIPLE_CHOICE, title: "Multiple choice", icon: { component: MultipleChoiceIcon, style: "bg-multiple_choice" } },
        { value: QUESTION_TYPE_YES_NO, title: "Yes/no", icon: { component: MultipleChoiceIcon } },
        { value: QUESTION_TYPE_OPEN, title: "Open", icon: { component: QuestionIcon } },
        { value: QUESTION_TYPE_DELAY, title: "Time delay", icon: { component: ClockIcon, height: 14, style: "bg-time_delay" } },
        { value: QUESTION_TYPE_RATING_SCORE, title: "Rating score", icon: { component: render$e } }
      ].filter((t2) => UNAVAILABLE_QUESTIONS_BY_FORM_CATEGORY[this.formCategory].indexOf(t2.value) === -1);
    }
  }
};
const _hoisted_1$1f = { class: "border-b pt-2 pb-3 px-3 relative z-20" };
const _hoisted_2$L = {
  key: 0,
  class: "border-b pt-2 pb-3 px-3 relative z-10"
};
const _hoisted_3$C = {
  key: 0,
  class: "opacity-10 bg-black absolute left-0 right-0 bottom-0 top-0 z-10"
};
function _sfc_render$1k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SelectBox = resolveComponent("SelectBox");
  return openBlock(), createElementBlock(Fragment, null, [
    createElementVNode("div", _hoisted_1$1f, [
      createVNode(_component_SelectBox, {
        label: "Question category",
        "model-value": $props.category,
        items: _ctx.categoriesOptions,
        placeholder: "Choose the category",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:category", $event))
      }, null, 8, ["model-value", "items"])
    ]),
    $props.category !== _ctx.QUESTION_CATEGORY_TYP ? (openBlock(), createElementBlock("div", _hoisted_2$L, [
      !$props.category ? (openBlock(), createElementBlock("div", _hoisted_3$C)) : createCommentVNode("", true),
      createVNode(_component_SelectBox, {
        label: "Question type",
        "model-value": $props.type,
        items: $options.typesOptions,
        placeholder: "Choose the type",
        disabled: !$props.category,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:type", $event))
      }, null, 8, ["model-value", "items", "disabled"])
    ])) : createCommentVNode("", true)
  ], 64);
}
var QuestionCategoryAndType = /* @__PURE__ */ _export_sfc$1(_sfc_main$1k, [["render", _sfc_render$1k]]);
const _sfc_main$1j = {
  name: "AddMediaIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$1e = { transform: "translate(-3 -4.5)" };
const _hoisted_2$K = ["fill"];
const _hoisted_3$B = ["fill"];
const _hoisted_4$o = ["fill"];
function _sfc_render$1j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 33 31.35" }), {
    default: withCtx(() => [
      createElementVNode("g", _hoisted_1$1e, [
        createElementVNode("path", {
          fill: _ctx.iconColor,
          d: "M6.3,7.8H27.75V19.35h3.3V7.8a3.3,3.3,0,0,0-3.3-3.3H6.3A3.3,3.3,0,0,0,3,7.8V27.6a3.3,3.3,0,0,0,3.3,3.3H19.5V27.6H6.3Z",
          transform: "translate(0 0)"
        }, null, 8, _hoisted_2$K),
        createElementVNode("path", {
          fill: _ctx.iconColor,
          d: "M12.45,16.8,7.5,23.4H25.65l-6.6-9.9L14.1,20.1Z",
          transform: "translate(0.45 0.9)"
        }, null, 8, _hoisted_3$B),
        createElementVNode("path", {
          fill: _ctx.iconColor,
          d: "M29.25,21h-3.3v4.95H21v3.3h4.95V34.2h3.3V29.25H34.2v-3.3H29.25Z",
          transform: "translate(1.8 1.65)"
        }, null, 8, _hoisted_4$o)
      ])
    ]),
    _: 1
  }, 16);
}
var AddMediaIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1j, [["render", _sfc_render$1j]]);
const _sfc_main$1i = {
  name: "TrashIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$1d = /* @__PURE__ */ createElementVNode("path", {
  d: "M9,28.5a3,3,0,0,0,3,3H24a3,3,0,0,0,3-3v-18H9v18m3-15H24v15H12v-15M23.25,6l-1.5-1.5h-7.5L12.75,6H7.5V9h21V6Z",
  transform: "translate(-7.5 -4.5)"
}, null, -1);
function _sfc_render$1i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 21 27" }), {
    default: withCtx(() => [
      _hoisted_1$1d
    ]),
    _: 1
  }, 16);
}
var TrashIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1i, [["render", _sfc_render$1i]]);
const _sfc_main$1h = {
  name: "QuestionSettings",
  components: {
    AddMediaIcon,
    QuestionCategoryAndType,
    SettingSwitch,
    TrashIcon
  },
  props: {
    question: { type: Object, default: void 0 },
    questionCategory: { type: String, default: void 0 },
    logic: { type: Array, default: () => [] },
    questions: { type: Array, default: () => [] },
    formCategory: { type: String, required: true },
    forms: { type: Array, default: () => [] }
  },
  emits: ["update:questionCategory", "update:question", "click:addMedia", "click:emoji", "update:currentQuestion", "update:logic"],
  computed: {
    settings: function() {
      return SETTINGS[this.question.type] || null;
    },
    settingTitles: () => SETTING_TITLE,
    allowChangeSettings: function() {
      return !(this.formCategory === FORM_CATEGORY_PRE_REVIEW && this.questionCategory === QUESTION_CATEGORY_KICK_OFF);
    },
    hasImage: function() {
      return this.question.attachments && this.question.attachments[0];
    }
  },
  mounted: function() {
    if (this.settings && Object.keys(this.settings).indexOf("period") && !this.question.properties.period) {
      this.handleChangeQuestionProp("period", ["days"]);
    }
  },
  updated: function() {
    if (this.settings && Object.keys(this.settings).indexOf("period") && !this.question.properties.period) {
      this.handleChangeQuestionProp("period", ["days"]);
    }
  },
  methods: {
    handleChangeQuestionType(type) {
      this.$emit("update:question", { ...this.question, type, properties: {} });
    },
    handleChangeQuestionProp(p2, v2) {
      this.$emit(
        "update:question",
        {
          ...this.question,
          properties: {
            ...this.question.properties,
            [p2]: v2
          }
        }
      );
    },
    isSettingSet(settingName) {
      return !!this.question.properties[settingName];
    },
    handleClickAddMedia() {
      this.$emit("click:addMedia");
    },
    handleDeleteAttachments() {
      this.$emit(
        "update:question",
        { ...this.question, attachments: [] }
      );
    }
  }
};
const _hoisted_1$1c = {
  key: 0,
  class: "border-b py-4 px-3"
};
const _hoisted_2$J = { class: "px-3 pt-4 pb-12" };
const _hoisted_3$A = { class: "text-xs text-navy flex justify-between select-none cursor-pointer" };
function _sfc_render$1h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_QuestionCategoryAndType = resolveComponent("QuestionCategoryAndType");
  const _component_TrashIcon = resolveComponent("TrashIcon");
  const _component_AddMediaIcon = resolveComponent("AddMediaIcon");
  return openBlock(), createElementBlock("div", null, [
    $options.allowChangeSettings ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createVNode(_component_QuestionCategoryAndType, {
        category: $props.questionCategory,
        type: $props.question.type,
        "form-category": $props.formCategory,
        "onUpdate:category": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:questionCategory", $event)),
        "onUpdate:type": $options.handleChangeQuestionType
      }, null, 8, ["category", "type", "form-category", "onUpdate:type"]),
      $options.settings ? (openBlock(), createElementBlock("div", _hoisted_1$1c, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.settings, (s2, settingName) => {
          return withDirectives((openBlock(), createBlock(resolveDynamicComponent(s2.c), mergeProps({
            key: `setting-${settingName}`
          }, s2.props || {}, {
            settings: s2.s,
            class: "pt-1 pb-2",
            "model-value": $props.question.properties[settingName],
            "onUpdate:modelValue": ($event) => $options.handleChangeQuestionProp(settingName, $event)
          }), {
            default: withCtx(() => [
              createTextVNode(toDisplayString($options.settingTitles[settingName]), 1)
            ]),
            _: 2
          }, 1040, ["settings", "model-value", "onUpdate:modelValue"])), [
            [vShow, s2.depends ? $options.isSettingSet(s2.depends) : true]
          ]);
        }), 128))
      ])) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true),
    createElementVNode("div", _hoisted_2$J, [
      createElementVNode("div", _hoisted_3$A, [
        createElementVNode("div", {
          class: "flex-grow",
          onClick: _cache[1] || (_cache[1] = (...args) => $options.handleClickAddMedia && $options.handleClickAddMedia(...args))
        }, toDisplayString($options.hasImage ? "Change" : "Add") + " image ", 1),
        $options.hasImage ? (openBlock(), createBlock(_component_TrashIcon, {
          key: 0,
          width: "20",
          height: "20",
          "icon-color": "red",
          onClick: $options.handleDeleteAttachments
        }, null, 8, ["onClick"])) : (openBlock(), createBlock(_component_AddMediaIcon, {
          key: 1,
          width: "20",
          height: "20",
          "icon-color": "gray",
          onClick: $options.handleClickAddMedia
        }, null, 8, ["onClick"]))
      ])
    ])
  ]);
}
var QuestionSettings = /* @__PURE__ */ _export_sfc$1(_sfc_main$1h, [["render", _sfc_render$1h]]);
const _sfc_main$1g = {
  name: "TrashIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$1b = /* @__PURE__ */ createElementVNode("path", {
  d: "M18,21a3,3,0,1,1-3,3,3,3,0,0,1,3-3m17.19-7.71L32.805,23.625,22.5,21.24l5.7-3.57A12,12,0,0,0,6.18,21.945L3.225,21.42A15.007,15.007,0,0,1,30.75,16.08l4.44-2.79Z",
  transform: "translate(-3.225 -9)"
}, null, -1);
function _sfc_render$1g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 31.965 18" }), {
    default: withCtx(() => [
      _hoisted_1$1b
    ]),
    _: 1
  }, 16);
}
var JumpIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1g, [["render", _sfc_render$1g]]);
const _sfc_main$1f = {
  name: "StopIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$1a = /* @__PURE__ */ createElementVNode("circle", {
  cx: "8.5",
  cy: "8.5",
  r: "8.5"
}, null, -1);
const _hoisted_2$I = /* @__PURE__ */ createElementVNode("line", {
  y1: "9",
  y2: "9",
  stroke: "#fff",
  x2: "13",
  x1: "4",
  "stroke-width": "2"
}, null, -1);
function _sfc_render$1f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 17 17" }), {
    default: withCtx(() => [
      _hoisted_1$1a,
      _hoisted_2$I
    ]),
    _: 1
  }, 16);
}
var StopIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1f, [["render", _sfc_render$1f]]);
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i$2 = 0; i$2 < 256; ++i$2) {
  byteToHex.push((i$2 + 256).toString(16).substr(1));
}
function stringify$1(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
function v4(options, buf, offset2) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset2 + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify$1(rnds);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var axios$2 = { exports: {} };
var bind$2 = function bind(fn3, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    return fn3.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString$1 = Object.prototype.toString;
function isArray$3(val) {
  return Array.isArray(val);
}
function isUndefined$1(val) {
  return typeof val === "undefined";
}
function isBuffer$2(val) {
  return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString$1.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return toString$1.call(val) === "[object FormData]";
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
function isString$2(val) {
  return typeof val === "string";
}
function isNumber$1(val) {
  return typeof val === "number";
}
function isObject$3(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject$2(val) {
  if (toString$1.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate$1(val) {
  return toString$1.call(val) === "[object Date]";
}
function isFile(val) {
  return toString$1.call(val) === "[object File]";
}
function isBlob(val) {
  return toString$1.call(val) === "[object Blob]";
}
function isFunction$2(val) {
  return toString$1.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$3(val) && isFunction$2(val.pipe);
}
function isURLSearchParams(val) {
  return toString$1.call(val) === "[object URLSearchParams]";
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn3) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$3(obj)) {
    for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn3.call(null, obj[i2], i2, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn3.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge$3() {
  var result = {};
  function assignValue2(val, key) {
    if (isPlainObject$2(result[key]) && isPlainObject$2(val)) {
      result[key] = merge$3(result[key], val);
    } else if (isPlainObject$2(val)) {
      result[key] = merge$3({}, val);
    } else if (isArray$3(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    forEach(arguments[i2], assignValue2);
  }
  return result;
}
function extend$2(a2, b2, thisArg) {
  forEach(b2, function assignValue2(val, key) {
    if (thisArg && typeof val === "function") {
      a2[key] = bind$1(val, thisArg);
    } else {
      a2[key] = val;
    }
  });
  return a2;
}
function stripBOM(content) {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
}
var utils$e = {
  isArray: isArray$3,
  isArrayBuffer,
  isBuffer: isBuffer$2,
  isFormData,
  isArrayBufferView,
  isString: isString$2,
  isNumber: isNumber$1,
  isObject: isObject$3,
  isPlainObject: isPlainObject$2,
  isUndefined: isUndefined$1,
  isDate: isDate$1,
  isFile,
  isBlob,
  isFunction: isFunction$2,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge: merge$3,
  extend: extend$2,
  trim,
  stripBOM
};
var utils$d = utils$e;
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$2 = function buildURL(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$d.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$d.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$d.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$d.forEach(val, function parseValue(v2) {
        if (utils$d.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils$d.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode(key) + "=" + encode(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$c = utils$e;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn3) {
  utils$c.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn3(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$b = utils$e;
var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
  utils$b.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};
var enhanceError$2 = function enhanceError(error, config, code, request2, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request2;
  error.response = response;
  error.isAxiosError = true;
  error.toJSON = function toJSON2() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
};
var enhanceError$1 = enhanceError$2;
var createError$2 = function createError(message, config, code, request2, response) {
  var error = new Error(message);
  return enhanceError$1(error, config, code, request2, response);
};
var createError$1 = createError$2;
var settle$1 = function settle(resolve, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(createError$1(
      "Request failed with status code " + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};
var utils$a = utils$e;
var cookies$1 = utils$a.isStandardBrowserEnv() ? function standardBrowserEnv() {
  return {
    write: function write2(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + "=" + encodeURIComponent(value));
      if (utils$a.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils$a.isString(path)) {
        cookie.push("path=" + path);
      }
      if (utils$a.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read2(name) {
      var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write2() {
    },
    read: function read2() {
      return null;
    },
    remove: function remove() {
    }
  };
}();
var isAbsoluteURL$1 = function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};
var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL2 = isAbsoluteURL$1;
var combineURLs2 = combineURLs$1;
var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL2(requestedURL)) {
    return combineURLs2(baseURL, requestedURL);
  }
  return requestedURL;
};
var utils$9 = utils$e;
var ignoreDuplicateOf = [
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
];
var parseHeaders$1 = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i2;
  if (!headers) {
    return parsed;
  }
  utils$9.forEach(headers.split("\n"), function parser(line) {
    i2 = line.indexOf(":");
    key = utils$9.trim(line.substr(0, i2)).toLowerCase();
    val = utils$9.trim(line.substr(i2 + 1));
    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === "set-cookie") {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    }
  });
  return parsed;
};
var utils$8 = utils$e;
var isURLSameOrigin$1 = utils$8.isStandardBrowserEnv() ? function standardBrowserEnv2() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement("a");
  var originURL;
  function resolveURL(url) {
    var href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    var parsed = utils$8.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
function Cancel$3(message) {
  this.message = message;
}
Cancel$3.prototype.toString = function toString() {
  return "Cancel" + (this.message ? ": " + this.message : "");
};
Cancel$3.prototype.__CANCEL__ = true;
var Cancel_1 = Cancel$3;
var utils$7 = utils$e;
var settle2 = settle$1;
var cookies = cookies$1;
var buildURL$1 = buildURL$2;
var buildFullPath2 = buildFullPath$1;
var parseHeaders2 = parseHeaders$1;
var isURLSameOrigin = isURLSameOrigin$1;
var createError2 = createError$2;
var defaults$6 = defaults_1;
var Cancel$2 = Cancel_1;
var xhr = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils$7.isFormData(requestData)) {
      delete requestHeaders["Content-Type"];
    }
    var request2 = new XMLHttpRequest();
    if (config.auth) {
      var username = config.auth.username || "";
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
    }
    var fullPath = buildFullPath2(config.baseURL, config.url);
    request2.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true);
    request2.timeout = config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      var response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle2(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(createError2("Request aborted", config, "ECONNABORTED", request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(createError2("Network Error", config, null, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      var transitional2 = config.transitional || defaults$6.transitional;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError2(
        timeoutErrorMessage,
        config,
        transitional2.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
        request2
      ));
      request2 = null;
    };
    if (utils$7.isStandardBrowserEnv()) {
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }
    if ("setRequestHeader" in request2) {
      utils$7.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
          delete requestHeaders[key];
        } else {
          request2.setRequestHeader(key, val);
        }
      });
    }
    if (!utils$7.isUndefined(config.withCredentials)) {
      request2.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request2.addEventListener("progress", config.onDownloadProgress);
    }
    if (typeof config.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", config.onUploadProgress);
    }
    if (config.cancelToken || config.signal) {
      onCanceled = function(cancel) {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel && cancel.type ? new Cancel$2("canceled") : cancel);
        request2.abort();
        request2 = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    if (!requestData) {
      requestData = null;
    }
    request2.send(requestData);
  });
};
var utils$6 = utils$e;
var normalizeHeaderName2 = normalizeHeaderName$1;
var enhanceError2 = enhanceError$2;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$6.isUndefined(headers) && utils$6.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = xhr;
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = xhr;
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$6.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$6.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$5 = {
  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data2, headers) {
    normalizeHeaderName2(headers, "Accept");
    normalizeHeaderName2(headers, "Content-Type");
    if (utils$6.isFormData(data2) || utils$6.isArrayBuffer(data2) || utils$6.isBuffer(data2) || utils$6.isStream(data2) || utils$6.isFile(data2) || utils$6.isBlob(data2)) {
      return data2;
    }
    if (utils$6.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$6.isURLSearchParams(data2)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data2.toString();
    }
    if (utils$6.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    var transitional2 = this.transitional || defaults$5.transitional;
    var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
    var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$6.isString(data2) && data2.length) {
      try {
        return JSON.parse(data2);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw enhanceError2(e2, this, "E_JSON_PARSE");
          }
          throw e2;
        }
      }
    }
    return data2;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$6.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$5.headers[method] = {};
});
utils$6.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$5.headers[method] = utils$6.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$5;
var utils$5 = utils$e;
var defaults$4 = defaults_1;
var transformData$1 = function transformData(data2, headers, fns) {
  var context = this || defaults$4;
  utils$5.forEach(fns, function transform(fn3) {
    data2 = fn3.call(context, data2, headers);
  });
  return data2;
};
var isCancel$1 = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};
var utils$4 = utils$e;
var transformData2 = transformData$1;
var isCancel2 = isCancel$1;
var defaults$3 = defaults_1;
var Cancel$1 = Cancel_1;
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new Cancel$1("canceled");
  }
}
var dispatchRequest$1 = function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = config.headers || {};
  config.data = transformData2.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );
  config.headers = utils$4.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );
  utils$4.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );
  var adapter = config.adapter || defaults$3.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData2.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel2(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData2.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$3 = utils$e;
var mergeConfig$2 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config = {};
  function getMergedValue(target, source2) {
    if (utils$3.isPlainObject(target) && utils$3.isPlainObject(source2)) {
      return utils$3.merge(target, source2);
    } else if (utils$3.isPlainObject(source2)) {
      return utils$3.merge({}, source2);
    } else if (utils$3.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(prop) {
    if (!utils$3.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$3.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils$3.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils$3.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils$3.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$3.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge2 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge2(prop);
    utils$3.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
};
var data = {
  "version": "0.25.0"
};
var VERSION = data.version;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys2 = Object.keys(options);
  var i2 = keys2.length;
  while (i2-- > 0) {
    var opt = keys2[i2];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = {
  assertOptions,
  validators: validators$1
};
var utils$2 = utils$e;
var buildURL2 = buildURL$2;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest2 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(configOrUrl, config) {
  if (typeof configOrUrl === "string") {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }
  if (!config.url) {
    throw new Error("Provided config url is not valid");
  }
  config = mergeConfig$1(this.defaults, config);
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = "get";
  }
  var transitional2 = config.transitional;
  if (transitional2 !== void 0) {
    validator.assertOptions(transitional2, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest2, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }
  try {
    promise = dispatchRequest2(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config) {
  if (!config.url) {
    throw new Error("Provided config url is not valid");
  }
  config = mergeConfig$1(this.defaults, config);
  return buildURL2(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
};
utils$2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$2.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  Axios$1.prototype[method] = function(url, data2, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data: data2
    }));
  };
});
var Axios_1 = Axios$1;
var Cancel = Cancel_1;
function CancelToken(executor) {
  if (typeof executor !== "function") {
    throw new TypeError("executor must be a function.");
  }
  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token2 = this;
  this.promise.then(function(cancel) {
    if (!token2._listeners)
      return;
    var i2;
    var l2 = token2._listeners.length;
    for (i2 = 0; i2 < l2; i2++) {
      token2._listeners[i2](cancel);
    }
    token2._listeners = null;
  });
  this.promise.then = function(onfulfilled) {
    var _resolve;
    var promise = new Promise(function(resolve) {
      token2.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);
    promise.cancel = function reject() {
      token2.unsubscribe(_resolve);
    };
    return promise;
  };
  executor(function cancel(message) {
    if (token2.reason) {
      return;
    }
    token2.reason = new Cancel(message);
    resolvePromise(token2.reason);
  });
}
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }
  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};
CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index2 = this._listeners.indexOf(listener);
  if (index2 !== -1) {
    this._listeners.splice(index2, 1);
  }
};
CancelToken.source = function source() {
  var cancel;
  var token2 = new CancelToken(function executor(c2) {
    cancel = c2;
  });
  return {
    token: token2,
    cancel
  };
};
var CancelToken_1 = CancelToken;
var spread = function spread2(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};
var utils$1 = utils$e;
var isAxiosError = function isAxiosError2(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
};
var utils = utils$e;
var bind2 = bind$2;
var Axios = Axios_1;
var mergeConfig2 = mergeConfig$2;
var defaults$2 = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance2 = bind2(Axios.prototype.request, context);
  utils.extend(instance2, Axios.prototype, context);
  utils.extend(instance2, context);
  instance2.create = function create(instanceConfig) {
    return createInstance(mergeConfig2(defaultConfig, instanceConfig));
  };
  return instance2;
}
var axios$1 = createInstance(defaults$2);
axios$1.Axios = Axios;
axios$1.Cancel = Cancel_1;
axios$1.CancelToken = CancelToken_1;
axios$1.isCancel = isCancel$1;
axios$1.VERSION = data.version;
axios$1.all = function all(promises) {
  return Promise.all(promises);
};
axios$1.spread = spread;
axios$1.isAxiosError = isAxiosError;
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axios = axios$2.exports;
function updateArrayElement(array, index2, updates) {
  return array.map(
    (el, i2) => i2 === index2 ? typeof updates === "function" ? updates(el) : { ...el, ...updates } : el
  );
}
function injectIntoString(str, pos, subject) {
  const strArr = str.split("");
  return [...strArr.slice(0, pos), subject, ...strArr.slice(pos)].join("");
}
function recursivelyGetProp(obj, path) {
  return path.reduce((acc, curr) => acc[curr], obj);
}
const merge$2 = (target, source2) => {
  target = ((obj) => {
    let cloneObj;
    try {
      cloneObj = JSON.parse(JSON.stringify(obj));
    } catch (err) {
      cloneObj = Object.assign({}, obj);
    }
    return cloneObj;
  })(target);
  const isObject2 = (obj) => obj && typeof obj === "object";
  if (!isObject2(target) || !isObject2(source2)) {
    return source2;
  }
  Object.keys(source2).forEach((key) => {
    const targetValue = target[key];
    const sourceValue = source2[key];
    if (Array.isArray(targetValue)) {
      target[key] = targetValue.map((x2, i2) => sourceValue[i2] ? merge$2(x2, sourceValue[i2]) : x2);
    } else if (isObject2(targetValue) && isObject2(sourceValue)) {
      target[key] = merge$2(Object.assign({}, targetValue), sourceValue);
    } else {
      target[key] = sourceValue;
    }
  });
  return target;
};
function filterFormQuestions(form2, omitTypes) {
  return {
    ...form2,
    kick_offs: form2.kick_offs.filter((q) => omitTypes.indexOf(q.type) === -1),
    follow_ups: form2.follow_ups.filter((q) => omitTypes.indexOf(q.type) === -1)
  };
}
function shuffle(array) {
  const newArray = array.slice();
  for (let i2 = newArray.length - 1; i2 > 0; i2--) {
    const j2 = Math.floor(Math.random() * (i2 + 1));
    [newArray[i2], newArray[j2]] = [newArray[j2], newArray[i2]];
  }
  return newArray;
}
function injectDefaultPreReviewYesNo(data2) {
  return {
    ...data2 || {},
    kick_offs: [{
      type: QUESTION_TYPE_YES_NO,
      title: "Are you ready to review your recent purchases?",
      id: v4(),
      properties: {
        choices: [
          { label: "Yes", id: v4() },
          { label: "No", id: v4() }
        ]
      }
    }]
  };
}
async function uploadFile(file, catalog, storeId) {
  const r2 = await window.Vapor.store(file, { visibility: "public-read" });
  const { data: data2 } = await axios.post(route("api.files.store"), {
    path: r2.key,
    contentType: file.type,
    extension: r2.extension,
    catalog
  }, {
    headers: { "X-Store-Id": storeId }
  });
  return data2.path;
}
function delay(ms) {
  return new Promise((resolve) => {
    setTimeout(() => resolve(), ms);
  });
}
function compare(a2, op, b2) {
  switch (op) {
    case "==":
      return a2 === b2;
    case "!=":
      return a2 !== b2;
    case ">":
      return a2 > b2;
    case "<":
      return a2 < b2;
    case ">=":
      return a2 >= b2;
    case "<=":
      return a2 <= b2;
    default:
      return false;
  }
}
var functions = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  updateArrayElement,
  injectIntoString,
  recursivelyGetProp,
  merge: merge$2,
  filterFormQuestions,
  shuffle,
  injectDefaultPreReviewYesNo,
  uploadFile,
  delay,
  compare
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$1e = {
  name: "EditIcon",
  components: { IconBase },
  props: iconProps
};
const _hoisted_1$19 = ["fill"];
const _hoisted_2$H = ["fill"];
const _hoisted_3$z = ["fill"];
const _hoisted_4$n = ["fill"];
function _sfc_render$1e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { "view-box": "0 0 17 17" }), {
    default: withCtx(() => [
      createElementVNode("g", null, [
        createElementVNode("path", {
          fill: _ctx.iconColor,
          class: "cls-16",
          d: "M21.258,23.335c.578.58.934.167,1.408-.305s.885-.831.308-1.409c0,0-8.049-8.042-10.038-10.025l-1.716,1.715L21.259,23.336Z",
          transform: "translate(-5.855 -6.909)"
        }, null, 8, _hoisted_1$19),
        createElementVNode("path", {
          fill: _ctx.iconColor,
          d: "M2.288,9.7l.667-.657s-.295-.808.137-1.2A1.329,1.329,0,0,1,4.253,7.7L6.6,5.432s-.164-1.178.053-1.4S9.3,2.635,9.533,2.4l-.5-.5s-3.4.409-3.77.777c-.217.217-1.836,1.853-2.991,3.008,0,0,.29.826-.091,1.206S.941,7,.941,7l-.678.676c-.286.288-.117.693.234,1.044l.746.746c.353.352.759.519,1.045.232Z",
          transform: "translate(-0.118 -1.899)"
        }, null, 8, _hoisted_2$H),
        createElementVNode("path", {
          fill: _ctx.iconColor,
          d: "M23.632,8.217a3.148,3.148,0,0,0,4.5-3.34L26.479,6.529l-1.407.349L23.482,5.31l.373-1.454,1.639-1.618a3.247,3.247,0,0,0-2.819.822,3.237,3.237,0,0,0-.551,3.651l-1.081,1.08L22.553,9.3l1.079-1.08Z",
          transform: "translate(-10.93 -2.05)"
        }, null, 8, _hoisted_3$z),
        createElementVNode("path", {
          fill: _ctx.iconColor,
          d: "M9.245,23.27,7.608,21.634,6.186,23.057a.894.894,0,0,0-.2.29.223.223,0,0,0-.16-.022,2.686,2.686,0,1,0-.86,5.218,2.656,2.656,0,0,0,2.56-3.559.39.39,0,0,0-.022-.088.927.927,0,0,0,.313-.2L9.245,23.27ZM4.969,27.423a1.564,1.564,0,1,1,1.6-1.564A1.58,1.58,0,0,1,4.969,27.423Z",
          transform: "translate(-1.22 -12.096)"
        }, null, 8, _hoisted_4$n)
      ])
    ]),
    _: 1
  }, 16);
}
var EditIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1e, [["render", _sfc_render$1e]]);
var LogicJumpCondition_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$1d = {
  name: "LogicJumpCondition",
  components: { Input, SelectBox, RadioButton, EditIcon, TrashIcon },
  props: {
    first: { type: Boolean, default: false },
    question: { type: Object, default: () => ({}) },
    questionNumber: { type: Number, default: 1 },
    logicOp: { type: String, default: void 0 },
    op: { type: String, default: void 0 },
    compareWith: { type: Object, default: () => ({}) },
    conditionIndex: { type: Number, default: 0 },
    logicIndex: { type: Number, default: 0 }
  },
  emits: ["update:op", "update:logicOp", "update:compareWith", "delete"],
  data: function() {
    return {
      editOp: false
    };
  },
  computed: {
    compareOptions: function() {
      return [
        { title: "equal to", value: "==" },
        { title: "NOT equal to", value: "!=" },
        ...[QUESTION_TYPE_MULTIPLE_CHOICE, QUESTION_TYPE_YES_NO].indexOf(this.question.type) === -1 ? [
          { title: "lower than", value: "<" },
          { title: "greater than", value: ">" },
          { title: "lower or equal to", value: "<=" },
          { title: "greater or equal to", value: ">=" }
        ] : []
      ];
    },
    answerOptionsForSelectBox: function() {
      var _a, _b;
      return (_b = (_a = this.question.properties) == null ? void 0 : _a.choices) == null ? void 0 : _b.map((c2) => ({ value: c2.id, title: c2.label }));
    }
  },
  methods: {
    handleSetCompareOperator: function(op) {
      this.$emit("update:op", op);
      this.editOp = false;
    },
    handleUpdateCompareWith: function(compareWith) {
      this.$emit("update:compareWith", compareWith);
    }
  }
};
const _hoisted_1$18 = { class: "py-2" };
const _hoisted_2$G = {
  key: 0,
  class: "pb-2 flex gap-3 items-center"
};
const _hoisted_3$y = { class: "text-xs text-gray-500 py-1" };
const _hoisted_4$m = { class: "flex pt-1 gap-2" };
const _hoisted_5$m = {
  key: 0,
  class: "flex gap-2"
};
const _hoisted_6$h = { class: "flex pt-2 gap-2 items-center justify-between" };
const _hoisted_7$e = { class: "text-xxs text-gray-500" };
const _hoisted_8$b = { class: "inline-input" };
function _sfc_render$1d(_ctx, _cache, $props, $setup, $data, $options) {
  var _a;
  const _component_RadioButton = resolveComponent("RadioButton");
  const _component_TrashIcon = resolveComponent("TrashIcon");
  const _component_EditIcon = resolveComponent("EditIcon");
  const _component_Input = resolveComponent("Input");
  const _component_SelectBox = resolveComponent("SelectBox");
  return openBlock(), createElementBlock("div", _hoisted_1$18, [
    !$props.first ? (openBlock(), createElementBlock("div", _hoisted_2$G, [
      createElementVNode("div", null, [
        createVNode(_component_RadioButton, {
          name: `${_ctx.name}-logic-op-${$props.questionNumber}-${$props.logicIndex}-${$props.conditionIndex}`,
          label: "AND",
          "model-value": $props.logicOp === "AND",
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:logicOp", "AND"))
        }, null, 8, ["name", "model-value"]),
        createVNode(_component_RadioButton, {
          name: `${_ctx.name}-logic-op-${$props.questionNumber}-${$props.logicIndex}-${$props.conditionIndex}`,
          label: "OR",
          "model-value": $props.logicOp === "OR",
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:logicOp", "OR"))
        }, null, 8, ["name", "model-value"])
      ]),
      createElementVNode("div", null, [
        createVNode(_component_TrashIcon, {
          width: "12",
          class: "cursor-pointer",
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("delete"))
        })
      ])
    ])) : createCommentVNode("", true),
    createElementVNode("div", _hoisted_3$y, toDisplayString($props.first ? `If answer to question [Q${$props.questionNumber}] is` : "Answer option") + ": ", 1),
    createElementVNode("div", _hoisted_4$m, [
      createElementVNode("div", null, [
        _ctx.editOp || !$props.op ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList($options.compareOptions, (compareOption, i2) => {
          return openBlock(), createBlock(_component_RadioButton, {
            key: `compareOption-${$props.questionNumber}-${$props.logicIndex}-${i2}`,
            name: `compareOption-${$props.questionNumber}-${$props.logicIndex}-${$props.logicIndex}-${$props.conditionIndex}`,
            label: compareOption.title,
            "model-value": compareOption.value === $props.op,
            "onUpdate:modelValue": ($event) => $options.handleSetCompareOperator(compareOption.value)
          }, null, 8, ["name", "label", "model-value", "onUpdate:modelValue"]);
        }), 128)) : createCommentVNode("", true),
        !_ctx.editOp && $props.op ? (openBlock(), createBlock(_component_RadioButton, {
          key: 1,
          name: `compareOption-${$props.questionNumber}-${$props.logicIndex}-${$props.logicIndex}-${$props.conditionIndex}`,
          label: (_a = $options.compareOptions.find((o2) => o2.value === $props.op)) == null ? void 0 : _a.title,
          "model-value": true
        }, null, 8, ["name", "label"])) : createCommentVNode("", true)
      ]),
      $props.op ? (openBlock(), createElementBlock("div", _hoisted_5$m, [
        createVNode(_component_EditIcon, {
          width: "12",
          class: "cursor-pointer",
          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.editOp = !_ctx.editOp)
        }),
        $props.first ? (openBlock(), createBlock(_component_TrashIcon, {
          key: 0,
          width: "12",
          class: "cursor-pointer",
          onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("delete"))
        })) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ]),
    createElementVNode("div", _hoisted_6$h, [
      createElementVNode("div", _hoisted_7$e, toDisplayString($options.answerOptionsForSelectBox ? "Answer option" : "Value") + ": ", 1),
      createElementVNode("div", _hoisted_8$b, [
        !$options.answerOptionsForSelectBox ? (openBlock(), createBlock(_component_Input, {
          key: 0,
          "model-value": $props.compareWith.val,
          class: "border p-1",
          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $options.handleUpdateCompareWith({ val: $event }))
        }, null, 8, ["model-value"])) : createCommentVNode("", true),
        $options.answerOptionsForSelectBox ? (openBlock(), createBlock(_component_SelectBox, {
          key: 1,
          "model-value": $props.compareWith.id,
          placeholder: "Select answer option",
          items: $options.answerOptionsForSelectBox,
          classes: "h-9",
          "font-size": 10,
          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $options.handleUpdateCompareWith({ id: $event }))
        }, null, 8, ["model-value", "items"])) : createCommentVNode("", true)
      ])
    ])
  ]);
}
var LogicJumpCondition = /* @__PURE__ */ _export_sfc$1(_sfc_main$1d, [["render", _sfc_render$1d], ["__scopeId", "data-v-059b70a5"]]);
const TYPE_LOGIC_JUMP = "question";
const TYPE_FORM_TRANSFER = "form";
var logicJump = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TYPE_LOGIC_JUMP,
  TYPE_FORM_TRANSFER
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$1c = {
  name: "LogicJump",
  components: { LogicJumpCondition, SelectBox, JumpIcon, StopIcon },
  props: {
    questions: { type: Array, default: () => [] },
    question: { type: Object, default: null },
    logic: { type: Array, default: () => [] },
    forms: { type: Array, default: () => [] },
    questionCategory: { type: String, default: "" },
    formCategory: { type: String, default: "" }
  },
  emits: ["update:questionCategory", "update:question", "click:addMedia", "click:emoji", "update:currentQuestion", "update:logic"],
  data: () => ({
    QUESTION_CATEGORY_TYP
  }),
  computed: {
    questionSelectBoxItems: function() {
      return this.questions.map((q) => ({
        value: q.id,
        title: `${q.category === QUESTION_CATEGORY_TYP ? "TYP" : "Q"}${q.index} - ` + (q.title || "No title"),
        isKickOff: q.category === QUESTION_CATEGORY_KICK_OFF,
        isTYP: q.category === QUESTION_CATEGORY_TYP
      }));
    },
    questionLogics: function() {
      return this.logic.map((l2, index2) => ({ ...l2, index: index2 })).filter((l2) => l2.question_id === this.question.id && l2.type === TYPE_LOGIC_JUMP);
    },
    questionNumber: function() {
      return this.questions.findIndex((q) => q.id === this.question.id) + 1;
    },
    showAddLogicButton: function() {
      var _a;
      return !!((_a = this.questionLogics[this.questionLogics.length - 1]) == null ? void 0 : _a.goto);
    }
  },
  mounted: function() {
    if (this.questionLogics.length === 0) {
      this.addLogicJump();
    }
  },
  updated: function() {
    if (this.questionLogics.length === 0) {
      this.addLogicJump();
    }
  },
  unmounted() {
    this.questionLogics.forEach((l2) => {
      var _a;
      if (((_a = l2.conditions) == null ? void 0 : _a.length) === 0 && !l2.otherwise) {
        this.$emit(
          "update:logic",
          this.logic.filter((_2, i2) => i2 !== l2.index)
        );
      }
    });
  },
  methods: {
    hasConditions: function(index2) {
      var _a;
      return (_a = this.logic[index2].conditions) == null ? void 0 : _a.length;
    },
    handleAddOtherwise: function(id, event) {
      this.questionLogics.forEach((l2) => {
        this.$emit(
          "update:logic",
          updateArrayElement(this.logic, l2.index, { otherwise: event })
        );
      });
    },
    handleRemoveOtherwise: function() {
      this.questionLogics.forEach((l2) => {
        this.$emit(
          "update:logic",
          updateArrayElement(this.logic, l2.index, { otherwise: void 0 })
        );
      });
    },
    handleAddCondition: function(index2) {
      this.$emit(
        "update:logic",
        updateArrayElement(
          this.logic,
          index2,
          (l2) => ({
            ...l2,
            conditions: [...l2.conditions || [], {}]
          })
        )
      );
    },
    handleUpdateCondition: function(index2, conditionIndex, updates) {
      this.$emit(
        "update:logic",
        updateArrayElement(
          this.logic,
          index2,
          (l2) => ({
            ...l2,
            conditions: updateArrayElement(l2.conditions, conditionIndex, updates)
          })
        )
      );
    },
    handleChangeGoto: function(index2, goto) {
      console.log(index2, goto);
      this.$emit(
        "update:logic",
        updateArrayElement(this.logic, index2, { goto })
      );
    },
    handleDeleteCondition: function(index2, conditionIndex) {
      this.$emit(
        "update:logic",
        updateArrayElement(
          this.logic,
          index2,
          (l2) => ({
            ...l2,
            conditions: l2.conditions.filter((c2, i2) => i2 !== conditionIndex),
            goto: void 0
          })
        )
      );
    },
    addLogicJump: function() {
      this.$emit("update:logic", [...this.logic, { question_id: this.question.id, type: TYPE_LOGIC_JUMP }]);
    }
  }
};
const _hoisted_1$17 = {
  key: 0,
  class: "px-3 py-4"
};
const _hoisted_2$F = /* @__PURE__ */ createElementVNode("div", { class: "text-gray-600 text-xs py-2" }, " You can't add logic jump for thank you page ", -1);
const _hoisted_3$x = { class: "px-3 py-4" };
const _hoisted_4$l = {
  key: 0,
  class: "py-4"
};
const _hoisted_5$l = /* @__PURE__ */ createElementVNode("div", { class: "text-xs text-gray-500" }, " ALWAYS jump to ", -1);
const _hoisted_6$g = { class: "relative" };
const _hoisted_7$d = ["onClick"];
const _hoisted_8$a = /* @__PURE__ */ createElementVNode("div", { class: "text-xs font-bold text-gray-500" }, " OR ", -1);
const _hoisted_9$7 = { class: "py-2" };
const _hoisted_10$7 = ["onClick"];
const _hoisted_11$7 = /* @__PURE__ */ createElementVNode("span", null, "Add logic", -1);
const _hoisted_12$6 = ["onClick"];
const _hoisted_13$4 = {
  key: 3,
  class: "flex justify-between pt-3"
};
const _hoisted_14$3 = /* @__PURE__ */ createElementVNode("div", { class: "text-xxs leading-3 text-gray-500" }, " Then Jump respondent to question ", -1);
const _hoisted_15$3 = {
  key: 0,
  class: "pt-5 pb-6 px-3"
};
const _hoisted_16$3 = /* @__PURE__ */ createElementVNode("div", { class: "text-xs text-gray-500" }, " In all other instances, ALWAYS jump to: ", -1);
const _hoisted_17$3 = { class: "relative" };
const _hoisted_18$2 = {
  key: 0,
  class: "py-4 px-3 text-right"
};
function _sfc_render$1c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SelectBox = resolveComponent("SelectBox");
  const _component_StopIcon = resolveComponent("StopIcon");
  const _component_JumpIcon = resolveComponent("JumpIcon");
  const _component_LogicJumpCondition = resolveComponent("LogicJumpCondition");
  return openBlock(), createElementBlock(Fragment, null, [
    $props.question.category === _ctx.QUESTION_CATEGORY_TYP ? (openBlock(), createElementBlock("div", _hoisted_1$17, [
      createVNode(_component_SelectBox, {
        label: "From question",
        items: $options.questionSelectBoxItems,
        "model-value": $props.question.id,
        classes: "h-10",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:currentQuestion", { id: $event }))
      }, null, 8, ["items", "model-value"]),
      _hoisted_2$F
    ])) : createCommentVNode("", true),
    $props.question.category !== _ctx.QUESTION_CATEGORY_TYP ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.questionLogics, (l2, i2) => {
        var _a;
        return openBlock(), createElementBlock("div", {
          key: `logic${i2}`,
          class: "border-b last:border-0"
        }, [
          createElementVNode("div", _hoisted_3$x, [
            createVNode(_component_SelectBox, {
              label: "From question",
              items: $options.questionSelectBoxItems,
              "model-value": l2.question_id,
              classes: "h-10",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:currentQuestion", { id: $event }))
            }, null, 8, ["items", "model-value"]),
            !$options.hasConditions(l2.index) ? (openBlock(), createElementBlock("div", _hoisted_4$l, [
              _hoisted_5$l,
              createElementVNode("div", _hoisted_6$g, [
                createVNode(_component_SelectBox, {
                  items: $options.questionSelectBoxItems.filter((q) => q.value !== l2.question_id && !q.isKickOff),
                  placeholder: "Select question",
                  classes: "h-10",
                  "model-value": l2.otherwise,
                  "onUpdate:modelValue": ($event) => $options.handleAddOtherwise(l2.index, $event)
                }, null, 8, ["items", "model-value", "onUpdate:modelValue"]),
                l2.otherwise ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: "absolute inset-y-0 right-7 flex items-center cursor-pointer",
                  onClick: ($event) => $options.handleRemoveOtherwise(l2.index)
                }, [
                  createVNode(_component_StopIcon, { height: "16" })
                ], 8, _hoisted_7$d)) : createCommentVNode("", true)
              ])
            ])) : createCommentVNode("", true),
            !$options.hasConditions(l2.index) ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              _hoisted_8$a,
              createElementVNode("div", _hoisted_9$7, [
                createElementVNode("button", {
                  type: "button",
                  class: "inline-flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 gap-1 font-bold",
                  onClick: ($event) => $options.handleAddCondition(l2.index)
                }, [
                  createVNode(_component_JumpIcon, {
                    "icon-color": "#fff",
                    height: "11",
                    width: "20"
                  }),
                  _hoisted_11$7
                ], 8, _hoisted_10$7)
              ])
            ], 64)) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(l2.conditions, (condition, i3) => {
              return openBlock(), createBlock(_component_LogicJumpCondition, {
                key: `logic-jump-condition-${i3}`,
                first: i3 === 0,
                "logic-op": condition.logic_op,
                op: condition.op,
                "compare-with": condition.compare_with,
                "question-number": $options.questionNumber,
                question: $props.question,
                "condition-index": i3,
                "logic-index": l2.index,
                "onUpdate:op": ($event) => $options.handleUpdateCondition(l2.index, i3, { op: $event }),
                "onUpdate:compareWith": ($event) => $options.handleUpdateCondition(l2.index, i3, { compare_with: $event }),
                "onUpdate:logicOp": ($event) => $options.handleUpdateCondition(l2.index, i3, { logic_op: $event }),
                onDelete: ($event) => $options.handleDeleteCondition(l2.index, i3)
              }, null, 8, ["first", "logic-op", "op", "compare-with", "question-number", "question", "condition-index", "logic-index", "onUpdate:op", "onUpdate:compareWith", "onUpdate:logicOp", "onDelete"]);
            }), 128)),
            l2.conditions && ((_a = l2.conditions[l2.conditions.length - 1]) == null ? void 0 : _a.op) ? (openBlock(), createElementBlock("button", {
              key: 2,
              class: "bg-gray-600 py-1 px-2 text-white text-xxs rounded",
              onClick: ($event) => $options.handleAddCondition(l2.index)
            }, " Add condition? ", 8, _hoisted_12$6)) : createCommentVNode("", true),
            $options.hasConditions(l2.index) ? (openBlock(), createElementBlock("div", _hoisted_13$4, [
              _hoisted_14$3,
              createElementVNode("div", null, [
                createVNode(_component_SelectBox, {
                  style: { "width": "155px" },
                  items: $options.questionSelectBoxItems.filter((q) => q.value !== l2.question_id && !q.isKickOff),
                  placeholder: "Select question",
                  "model-value": l2.goto,
                  "font-size": 10,
                  classes: "h-9",
                  "onUpdate:modelValue": ($event) => $options.handleChangeGoto(l2.index, $event)
                }, null, 8, ["items", "model-value", "onUpdate:modelValue"])
              ])
            ])) : createCommentVNode("", true)
          ]),
          $options.hasConditions(l2.index) ? (openBlock(), createElementBlock("div", _hoisted_15$3, [
            _hoisted_16$3,
            createElementVNode("div", _hoisted_17$3, [
              createVNode(_component_SelectBox, {
                items: $options.questionSelectBoxItems.filter((q) => q.value !== l2.question_id && !q.isKickOff),
                placeholder: "Select question",
                "model-value": l2.otherwise,
                "onUpdate:modelValue": ($event) => $options.handleAddOtherwise(l2.index, $event)
              }, null, 8, ["items", "model-value", "onUpdate:modelValue"]),
              l2.otherwise ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "absolute inset-y-0 right-7 flex items-center cursor-pointer",
                onClick: _cache[2] || (_cache[2] = (...args) => $options.handleRemoveOtherwise && $options.handleRemoveOtherwise(...args))
              }, [
                createVNode(_component_StopIcon, { height: "16" })
              ])) : createCommentVNode("", true)
            ])
          ])) : createCommentVNode("", true)
        ]);
      }), 128)),
      $options.showAddLogicButton ? (openBlock(), createElementBlock("div", _hoisted_18$2, [
        createElementVNode("button", {
          type: "button",
          class: "inline-flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 gap-1 font-bold",
          onClick: _cache[3] || (_cache[3] = (...args) => $options.addLogicJump && $options.addLogicJump(...args))
        }, " Add another logic jump? ")
      ])) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true)
  ], 64);
}
var LogicJump = /* @__PURE__ */ _export_sfc$1(_sfc_main$1c, [["render", _sfc_render$1c]]);
const _sfc_main$1b = {
  name: "FormTransfer",
  components: { LogicJumpCondition, SelectBox },
  props: {
    questions: { type: Array, default: () => [] },
    question: { type: Object, default: null },
    logic: { type: Array, default: () => [] },
    forms: { type: Array, default: () => [] },
    questionCategory: { type: String, default: "" },
    formCategory: { type: String, default: "" }
  },
  emits: ["update:questionCategory", "update:question", "click:addMedia", "click:emoji", "update:currentQuestion", "update:logic"],
  data: () => ({ QUESTION_CATEGORY_TYP }),
  computed: {
    questionSelectBoxItems: function() {
      return this.questions.map((q) => ({
        value: q.id,
        title: `Q${q.index} - ` + (q.title || "No title"),
        isKickOff: q.category === QUESTION_CATEGORY_KICK_OFF
      }));
    },
    formsSelectBoxItems: function() {
      return this.forms.map((f2) => ({ value: f2.id, title: f2.name }));
    },
    questionTransfers: function() {
      return this.logic.map((l2, index2) => ({ ...l2, index: index2 })).filter((l2) => l2.question_id === this.question.id && l2.type === TYPE_FORM_TRANSFER);
    },
    questionNumber: function() {
      return this.questions.findIndex((q) => q.id === this.question.id) + 1;
    }
  },
  methods: {
    addFromTransfer: function() {
      this.$emit("update:logic", [...this.logic, { question_id: this.question.id, type: TYPE_FORM_TRANSFER, conditions: [{}] }]);
    },
    handleAddCondition: function(index2) {
      this.$emit(
        "update:logic",
        updateArrayElement(
          this.logic,
          index2,
          (l2) => ({
            ...l2,
            conditions: [...l2.conditions || [], {}]
          })
        )
      );
    },
    handleUpdateCondition: function(index2, conditionIndex, updates) {
      this.$emit(
        "update:logic",
        updateArrayElement(
          this.logic,
          index2,
          (l2) => ({
            ...l2,
            conditions: updateArrayElement(l2.conditions, conditionIndex, updates)
          })
        )
      );
    },
    handleChangeGoto: function(index2, goto) {
      this.$emit(
        "update:logic",
        updateArrayElement(this.logic, index2, { goto })
      );
    },
    handleDeleteCondition: function(index2, conditionIndex) {
      let newLogicState;
      if (this.logic[index2].conditions.length === 1) {
        newLogicState = [...this.logic.slice(0, index2), ...this.logic.slice(index2 + 1)];
      } else {
        newLogicState = updateArrayElement(
          this.logic,
          index2,
          (l2) => ({
            ...l2,
            conditions: l2.conditions.filter((c2, i2) => i2 !== conditionIndex),
            goto: void 0
          })
        );
      }
      this.$emit("update:logic", newLogicState);
    },
    hasConditions: function(index2) {
      var _a;
      return (_a = this.logic[index2].conditions) == null ? void 0 : _a.length;
    }
  }
};
const _hoisted_1$16 = {
  key: 0,
  class: "px-3 py-4"
};
const _hoisted_2$E = /* @__PURE__ */ createElementVNode("div", { class: "text-gray-600 text-xs py-2" }, " You can't add form transfer for thank you page ", -1);
const _hoisted_3$w = { class: "px-3 pt-4 pb-2" };
const _hoisted_4$k = { class: "px-3 py-4" };
const _hoisted_5$k = ["onClick"];
const _hoisted_6$f = {
  key: 1,
  class: "flex justify-between pt-3"
};
const _hoisted_7$c = /* @__PURE__ */ createElementVNode("div", { class: "text-xxs leading-3 text-gray-500" }, [
  /* @__PURE__ */ createTextVNode(" Then move respondent"),
  /* @__PURE__ */ createElementVNode("br"),
  /* @__PURE__ */ createTextVNode(" over to form: ")
], -1);
const _hoisted_8$9 = {
  key: 2,
  class: "text-xxs leading-3 text-gray-500 pb-2 pt-5"
};
const _hoisted_9$6 = /* @__PURE__ */ createTextVNode(" In ALL other instances, the respondent will");
const _hoisted_10$6 = /* @__PURE__ */ createElementVNode("br", null, null, -1);
const _hoisted_11$6 = /* @__PURE__ */ createTextVNode(" move to the next question in this form. ");
const _hoisted_12$5 = [
  _hoisted_9$6,
  _hoisted_10$6,
  _hoisted_11$6
];
const _hoisted_13$3 = { class: "text-right px-3 py-3" };
function _sfc_render$1b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SelectBox = resolveComponent("SelectBox");
  const _component_LogicJumpCondition = resolveComponent("LogicJumpCondition");
  return openBlock(), createElementBlock(Fragment, null, [
    $props.question.category === _ctx.QUESTION_CATEGORY_TYP ? (openBlock(), createElementBlock("div", _hoisted_1$16, [
      createVNode(_component_SelectBox, {
        label: "From question",
        items: $options.questionSelectBoxItems,
        "model-value": $props.question.id,
        classes: "h-10",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:currentQuestion", { id: $event }))
      }, null, 8, ["items", "model-value"]),
      _hoisted_2$E
    ])) : createCommentVNode("", true),
    $props.question.category !== _ctx.QUESTION_CATEGORY_TYP ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      createElementVNode("div", _hoisted_3$w, [
        createVNode(_component_SelectBox, {
          label: "Transfer question",
          items: $options.questionSelectBoxItems,
          "model-value": $props.question.id,
          classes: "h-10",
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:currentQuestion", { id: $event }))
        }, null, 8, ["items", "model-value"])
      ]),
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.questionTransfers, (l2, i2) => {
        var _a;
        return openBlock(), createElementBlock("div", {
          key: `questionTransfer${i2}`,
          class: "border-b last:border-0"
        }, [
          createElementVNode("div", _hoisted_4$k, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(l2.conditions, (condition, conditionIndex) => {
              return openBlock(), createBlock(_component_LogicJumpCondition, {
                key: `transfer-from-condition-${conditionIndex}`,
                first: conditionIndex === 0,
                "logic-op": condition.logic_op,
                op: condition.op,
                "compare-with": condition.compare_with,
                "question-number": $options.questionNumber,
                question: $props.question,
                "condition-index": conditionIndex,
                "logic-index": l2.index,
                "onUpdate:op": ($event) => $options.handleUpdateCondition(l2.index, conditionIndex, { op: $event }),
                "onUpdate:compareWith": ($event) => $options.handleUpdateCondition(l2.index, conditionIndex, { compare_with: $event }),
                "onUpdate:logicOp": ($event) => $options.handleUpdateCondition(l2.index, conditionIndex, { logic_op: $event }),
                onDelete: ($event) => $options.handleDeleteCondition(l2.index, conditionIndex)
              }, null, 8, ["first", "logic-op", "op", "compare-with", "question-number", "question", "condition-index", "logic-index", "onUpdate:op", "onUpdate:compareWith", "onUpdate:logicOp", "onDelete"]);
            }), 128)),
            l2.conditions && ((_a = l2.conditions[l2.conditions.length - 1]) == null ? void 0 : _a.op) ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: "bg-gray-600 py-1 px-2 text-white text-xxs rounded",
              onClick: ($event) => $options.handleAddCondition(l2.index)
            }, " Add condition? ", 8, _hoisted_5$k)) : createCommentVNode("", true),
            $options.hasConditions(l2.index) ? (openBlock(), createElementBlock("div", _hoisted_6$f, [
              _hoisted_7$c,
              createElementVNode("div", null, [
                createVNode(_component_SelectBox, {
                  style: { "width": "155px" },
                  items: $options.formsSelectBoxItems,
                  placeholder: "Select form",
                  "model-value": l2.goto,
                  "font-size": 10,
                  classes: "h-9",
                  "onUpdate:modelValue": ($event) => $options.handleChangeGoto(l2.index, $event)
                }, null, 8, ["items", "model-value", "onUpdate:modelValue"])
              ])
            ])) : createCommentVNode("", true),
            $options.hasConditions(l2.index) ? (openBlock(), createElementBlock("div", _hoisted_8$9, _hoisted_12$5)) : createCommentVNode("", true)
          ])
        ]);
      }), 128)),
      createElementVNode("div", _hoisted_13$3, [
        createElementVNode("button", {
          class: "inline-flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded shadow-sm text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 gap-1 font-bold",
          onClick: _cache[2] || (_cache[2] = (...args) => $options.addFromTransfer && $options.addFromTransfer(...args))
        }, toDisplayString($options.questionTransfers.length > 0 ? "Add another form transfer" : "Add form transfer"), 1)
      ])
    ], 64)) : createCommentVNode("", true)
  ], 64);
}
var FormTransfer$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$1b, [["render", _sfc_render$1b]]);
const _sfc_main$1a = {
  name: "Hyperlink",
  components: { Input, Label },
  props: {
    questions: { type: Array, default: () => [] },
    question: { type: Object, default: null },
    logic: { type: Array, default: () => [] },
    forms: { type: Array, default: () => [] },
    questionCategory: { type: String, default: "" },
    formCategory: { type: String, default: "" }
  },
  emits: ["update:questionCategory", "update:question", "click:addMedia", "click:emoji", "update:currentQuestion", "update:logic"]
};
const _hoisted_1$15 = { class: "px-3" };
const _hoisted_2$D = { class: "py-2 text-xs flex justify-between items-center" };
const _hoisted_3$v = /* @__PURE__ */ createTextVNode("URL");
const _hoisted_4$j = { class: "py-2 text-xs flex justify-between items-center" };
const _hoisted_5$j = /* @__PURE__ */ createTextVNode("Text");
const _hoisted_6$e = /* @__PURE__ */ createElementVNode("div", { class: "py-4 text-right" }, [
  /* @__PURE__ */ createElementVNode("button", { class: "text-sm text-white bg-red-600 rounded px-4 py-1" }, " Remove link ")
], -1);
function _sfc_render$1a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Label = resolveComponent("Label");
  const _component_Input = resolveComponent("Input");
  return openBlock(), createElementBlock("div", _hoisted_1$15, [
    createElementVNode("div", _hoisted_2$D, [
      createVNode(_component_Label, { class: "w-1/4" }, {
        default: withCtx(() => [
          _hoisted_3$v
        ]),
        _: 1
      }),
      createVNode(_component_Input, {
        class: "py-1 text-sm w-3/4",
        type: "text",
        placeholder: "Enter the link address"
      })
    ]),
    createElementVNode("div", _hoisted_4$j, [
      createVNode(_component_Label, { class: "w-1/4" }, {
        default: withCtx(() => [
          _hoisted_5$j
        ]),
        _: 1
      }),
      createVNode(_component_Input, {
        class: "py-1 text-sm w-3/4",
        type: "text",
        placeholder: "Enter the link text"
      })
    ]),
    _hoisted_6$e
  ]);
}
var Hyperlink = /* @__PURE__ */ _export_sfc$1(_sfc_main$1a, [["render", _sfc_render$1a]]);
const _sfc_main$19 = {
  name: "RecallInfo",
  components: {
    SelectBox
  },
  props: {
    questions: { type: Array, default: () => [] },
    question: { type: Object, default: null },
    logic: { type: Array, default: () => [] },
    forms: { type: Array, default: () => [] },
    questionCategory: { type: String, default: "" },
    formCategory: { type: String, default: "" }
  },
  emits: ["click:addMedia", "click:emoji", "update:addMark"],
  computed: {
    questionSelectBoxItems: function() {
      return this.questions.slice(0, this.questions.findIndex((q) => q.id === this.question.id)).map((q) => ({
        value: `[Recall info = answer to ${q.category === QUESTION_CATEGORY_KICK_OFF ? "KO" : "FO"}Q-${q.index}]`,
        title: `Q${q.index} - ` + (q.title || "No title")
      }));
    }
  }
};
const _hoisted_1$14 = { class: "px-3 py-4" };
function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SelectBox = resolveComponent("SelectBox");
  return openBlock(), createElementBlock("div", _hoisted_1$14, [
    createVNode(_component_SelectBox, {
      label: "Recall information from answer to question",
      items: $options.questionSelectBoxItems,
      "model-value": $props.question.id,
      classes: "h-10",
      placeholder: "Choose the question",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:addMark", $event))
    }, null, 8, ["items", "model-value"])
  ]);
}
var RecallInfo = /* @__PURE__ */ _export_sfc$1(_sfc_main$19, [["render", _sfc_render$19]]);
const _sfc_main$18 = {
  name: "MergeTags",
  components: {
    Accordion
  },
  props: {
    questions: { type: Array, default: () => [] },
    question: { type: Object, default: null },
    logic: { type: Array, default: () => [] },
    forms: { type: Array, default: () => [] },
    questionCategory: { type: String, default: "" },
    formCategory: { type: String, default: "" }
  },
  emits: ["click:addMedia", "click:emoji", "update:addMark"],
  data: function() {
    return {
      tags: Object.freeze({
        Contact: ["email", "phone"],
        Personal: ["first_name", "last_name"],
        Purchase: ["product_name", "price", "total_price"]
      })
    };
  }
};
const _hoisted_1$13 = { class: "px-3 py-4" };
const _hoisted_2$C = /* @__PURE__ */ createElementVNode("div", { class: "text-xs text-gray-600 pb-2" }, " Which CRM data point do you want to into from using Merge Tag? ", -1);
const _hoisted_3$u = { class: "rounded border" };
const _hoisted_4$i = { class: "border-t mt-2 py-1" };
const _hoisted_5$i = ["onClick"];
function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Accordion = resolveComponent("Accordion");
  return openBlock(), createElementBlock("div", _hoisted_1$13, [
    _hoisted_2$C,
    createElementVNode("div", _hoisted_3$u, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.tags, (fields, title) => {
        return openBlock(), createBlock(_component_Accordion, {
          key: `merge-tags-${title}`,
          class: "p-2 border-b last:border-b-0",
          title
        }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_4$i, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(fields, (f2) => {
                return openBlock(), createElementBlock("button", {
                  key: `merge-tags-${f2}`,
                  class: "block w-full text-left py-1 my-1 rounded px-4 text-sm text-navy hover:bg-blue-900 hover:text-white transition-all duration-300",
                  onClick: ($event) => _ctx.$emit("update:addMark", ` {{ ${f2} }} `)
                }, toDisplayString(f2), 9, _hoisted_5$i);
              }), 128))
            ])
          ]),
          _: 2
        }, 1032, ["title"]);
      }), 128))
    ])
  ]);
}
var MergeTags = /* @__PURE__ */ _export_sfc$1(_sfc_main$18, [["render", _sfc_render$18]]);
const _sfc_main$17 = {
  name: "StoreAnswer",
  components: {
    Input,
    Checkbox,
    SelectBox,
    Label,
    Accordion,
    PlusIcon: render$2,
    StopIcon
  },
  props: {
    questions: { type: Array, default: () => [] },
    question: { type: Object, default: null },
    logic: { type: Array, default: () => [] },
    forms: { type: Array, default: () => [] },
    questionCategory: { type: String, default: "" },
    formCategory: { type: String, default: "" }
  },
  emits: ["update:questionCategory", "update:question", "click:addMedia", "click:emoji", "update:currentQuestion", "update:logic", "update:storeAnswer"],
  data: function() {
    var _a, _b, _c;
    return {
      QUESTION_CATEGORY_TYP,
      ownCrmParam: ((_a = this.question.storeAnswer) == null ? void 0 : _a.param_group) === "ownCrmParams" && this.question.storeAnswer.param,
      crmParamsGroupTitle: {
        contact: "Contact Information",
        personal: "Personal Information",
        timeDelay: "Time Delay",
        ownCrmParams: "Other"
      },
      dataFormat: [
        { value: "text", inputType: "text" },
        { value: "days", inputType: "number" },
        { value: "weeks", inputType: "number" }
      ],
      showParamsSelect: !((_c = (_b = this.question) == null ? void 0 : _b.storeAnswer) == null ? void 0 : _c.param)
    };
  },
  computed: {
    crmParams: function() {
      return {
        contact: ["email", "phone"],
        personal: ["first_name", "last_name"],
        timeDelay: ["pre_review_message", "pre_review_follow_up_message", "purchase_review"]
      };
    },
    questionSelectBoxItems: function() {
      return this.questions.filter((q) => q.category !== QUESTION_CATEGORY_TYP).map((q) => ({
        value: q.id,
        title: `${q.category === QUESTION_CATEGORY_KICK_OFF ? "KO" : "FO"}Q${q.index} - ` + (q.title || "No title")
      }));
    },
    choicesMappedById: function() {
      var _a;
      if (!((_a = this.question.properties) == null ? void 0 : _a.choices) || this.question.properties.choices.length === 0) {
        return {};
      }
      return {
        ...Object.fromEntries(this.question.properties.choices.map((choice) => [choice.id, choice])),
        ...this.question.properties.allow_other_choice ? { other: { label: "other" } } : {}
      };
    },
    dataFormatSelectBoxOptions: function() {
      return this.dataFormat.map((d2) => ({ value: d2.value, title: d2.value }));
    },
    checkedOptions: function() {
      var _a;
      return (((_a = this.question.storeAnswer) == null ? void 0 : _a.choices) || []).map((c2) => c2.id);
    }
  },
  watch: {
    ownCrmParam: function() {
      var _a;
      console.log(this.ownCrmParam);
      if (this.ownCrmParam) {
        this.handleUpdate({ param_group: "ownCrmParams", param: this.ownCrmParam });
      } else if (((_a = this.question.storeAnswer) == null ? void 0 : _a.param_group) === "ownCrmParams") {
        this.remove();
      }
    }
  },
  methods: {
    handleCheck: function(id, checked) {
      var _a;
      this.handleUpdate({
        choices: checked ? [...((_a = this.question.storeAnswer) == null ? void 0 : _a.choices) || [], { id }] : this.question.storeAnswer.choices.filter((c2) => c2.id !== id)
      });
    },
    handleUpdate: function(updates) {
      this.$emit(
        "update:question",
        {
          ...this.question,
          storeAnswer: { ...this.question.storeAnswer || {}, ...updates }
        }
      );
    },
    remove: function() {
      this.$emit(
        "update:question",
        { ...this.question, storeAnswer: {} }
      );
    },
    handleUpdateChoice: function(choiceId, updates) {
      this.handleUpdate({
        choices: this.question.storeAnswer.choices.map((c2) => c2.id === choiceId ? { ...c2, ...updates } : c2)
      });
    },
    toggleShowParamsSelect: function() {
      this.showParamsSelect = !this.showParamsSelect;
    },
    addOwnParam: function() {
      this.ownCrmParam = "";
    }
  }
};
const _hoisted_1$12 = { class: "px-3 py-4" };
const _hoisted_2$B = {
  key: 0,
  class: "text-gray-600 text-xs py-2"
};
const _hoisted_3$t = {
  key: 1,
  class: "py-2"
};
const _hoisted_4$h = /* @__PURE__ */ createElementVNode("div", { class: "text-xs text-gray-500 pb-2" }, " Selected which answer options you want to save ", -1);
const _hoisted_5$h = { class: "flex justify-between" };
const _hoisted_6$d = { class: "w-3/4 truncate" };
const _hoisted_7$b = { class: "px-2" };
const _hoisted_8$8 = { key: 0 };
const _hoisted_9$5 = { class: "flex justify-between" };
const _hoisted_10$5 = /* @__PURE__ */ createElementVNode("span", null, "Other", -1);
const _hoisted_11$5 = { class: "px-2" };
const _hoisted_12$4 = { class: "text-xs text-gray-500 py-2" };
const _hoisted_13$2 = { class: "absolute right-1 top-1 bottom-1 flex items-center" };
const _hoisted_14$2 = { class: "border-t mt-2 py-1" };
const _hoisted_15$2 = ["onClick"];
const _hoisted_16$2 = /* @__PURE__ */ createTextVNode(" Add new parameter ");
const _hoisted_17$2 = {
  key: 1,
  class: "py-2 relative"
};
const _hoisted_18$1 = /* @__PURE__ */ createElementVNode("div", { class: "text-xs text-gray-500 py-2" }, " How should answer options should be saved in CRM? ", -1);
const _hoisted_19$1 = /* @__PURE__ */ createElementVNode("div", { class: "text-xxs text-gray-500 flex" }, [
  /* @__PURE__ */ createElementVNode("div", null, " Selected answers "),
  /* @__PURE__ */ createElementVNode("div", null, " Format "),
  /* @__PURE__ */ createElementVNode("div", null, " Data ")
], -1);
const _hoisted_20 = { class: "pb-12" };
const _hoisted_21 = { class: "w-1/3 truncate text-sm py-1" };
const _hoisted_22 = { class: "w-1/3" };
const _hoisted_23 = { class: "w-1/3 pl-1" };
function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SelectBox = resolveComponent("SelectBox");
  const _component_Checkbox = resolveComponent("Checkbox");
  const _component_Label = resolveComponent("Label");
  const _component_StopIcon = resolveComponent("StopIcon");
  const _component_Accordion = resolveComponent("Accordion");
  const _component_PlusIcon = resolveComponent("PlusIcon");
  const _component_Input = resolveComponent("Input");
  return openBlock(), createElementBlock("div", _hoisted_1$12, [
    createVNode(_component_SelectBox, {
      label: "From question",
      items: $options.questionSelectBoxItems,
      "model-value": $props.question.id,
      classes: "h-10",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:currentQuestion", { id: $event }))
    }, null, 8, ["items", "model-value"]),
    $props.question.category === _ctx.QUESTION_CATEGORY_TYP ? (openBlock(), createElementBlock("div", _hoisted_2$B, " You can't store answer for thank you page ")) : createCommentVNode("", true),
    $props.question.properties.choices ? (openBlock(), createElementBlock("div", _hoisted_3$t, [
      _hoisted_4$h,
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.question.properties.choices, (choice) => {
        return openBlock(), createElementBlock("div", {
          key: `${$props.question.id}-choice=${choice.id}`
        }, [
          createVNode(_component_Label, null, {
            default: withCtx(() => [
              createElementVNode("div", _hoisted_5$h, [
                createElementVNode("span", _hoisted_6$d, toDisplayString(choice.label), 1),
                createElementVNode("div", _hoisted_7$b, [
                  createVNode(_component_Checkbox, {
                    checked: $options.checkedOptions.indexOf(choice.id) !== -1,
                    "onUpdate:checked": ($event) => $options.handleCheck(choice.id, $event)
                  }, null, 8, ["checked", "onUpdate:checked"])
                ])
              ])
            ]),
            _: 2
          }, 1024)
        ]);
      }), 128)),
      $props.question.properties.allow_other_choice ? (openBlock(), createElementBlock("div", _hoisted_8$8, [
        createVNode(_component_Label, null, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_9$5, [
              _hoisted_10$5,
              createElementVNode("div", _hoisted_11$5, [
                createVNode(_component_Checkbox, {
                  "onUpdate:checked": _cache[1] || (_cache[1] = ($event) => $options.handleCheck("other", $event))
                })
              ])
            ])
          ]),
          _: 1
        })
      ])) : createCommentVNode("", true)
    ])) : createCommentVNode("", true),
    createElementVNode("div", _hoisted_12$4, toDisplayString(_ctx.showParamsSelect ? "Select" : "Selected") + " CRM parameter which for saved answer ", 1),
    !_ctx.showParamsSelect ? (openBlock(), createElementBlock("button", {
      key: 2,
      class: "border rounded px-2 py-1 w-full text-left relative pr-6",
      onClick: _cache[2] || (_cache[2] = (...args) => $options.toggleShowParamsSelect && $options.toggleShowParamsSelect(...args))
    }, [
      createElementVNode("strong", null, toDisplayString(_ctx.crmParamsGroupTitle[$props.question.storeAnswer.param_group]), 1),
      createTextVNode(" - " + toDisplayString($props.question.storeAnswer.param) + " ", 1),
      createElementVNode("div", _hoisted_13$2, [
        createVNode(_component_StopIcon, {
          class: "h-8 cursor-pointer",
          onClick: $options.remove
        }, null, 8, ["onClick"])
      ])
    ])) : (openBlock(), createElementBlock(Fragment, { key: 3 }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.crmParams, (params, crmParamGroup) => {
        return openBlock(), createBlock(_component_Accordion, {
          key: `store-answer-crm-param-group-${crmParamGroup}`,
          title: _ctx.crmParamsGroupTitle[crmParamGroup],
          class: "p-2 border-b last:border-b-0 text-xs"
        }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_14$2, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(params, (param) => {
                return openBlock(), createElementBlock("button", {
                  key: `store-answer-crm-param-${param}`,
                  class: "block w-full text-left py-1 my-1 rounded px-4 text-sm text-navy hover:bg-blue-900 hover:text-white transition-all duration-300",
                  onClick: ($event) => {
                    $options.handleUpdate({ param_group: crmParamGroup, param });
                    $options.toggleShowParamsSelect();
                  }
                }, toDisplayString(param), 9, _hoisted_15$2);
              }), 128))
            ])
          ]),
          _: 2
        }, 1032, ["title"]);
      }), 128)),
      typeof _ctx.ownCrmParam !== "string" ? (openBlock(), createElementBlock("button", {
        key: 0,
        class: "text-xxs flex gap-2 mt-2",
        onClick: _cache[3] || (_cache[3] = (...args) => $options.addOwnParam && $options.addOwnParam(...args))
      }, [
        createVNode(_component_PlusIcon, { class: "h-3 text-gray-600" }),
        _hoisted_16$2
      ])) : createCommentVNode("", true),
      typeof _ctx.ownCrmParam === "string" ? (openBlock(), createElementBlock("div", _hoisted_17$2, [
        createVNode(_component_Input, {
          modelValue: _ctx.ownCrmParam,
          "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.ownCrmParam = $event),
          placeholder: "Enter the param name",
          class: "w-full text-sm p-1 pr-6"
        }, null, 8, ["modelValue"]),
        createVNode(_component_StopIcon, {
          class: "h-8 absolute right-1 top-2 cursor-pointer",
          onClick: _cache[5] || (_cache[5] = ($event) => _ctx.ownCrmParam = null)
        })
      ])) : createCommentVNode("", true)
    ], 64)),
    $options.checkedOptions.length > 0 ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [
      _hoisted_18$1,
      createElementVNode("div", null, [
        _hoisted_19$1,
        createElementVNode("div", _hoisted_20, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.question.storeAnswer.choices, (choice) => {
            var _a;
            return openBlock(), createElementBlock("div", {
              key: `store-answer-store-as-${choice.id}`,
              class: "flex border-b last:border-b-0 py-3"
            }, [
              createElementVNode("div", _hoisted_21, toDisplayString($options.choicesMappedById[choice.id].label), 1),
              createElementVNode("div", _hoisted_22, [
                createVNode(_component_SelectBox, {
                  label: "",
                  items: $options.dataFormatSelectBoxOptions,
                  "model-value": choice.format || $options.dataFormatSelectBoxOptions[0].value,
                  "onUpdate:modelValue": ($event) => $options.handleUpdateChoice(choice.id, { format: $event })
                }, null, 8, ["items", "model-value", "onUpdate:modelValue"])
              ]),
              createElementVNode("div", _hoisted_23, [
                createVNode(_component_Input, {
                  type: ((_a = _ctx.dataFormat.find((o2) => o2.value === choice.format)) == null ? void 0 : _a.inputType) || "text",
                  class: "w-full text-sm p-1",
                  "model-value": choice.value || $options.choicesMappedById[choice.id].label,
                  "onUpdate:modelValue": ($event) => $options.handleUpdateChoice(choice.id, { value: $event })
                }, null, 8, ["type", "model-value", "onUpdate:modelValue"])
              ])
            ]);
          }), 128))
        ])
      ])
    ], 64)) : createCommentVNode("", true)
  ]);
}
var StoreAnswer = /* @__PURE__ */ _export_sfc$1(_sfc_main$17, [["render", _sfc_render$17]]);
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject$2(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function isPlainObject$1(o2) {
  var ctor, prot;
  if (isObject$2(o2) === false)
    return false;
  ctor = o2.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject$2(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function t$1() {
  return t$1 = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = arguments[t2];
      for (var n2 in r2)
        Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
    }
    return e2;
  }, t$1.apply(this, arguments);
}
function r$1(e2, t2) {
  if (null == e2)
    return {};
  var r2, n2, i2 = {}, o2 = Object.keys(e2);
  for (n2 = 0; n2 < o2.length; n2++)
    t2.indexOf(r2 = o2[n2]) >= 0 || (i2[r2] = e2[r2]);
  return i2;
}
const n$1 = { silent: false, logLevel: "warn" }, i$1 = ["validator"], o$1 = Object.prototype, a$1 = o$1.toString, s$1 = o$1.hasOwnProperty, u$1 = /^\s*function (\w+)/;
function l$1(e2) {
  var t2;
  const r2 = null !== (t2 = null == e2 ? void 0 : e2.type) && void 0 !== t2 ? t2 : e2;
  if (r2) {
    const e3 = r2.toString().match(u$1);
    return e3 ? e3[1] : "";
  }
  return "";
}
const c$1 = isPlainObject$1, f$1 = (e2) => e2;
let d$1 = f$1;
const p$1 = (e2, t2) => s$1.call(e2, t2), y$1 = Number.isInteger || function(e2) {
  return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
}, v$1 = Array.isArray || function(e2) {
  return "[object Array]" === a$1.call(e2);
}, h$1 = (e2) => "[object Function]" === a$1.call(e2), b$1 = (e2) => c$1(e2) && p$1(e2, "_vueTypes_name"), g$1 = (e2) => c$1(e2) && (p$1(e2, "type") || ["_vueTypes_name", "validator", "default", "required"].some((t2) => p$1(e2, t2)));
function O$1(e2, t2) {
  return Object.defineProperty(e2.bind(t2), "__original", { value: e2 });
}
function m$1(e2, t2, r2 = false) {
  let n2, i2 = true, o2 = "";
  n2 = c$1(e2) ? e2 : { type: e2 };
  const a2 = b$1(n2) ? n2._vueTypes_name + " - " : "";
  if (g$1(n2) && null !== n2.type) {
    if (void 0 === n2.type || true === n2.type)
      return i2;
    if (!n2.required && void 0 === t2)
      return i2;
    v$1(n2.type) ? (i2 = n2.type.some((e3) => true === m$1(e3, t2, true)), o2 = n2.type.map((e3) => l$1(e3)).join(" or ")) : (o2 = l$1(n2), i2 = "Array" === o2 ? v$1(t2) : "Object" === o2 ? c$1(t2) : "String" === o2 || "Number" === o2 || "Boolean" === o2 || "Function" === o2 ? function(e3) {
      if (null == e3)
        return "";
      const t3 = e3.constructor.toString().match(u$1);
      return t3 ? t3[1] : "";
    }(t2) === o2 : t2 instanceof n2.type);
  }
  if (!i2) {
    const e3 = `${a2}value "${t2}" should be of type "${o2}"`;
    return false === r2 ? (d$1(e3), false) : e3;
  }
  if (p$1(n2, "validator") && h$1(n2.validator)) {
    const e3 = d$1, o3 = [];
    if (d$1 = (e4) => {
      o3.push(e4);
    }, i2 = n2.validator(t2), d$1 = e3, !i2) {
      const e4 = (o3.length > 1 ? "* " : "") + o3.join("\n* ");
      return o3.length = 0, false === r2 ? (d$1(e4), i2) : e4;
    }
  }
  return i2;
}
function j$1(e2, t2) {
  const r2 = Object.defineProperties(t2, { _vueTypes_name: { value: e2, writable: true }, isRequired: { get() {
    return this.required = true, this;
  } }, def: { value(e3) {
    return void 0 === e3 ? (p$1(this, "default") && delete this.default, this) : h$1(e3) || true === m$1(this, e3, true) ? (this.default = v$1(e3) ? () => [...e3] : c$1(e3) ? () => Object.assign({}, e3) : e3, this) : (d$1(`${this._vueTypes_name} - invalid default value: "${e3}"`), this);
  } } }), { validator: n2 } = r2;
  return h$1(n2) && (r2.validator = O$1(n2, r2)), r2;
}
function _$2(e2, t2) {
  const r2 = j$1(e2, t2);
  return Object.defineProperty(r2, "validate", { value(e3) {
    return h$1(this.validator) && d$1(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:
${JSON.stringify(this)}`), this.validator = O$1(e3, this), this;
  } });
}
function T$1(e2, t2, n2) {
  const o2 = function(e3) {
    const t3 = {};
    return Object.getOwnPropertyNames(e3).forEach((r2) => {
      t3[r2] = Object.getOwnPropertyDescriptor(e3, r2);
    }), Object.defineProperties({}, t3);
  }(t2);
  if (o2._vueTypes_name = e2, !c$1(n2))
    return o2;
  const { validator: a2 } = n2, s2 = r$1(n2, i$1);
  if (h$1(a2)) {
    let { validator: e3 } = o2;
    e3 && (e3 = null !== (l2 = (u2 = e3).__original) && void 0 !== l2 ? l2 : u2), o2.validator = O$1(e3 ? function(t3) {
      return e3.call(this, t3) && a2.call(this, t3);
    } : a2, o2);
  }
  var u2, l2;
  return Object.assign(o2, s2);
}
function $$1(e2) {
  return e2.replace(/^(?!\s*$)/gm, "  ");
}
const w$1 = () => _$2("any", {}), P$1 = () => _$2("function", { type: Function }), x$1 = () => _$2("boolean", { type: Boolean }), E$1 = () => _$2("string", { type: String }), N$1 = () => _$2("number", { type: Number }), q$1 = () => _$2("array", { type: Array }), A$1 = () => _$2("object", { type: Object }), V$1 = () => j$1("integer", { type: Number, validator: (e2) => y$1(e2) }), S$1 = () => j$1("symbol", { validator: (e2) => "symbol" == typeof e2 });
function D$1(e2, t2 = "custom validation failed") {
  if ("function" != typeof e2)
    throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return j$1(e2.name || "<<anonymous function>>", { type: null, validator(r2) {
    const n2 = e2(r2);
    return n2 || d$1(`${this._vueTypes_name} - ${t2}`), n2;
  } });
}
function L$1(e2) {
  if (!v$1(e2))
    throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  const t2 = `oneOf - value should be one of "${e2.join('", "')}".`, r2 = e2.reduce((e3, t3) => {
    if (null != t3) {
      const r3 = t3.constructor;
      -1 === e3.indexOf(r3) && e3.push(r3);
    }
    return e3;
  }, []);
  return j$1("oneOf", { type: r2.length > 0 ? r2 : void 0, validator(r3) {
    const n2 = -1 !== e2.indexOf(r3);
    return n2 || d$1(t2), n2;
  } });
}
function F$1(e2) {
  if (!v$1(e2))
    throw new TypeError("[VueTypes error]: You must provide an array as argument");
  let t2 = false, r2 = [];
  for (let n3 = 0; n3 < e2.length; n3 += 1) {
    const i2 = e2[n3];
    if (g$1(i2)) {
      if (b$1(i2) && "oneOf" === i2._vueTypes_name && i2.type) {
        r2 = r2.concat(i2.type);
        continue;
      }
      if (h$1(i2.validator) && (t2 = true), true === i2.type || !i2.type) {
        d$1('oneOfType - invalid usage of "true" or "null" as types.');
        continue;
      }
      r2 = r2.concat(i2.type);
    } else
      r2.push(i2);
  }
  r2 = r2.filter((e3, t3) => r2.indexOf(e3) === t3);
  const n2 = r2.length > 0 ? r2 : null;
  return j$1("oneOfType", t2 ? { type: n2, validator(t3) {
    const r3 = [], n3 = e2.some((e3) => {
      const n4 = m$1(b$1(e3) && "oneOf" === e3._vueTypes_name ? e3.type || null : e3, t3, true);
      return "string" == typeof n4 && r3.push(n4), true === n4;
    });
    return n3 || d$1(`oneOfType - provided value does not match any of the ${r3.length} passed-in validators:
${$$1(r3.join("\n"))}`), n3;
  } } : { type: n2 });
}
function Y$1(e2) {
  return j$1("arrayOf", { type: Array, validator(t2) {
    let r2 = "";
    const n2 = t2.every((t3) => (r2 = m$1(e2, t3, true), true === r2));
    return n2 || d$1(`arrayOf - value validation error:
${$$1(r2)}`), n2;
  } });
}
function B$1(e2) {
  return j$1("instanceOf", { type: e2 });
}
function I$1(e2) {
  return j$1("objectOf", { type: Object, validator(t2) {
    let r2 = "";
    const n2 = Object.keys(t2).every((n3) => (r2 = m$1(e2, t2[n3], true), true === r2));
    return n2 || d$1(`objectOf - value validation error:
${$$1(r2)}`), n2;
  } });
}
function J$1(e2) {
  const t2 = Object.keys(e2), r2 = t2.filter((t3) => {
    var r3;
    return !(null === (r3 = e2[t3]) || void 0 === r3 || !r3.required);
  }), n2 = j$1("shape", { type: Object, validator(n3) {
    if (!c$1(n3))
      return false;
    const i2 = Object.keys(n3);
    if (r2.length > 0 && r2.some((e3) => -1 === i2.indexOf(e3))) {
      const e3 = r2.filter((e4) => -1 === i2.indexOf(e4));
      return d$1(1 === e3.length ? `shape - required property "${e3[0]}" is not defined.` : `shape - required properties "${e3.join('", "')}" are not defined.`), false;
    }
    return i2.every((r3) => {
      if (-1 === t2.indexOf(r3))
        return true === this._vueTypes_isLoose || (d$1(`shape - shape definition does not include a "${r3}" property. Allowed keys: "${t2.join('", "')}".`), false);
      const i3 = m$1(e2[r3], n3[r3], true);
      return "string" == typeof i3 && d$1(`shape - "${r3}" property validation error:
 ${$$1(i3)}`), true === i3;
    });
  } });
  return Object.defineProperty(n2, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(n2, "loose", { get() {
    return this._vueTypes_isLoose = true, this;
  } }), n2;
}
const M$1 = ["name", "validate", "getter"], R$1 = /* @__PURE__ */ (() => {
  var e2;
  return (e2 = class {
    static get any() {
      return w$1();
    }
    static get func() {
      return P$1().def(this.defaults.func);
    }
    static get bool() {
      return x$1().def(this.defaults.bool);
    }
    static get string() {
      return E$1().def(this.defaults.string);
    }
    static get number() {
      return N$1().def(this.defaults.number);
    }
    static get array() {
      return q$1().def(this.defaults.array);
    }
    static get object() {
      return A$1().def(this.defaults.object);
    }
    static get integer() {
      return V$1().def(this.defaults.integer);
    }
    static get symbol() {
      return S$1();
    }
    static get nullable() {
      return { type: null };
    }
    static extend(e3) {
      if (v$1(e3))
        return e3.forEach((e4) => this.extend(e4)), this;
      const { name: t2, validate: n2 = false, getter: i2 = false } = e3, o2 = r$1(e3, M$1);
      if (p$1(this, t2))
        throw new TypeError(`[VueTypes error]: Type "${t2}" already defined`);
      const { type: a2 } = o2;
      if (b$1(a2))
        return delete o2.type, Object.defineProperty(this, t2, i2 ? { get: () => T$1(t2, a2, o2) } : { value(...e4) {
          const r2 = T$1(t2, a2, o2);
          return r2.validator && (r2.validator = r2.validator.bind(r2, ...e4)), r2;
        } });
      let s2;
      return s2 = i2 ? { get() {
        const e4 = Object.assign({}, o2);
        return n2 ? _$2(t2, e4) : j$1(t2, e4);
      }, enumerable: true } : { value(...e4) {
        const r2 = Object.assign({}, o2);
        let i3;
        return i3 = n2 ? _$2(t2, r2) : j$1(t2, r2), r2.validator && (i3.validator = r2.validator.bind(i3, ...e4)), i3;
      }, enumerable: true }, Object.defineProperty(this, t2, s2);
    }
  }).defaults = {}, e2.sensibleDefaults = void 0, e2.config = n$1, e2.custom = D$1, e2.oneOf = L$1, e2.instanceOf = B$1, e2.oneOfType = F$1, e2.arrayOf = Y$1, e2.objectOf = I$1, e2.shape = J$1, e2.utils = { validate: (e3, t2) => true === m$1(t2, e3, true), toType: (e3, t2, r2 = false) => r2 ? _$2(e3, t2) : j$1(e3, t2) }, e2;
})();
function z$1(e2 = { func: () => {
}, bool: true, string: "", number: 0, array: () => [], object: () => ({}), integer: 0 }) {
  var r2;
  return (r2 = class extends R$1 {
    static get sensibleDefaults() {
      return t$1({}, this.defaults);
    }
    static set sensibleDefaults(r3) {
      this.defaults = false !== r3 ? t$1({}, true !== r3 ? r3 : e2) : {};
    }
  }).defaults = t$1({}, e2), r2;
}
class C$1 extends z$1() {
}
var tinycolor$1 = { exports: {} };
(function(module2) {
  (function(Math2) {
    var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
    function tinycolor2(color, opts) {
      color = color ? color : "";
      opts = opts || {};
      if (color instanceof tinycolor2) {
        return color;
      }
      if (!(this instanceof tinycolor2)) {
        return new tinycolor2(color, opts);
      }
      var rgb = inputToRGB(color);
      this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
      this._gradientType = opts.gradientType;
      if (this._r < 1) {
        this._r = mathRound(this._r);
      }
      if (this._g < 1) {
        this._g = mathRound(this._g);
      }
      if (this._b < 1) {
        this._b = mathRound(this._b);
      }
      this._ok = rgb.ok;
      this._tc_id = tinyCounter++;
    }
    tinycolor2.prototype = {
      isDark: function() {
        return this.getBrightness() < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      isValid: function() {
        return this._ok;
      },
      getOriginalInput: function() {
        return this._originalInput;
      },
      getFormat: function() {
        return this._format;
      },
      getAlpha: function() {
        return this._a;
      },
      getBrightness: function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      },
      getLuminance: function() {
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R2, G2, B2;
        RsRGB = rgb.r / 255;
        GsRGB = rgb.g / 255;
        BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) {
          R2 = RsRGB / 12.92;
        } else {
          R2 = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G2 = GsRGB / 12.92;
        } else {
          G2 = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B2 = BsRGB / 12.92;
        } else {
          B2 = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
      },
      setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100 * this._a) / 100;
        return this;
      },
      toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
      },
      toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h2 = mathRound(hsv.h * 360), s2 = mathRound(hsv.s * 100), v2 = mathRound(hsv.v * 100);
        return this._a == 1 ? "hsv(" + h2 + ", " + s2 + "%, " + v2 + "%)" : "hsva(" + h2 + ", " + s2 + "%, " + v2 + "%, " + this._roundA + ")";
      },
      toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
      },
      toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h2 = mathRound(hsl.h * 360), s2 = mathRound(hsl.s * 100), l2 = mathRound(hsl.l * 100);
        return this._a == 1 ? "hsl(" + h2 + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
      },
      toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
      },
      toHexString: function(allow3Char) {
        return "#" + this.toHex(allow3Char);
      },
      toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
      },
      toHex8String: function(allow4Char) {
        return "#" + this.toHex8(allow4Char);
      },
      toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
      },
      toRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
      },
      toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
      },
      toPercentageRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
      },
      toName: function() {
        if (this._a === 0) {
          return "transparent";
        }
        if (this._a < 1) {
          return false;
        }
        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
      },
      toFilter: function(secondColor) {
        var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";
        if (secondColor) {
          var s2 = tinycolor2(secondColor);
          secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
        }
        return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
      },
      toString: function(format2) {
        var formatSet = !!format2;
        format2 = format2 || this._format;
        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
        if (needsAlphaFormat) {
          if (format2 === "name" && this._a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format2 === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format2 === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format2 === "hex" || format2 === "hex6") {
          formattedString = this.toHexString();
        }
        if (format2 === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format2 === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format2 === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format2 === "name") {
          formattedString = this.toName();
        }
        if (format2 === "hsl") {
          formattedString = this.toHslString();
        }
        if (format2 === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      },
      clone: function() {
        return tinycolor2(this.toString());
      },
      _applyModification: function(fn3, args) {
        var color = fn3.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
      },
      lighten: function() {
        return this._applyModification(lighten, arguments);
      },
      brighten: function() {
        return this._applyModification(brighten, arguments);
      },
      darken: function() {
        return this._applyModification(darken, arguments);
      },
      desaturate: function() {
        return this._applyModification(desaturate, arguments);
      },
      saturate: function() {
        return this._applyModification(saturate, arguments);
      },
      greyscale: function() {
        return this._applyModification(greyscale, arguments);
      },
      spin: function() {
        return this._applyModification(spin, arguments);
      },
      _applyCombination: function(fn3, args) {
        return fn3.apply(null, [this].concat([].slice.call(args)));
      },
      analogous: function() {
        return this._applyCombination(analogous, arguments);
      },
      complement: function() {
        return this._applyCombination(complement, arguments);
      },
      monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
      },
      splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
      },
      triad: function() {
        return this._applyCombination(triad, arguments);
      },
      tetrad: function() {
        return this._applyCombination(tetrad, arguments);
      }
    };
    tinycolor2.fromRatio = function(color, opts) {
      if (typeof color == "object") {
        var newColor = {};
        for (var i2 in color) {
          if (color.hasOwnProperty(i2)) {
            if (i2 === "a") {
              newColor[i2] = color[i2];
            } else {
              newColor[i2] = convertToPercentage(color[i2]);
            }
          }
        }
        color = newColor;
      }
      return tinycolor2(color, opts);
    };
    function inputToRGB(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a2 = 1;
      var s2 = null;
      var v2 = null;
      var l2 = null;
      var ok = false;
      var format2 = false;
      if (typeof color == "string") {
        color = stringInputToObject(color);
      }
      if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s2 = convertToPercentage(color.s);
          v2 = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s2, v2);
          ok = true;
          format2 = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s2 = convertToPercentage(color.s);
          l2 = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s2, l2);
          ok = true;
          format2 = "hsl";
        }
        if (color.hasOwnProperty("a")) {
          a2 = color.a;
        }
      }
      a2 = boundAlpha(a2);
      return {
        ok,
        format: color.format || format2,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a2
      };
    }
    function rgbToRgb(r2, g2, b2) {
      return {
        r: bound01(r2, 255) * 255,
        g: bound01(g2, 255) * 255,
        b: bound01(b2, 255) * 255
      };
    }
    function rgbToHsl(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = mathMax(r2, g2, b2), min2 = mathMin(r2, g2, b2);
      var h2, s2, l2 = (max2 + min2) / 2;
      if (max2 == min2) {
        h2 = s2 = 0;
      } else {
        var d2 = max2 - min2;
        s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, l: l2 };
    }
    function hslToRgb(h2, s2, l2) {
      var r2, g2, b2;
      h2 = bound01(h2, 360);
      s2 = bound01(s2, 100);
      l2 = bound01(l2, 100);
      function hue2rgb(p3, q2, t2) {
        if (t2 < 0)
          t2 += 1;
        if (t2 > 1)
          t2 -= 1;
        if (t2 < 1 / 6)
          return p3 + (q2 - p3) * 6 * t2;
        if (t2 < 1 / 2)
          return q2;
        if (t2 < 2 / 3)
          return p3 + (q2 - p3) * (2 / 3 - t2) * 6;
        return p3;
      }
      if (s2 === 0) {
        r2 = g2 = b2 = l2;
      } else {
        var q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        var p2 = 2 * l2 - q;
        r2 = hue2rgb(p2, q, h2 + 1 / 3);
        g2 = hue2rgb(p2, q, h2);
        b2 = hue2rgb(p2, q, h2 - 1 / 3);
      }
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHsv(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = mathMax(r2, g2, b2), min2 = mathMin(r2, g2, b2);
      var h2, s2, v2 = max2;
      var d2 = max2 - min2;
      s2 = max2 === 0 ? 0 : d2 / max2;
      if (max2 == min2) {
        h2 = 0;
      } else {
        switch (max2) {
          case r2:
            h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h2 = (b2 - r2) / d2 + 2;
            break;
          case b2:
            h2 = (r2 - g2) / d2 + 4;
            break;
        }
        h2 /= 6;
      }
      return { h: h2, s: s2, v: v2 };
    }
    function hsvToRgb(h2, s2, v2) {
      h2 = bound01(h2, 360) * 6;
      s2 = bound01(s2, 100);
      v2 = bound01(v2, 100);
      var i2 = Math2.floor(h2), f2 = h2 - i2, p2 = v2 * (1 - s2), q = v2 * (1 - f2 * s2), t2 = v2 * (1 - (1 - f2) * s2), mod2 = i2 % 6, r2 = [v2, q, p2, p2, t2, v2][mod2], g2 = [t2, v2, v2, q, p2, p2][mod2], b2 = [p2, p2, t2, v2, v2, q][mod2];
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHex(r2, g2, b2, allow3Char) {
      var hex = [
        pad2(mathRound(r2).toString(16)),
        pad2(mathRound(g2).toString(16)),
        pad2(mathRound(b2).toString(16))
      ];
      if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r2, g2, b2, a2, allow4Char) {
      var hex = [
        pad2(mathRound(r2).toString(16)),
        pad2(mathRound(g2).toString(16)),
        pad2(mathRound(b2).toString(16)),
        pad2(convertDecimalToHex(a2))
      ];
      if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToArgbHex(r2, g2, b2, a2) {
      var hex = [
        pad2(convertDecimalToHex(a2)),
        pad2(mathRound(r2).toString(16)),
        pad2(mathRound(g2).toString(16)),
        pad2(mathRound(b2).toString(16))
      ];
      return hex.join("");
    }
    tinycolor2.equals = function(color1, color2) {
      if (!color1 || !color2) {
        return false;
      }
      return tinycolor2(color1).toRgbString() == tinycolor2(color2).toRgbString();
    };
    tinycolor2.random = function() {
      return tinycolor2.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
      });
    };
    function desaturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor2(hsl);
    }
    function saturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor2(hsl);
    }
    function greyscale(color) {
      return tinycolor2(color).desaturate(100);
    }
    function lighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor2(hsl);
    }
    function brighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var rgb = tinycolor2(color).toRgb();
      rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
      rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
      rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
      return tinycolor2(rgb);
    }
    function darken(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor2(hsl);
    }
    function spin(color, amount) {
      var hsl = tinycolor2(color).toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return tinycolor2(hsl);
    }
    function complement(color) {
      var hsl = tinycolor2(color).toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return tinycolor2(hsl);
    }
    function triad(color) {
      var hsl = tinycolor2(color).toHsl();
      var h2 = hsl.h;
      return [
        tinycolor2(color),
        tinycolor2({ h: (h2 + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h2 + 240) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function tetrad(color) {
      var hsl = tinycolor2(color).toHsl();
      var h2 = hsl.h;
      return [
        tinycolor2(color),
        tinycolor2({ h: (h2 + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h2 + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h2 + 270) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function splitcomplement(color) {
      var hsl = tinycolor2(color).toHsl();
      var h2 = hsl.h;
      return [
        tinycolor2(color),
        tinycolor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function analogous(color, results, slices) {
      results = results || 6;
      slices = slices || 30;
      var hsl = tinycolor2(color).toHsl();
      var part = 360 / slices;
      var ret = [tinycolor2(color)];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor2(hsl));
      }
      return ret;
    }
    function monochromatic(color, results) {
      results = results || 6;
      var hsv = tinycolor2(color).toHsv();
      var h2 = hsv.h, s2 = hsv.s, v2 = hsv.v;
      var ret = [];
      var modification = 1 / results;
      while (results--) {
        ret.push(tinycolor2({ h: h2, s: s2, v: v2 }));
        v2 = (v2 + modification) % 1;
      }
      return ret;
    }
    tinycolor2.mix = function(color1, color2, amount) {
      amount = amount === 0 ? 0 : amount || 50;
      var rgb1 = tinycolor2(color1).toRgb();
      var rgb2 = tinycolor2(color2).toRgb();
      var p2 = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
        a: (rgb2.a - rgb1.a) * p2 + rgb1.a
      };
      return tinycolor2(rgba);
    };
    tinycolor2.readability = function(color1, color2) {
      var c1 = tinycolor2(color1);
      var c2 = tinycolor2(color2);
      return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
    };
    tinycolor2.isReadable = function(color1, color2, wcag2) {
      var readability = tinycolor2.readability(color1, color2);
      var wcag2Parms, out;
      out = false;
      wcag2Parms = validateWCAG2Parms(wcag2);
      switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
          out = readability >= 4.5;
          break;
        case "AAlarge":
          out = readability >= 3;
          break;
        case "AAAsmall":
          out = readability >= 7;
          break;
      }
      return out;
    };
    tinycolor2.mostReadable = function(baseColor, colorList, args) {
      var bestColor = null;
      var bestScore = 0;
      var readability;
      var includeFallbackColors, level, size;
      args = args || {};
      includeFallbackColors = args.includeFallbackColors;
      level = args.level;
      size = args.size;
      for (var i2 = 0; i2 < colorList.length; i2++) {
        readability = tinycolor2.readability(baseColor, colorList[i2]);
        if (readability > bestScore) {
          bestScore = readability;
          bestColor = tinycolor2(colorList[i2]);
        }
      }
      if (tinycolor2.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
        return bestColor;
      } else {
        args.includeFallbackColors = false;
        return tinycolor2.mostReadable(baseColor, ["#fff", "#000"], args);
      }
    };
    var names = tinycolor2.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    var hexNames = tinycolor2.hexNames = flip2(names);
    function flip2(o2) {
      var flipped = {};
      for (var i2 in o2) {
        if (o2.hasOwnProperty(i2)) {
          flipped[o2[i2]] = i2;
        }
      }
      return flipped;
    }
    function boundAlpha(a2) {
      a2 = parseFloat(a2);
      if (isNaN(a2) || a2 < 0 || a2 > 1) {
        a2 = 1;
      }
      return a2;
    }
    function bound01(n2, max2) {
      if (isOnePointZero(n2)) {
        n2 = "100%";
      }
      var processPercent = isPercentage(n2);
      n2 = mathMin(max2, mathMax(0, parseFloat(n2)));
      if (processPercent) {
        n2 = parseInt(n2 * max2, 10) / 100;
      }
      if (Math2.abs(n2 - max2) < 1e-6) {
        return 1;
      }
      return n2 % max2 / parseFloat(max2);
    }
    function clamp01(val) {
      return mathMin(1, mathMax(0, val));
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function isOnePointZero(n2) {
      return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
    }
    function isPercentage(n2) {
      return typeof n2 === "string" && n2.indexOf("%") != -1;
    }
    function pad2(c2) {
      return c2.length == 1 ? "0" + c2 : "" + c2;
    }
    function convertToPercentage(n2) {
      if (n2 <= 1) {
        n2 = n2 * 100 + "%";
      }
      return n2;
    }
    function convertDecimalToHex(d2) {
      return Math2.round(parseFloat(d2) * 255).toString(16);
    }
    function convertHexToDecimal(h2) {
      return parseIntFromHex(h2) / 255;
    }
    var matchers = function() {
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
    }();
    function isValidCSSUnit(color) {
      return !!matchers.CSS_UNIT.exec(color);
    }
    function stringInputToObject(color) {
      color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color == "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match;
      if (match = matchers.rgb.exec(color)) {
        return { r: match[1], g: match[2], b: match[3] };
      }
      if (match = matchers.rgba.exec(color)) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      if (match = matchers.hsl.exec(color)) {
        return { h: match[1], s: match[2], l: match[3] };
      }
      if (match = matchers.hsla.exec(color)) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      if (match = matchers.hsv.exec(color)) {
        return { h: match[1], s: match[2], v: match[3] };
      }
      if (match = matchers.hsva.exec(color)) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      if (match = matchers.hex8.exec(color)) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers.hex6.exec(color)) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      if (match = matchers.hex4.exec(color)) {
        return {
          r: parseIntFromHex(match[1] + "" + match[1]),
          g: parseIntFromHex(match[2] + "" + match[2]),
          b: parseIntFromHex(match[3] + "" + match[3]),
          a: convertHexToDecimal(match[4] + "" + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers.hex3.exec(color)) {
        return {
          r: parseIntFromHex(match[1] + "" + match[1]),
          g: parseIntFromHex(match[2] + "" + match[2]),
          b: parseIntFromHex(match[3] + "" + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function validateWCAG2Parms(parms) {
      var level, size;
      parms = parms || { "level": "AA", "size": "small" };
      level = (parms.level || "AA").toUpperCase();
      size = (parms.size || "small").toLowerCase();
      if (level !== "AA" && level !== "AAA") {
        level = "AA";
      }
      if (size !== "small" && size !== "large") {
        size = "small";
      }
      return { "level": level, "size": size };
    }
    if (module2.exports) {
      module2.exports = tinycolor2;
    } else {
      window.tinycolor = tinycolor2;
    }
  })(Math);
})(tinycolor$1);
var tinycolor = tinycolor$1.exports;
function tryOnScopeDispose(fn3) {
  if (getCurrentScope()) {
    onScopeDispose(fn3);
    return true;
  }
  return false;
}
const isClient = typeof window !== "undefined";
const isString$1 = (val) => typeof val === "string";
const noop = () => {
};
function createFilterWrapper(filter, fn3) {
  function wrapper(...args) {
    filter(() => fn3.apply(this, args), { fn: fn3, thisArg: this, args });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  const filter = (invoke) => {
    const duration = unref(ms);
    const maxDuration = unref(options.maxWait);
    if (timer)
      clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer)
          clearTimeout(timer);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }
    timer = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };
  return filter;
}
function useDebounceFn(fn3, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn3);
}
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source2, exclude) => {
  var target = {};
  for (var prop in source2)
    if (__hasOwnProp$9.call(source2, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source2[prop];
  if (source2 != null && __getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(source2)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$9.call(source2, prop))
        target[prop] = source2[prop];
    }
  return target;
};
function watchWithFilter(source2, cb, options = {}) {
  const _a = options, {
    eventFilter = bypassFilter
  } = _a, watchOptions = __objRest$5(_a, [
    "eventFilter"
  ]);
  return watch(source2, createFilterWrapper(eventFilter, cb), watchOptions);
}
function tryOnMounted(fn3, sync = true) {
  if (getCurrentInstance())
    onMounted(fn3);
  else if (sync)
    fn3();
  else
    nextTick(fn3);
}
function whenever(source2, cb, options) {
  return watch(source2, (v2, ov, onInvalidate) => {
    if (v2)
      cb(v2, ov, onInvalidate);
  }, options);
}
function unrefElement(elRef) {
  var _a;
  const plain = unref(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options;
  if (isString$1(args[0])) {
    [event, listener, options] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options] = args;
  }
  if (!target)
    return noop;
  let cleanup = noop;
  const stopWatch = watch(() => unref(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options);
    cleanup = () => {
      el.removeEventListener(event, listener, options);
      cleanup = noop;
    };
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function onClickOutside(target, handler, options = {}) {
  const { window: window2 = defaultWindow, event = "pointerdown" } = options;
  if (!window2)
    return;
  const listener = (event2) => {
    const el = unrefElement(target);
    if (!el)
      return;
    if (el === event2.target || event2.composedPath().includes(el))
      return;
    handler(event2);
  };
  return useEventListener(window2, event, listener, { passive: true });
}
const StorageSerializers = {
  boolean: {
    read: (v2) => v2 === "true",
    write: (v2) => String(v2)
  },
  object: {
    read: (v2) => JSON.parse(v2),
    write: (v2) => JSON.stringify(v2)
  },
  number: {
    read: (v2) => Number.parseFloat(v2),
    write: (v2) => String(v2)
  },
  any: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  string: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  map: {
    read: (v2) => new Map(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  },
  set: {
    read: (v2) => new Set(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  }
};
function useStorage(key, initialValue, storage = ((_a) => (_a = defaultWindow) == null ? void 0 : _a.localStorage)(), options = {}) {
  var _a2;
  const {
    flush: flush2 = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e2) => {
      console.error(e2);
    }
  } = options;
  const rawInit = unref(initialValue);
  const type = rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
  const data2 = (shallow ? shallowRef : ref)(initialValue);
  const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type];
  function read2(event) {
    if (!storage || event && event.key !== key)
      return;
    try {
      const rawValue = event ? event.newValue : storage.getItem(key);
      if (rawValue == null) {
        data2.value = rawInit;
        if (writeDefaults && rawInit !== null)
          storage.setItem(key, serializer.write(rawInit));
      } else {
        data2.value = serializer.read(rawValue);
      }
    } catch (e2) {
      onError(e2);
    }
  }
  read2();
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", (e2) => setTimeout(() => read2(e2), 0));
  if (storage) {
    watchWithFilter(data2, () => {
      try {
        if (data2.value == null)
          storage.removeItem(key);
        else
          storage.setItem(key, serializer.write(data2.value));
      } catch (e2) {
        onError(e2);
      }
    }, {
      flush: flush2,
      deep,
      eventFilter
    });
  }
  return data2;
}
function useLocalStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function e(t2) {
  var e2 = { exports: {} };
  return t2(e2, e2.exports), e2.exports;
}
var n = function(t2) {
  return t2 && t2.Math == Math && t2;
}, r = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof t && t) || function() {
  return this;
}() || Function("return this")(), o = function(t2) {
  try {
    return !!t2();
  } catch (t3) {
    return true;
  }
}, i = !o(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
}), u = {}.propertyIsEnumerable, a = Object.getOwnPropertyDescriptor, c = { f: a && !u.call({ 1: 2 }, 1) ? function(t2) {
  var e2 = a(this, t2);
  return !!e2 && e2.enumerable;
} : u }, l = function(t2, e2) {
  return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e2 };
}, f = {}.toString, s = function(t2) {
  return f.call(t2).slice(8, -1);
}, d = "".split, v = o(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(t2) {
  return "String" == s(t2) ? d.call(t2, "") : Object(t2);
} : Object, p = function(t2) {
  if (null == t2)
    throw TypeError("Can't call method on " + t2);
  return t2;
}, g = function(t2) {
  return v(p(t2));
}, h = function(t2) {
  return "object" == typeof t2 ? null !== t2 : "function" == typeof t2;
}, y = function(t2, e2) {
  if (!h(t2))
    return t2;
  var n2, r2;
  if (e2 && "function" == typeof (n2 = t2.toString) && !h(r2 = n2.call(t2)))
    return r2;
  if ("function" == typeof (n2 = t2.valueOf) && !h(r2 = n2.call(t2)))
    return r2;
  if (!e2 && "function" == typeof (n2 = t2.toString) && !h(r2 = n2.call(t2)))
    return r2;
  throw TypeError("Can't convert object to primitive value");
}, m = {}.hasOwnProperty, S = function(t2, e2) {
  return m.call(t2, e2);
}, x = r.document, b = h(x) && h(x.createElement), E = function(t2) {
  return b ? x.createElement(t2) : {};
}, w = !i && !o(function() {
  return 7 != Object.defineProperty(E("div"), "a", { get: function() {
    return 7;
  } }).a;
}), O = Object.getOwnPropertyDescriptor, T = { f: i ? O : function(t2, e2) {
  if (t2 = g(t2), e2 = y(e2, true), w)
    try {
      return O(t2, e2);
    } catch (t3) {
    }
  if (S(t2, e2))
    return l(!c.f.call(t2, e2), t2[e2]);
} }, A = function(t2) {
  if (!h(t2))
    throw TypeError(String(t2) + " is not an object");
  return t2;
}, k = Object.defineProperty, R = { f: i ? k : function(t2, e2, n2) {
  if (A(t2), e2 = y(e2, true), A(n2), w)
    try {
      return k(t2, e2, n2);
    } catch (t3) {
    }
  if ("get" in n2 || "set" in n2)
    throw TypeError("Accessors not supported");
  return "value" in n2 && (t2[e2] = n2.value), t2;
} }, I = i ? function(t2, e2, n2) {
  return R.f(t2, e2, l(1, n2));
} : function(t2, e2, n2) {
  return t2[e2] = n2, t2;
}, j = function(t2, e2) {
  try {
    I(r, t2, e2);
  } catch (n2) {
    r[t2] = e2;
  }
  return e2;
}, C = r["__core-js_shared__"] || j("__core-js_shared__", {}), L = Function.toString;
"function" != typeof C.inspectSource && (C.inspectSource = function(t2) {
  return L.call(t2);
});
var P, M, _$1, D = C.inspectSource, U = r.WeakMap, N = "function" == typeof U && /native code/.test(D(U)), F = e(function(t2) {
  (t2.exports = function(t3, e2) {
    return C[t3] || (C[t3] = void 0 !== e2 ? e2 : {});
  })("versions", []).push({ version: "3.8.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
}), W = 0, z = Math.random(), $ = function(t2) {
  return "Symbol(" + String(void 0 === t2 ? "" : t2) + ")_" + (++W + z).toString(36);
}, B = F("keys"), Y = function(t2) {
  return B[t2] || (B[t2] = $(t2));
}, G = {}, H = r.WeakMap;
if (N) {
  var X = C.state || (C.state = new H()), V = X.get, K = X.has, q = X.set;
  P = function(t2, e2) {
    return e2.facade = t2, q.call(X, t2, e2), e2;
  }, M = function(t2) {
    return V.call(X, t2) || {};
  }, _$1 = function(t2) {
    return K.call(X, t2);
  };
} else {
  var Q = Y("state");
  G[Q] = true, P = function(t2, e2) {
    return e2.facade = t2, I(t2, Q, e2), e2;
  }, M = function(t2) {
    return S(t2, Q) ? t2[Q] : {};
  }, _$1 = function(t2) {
    return S(t2, Q);
  };
}
var J = { set: P, get: M, has: _$1, enforce: function(t2) {
  return _$1(t2) ? M(t2) : P(t2, {});
}, getterFor: function(t2) {
  return function(e2) {
    var n2;
    if (!h(e2) || (n2 = M(e2)).type !== t2)
      throw TypeError("Incompatible receiver, " + t2 + " required");
    return n2;
  };
} }, Z = e(function(t2) {
  var e2 = J.get, n2 = J.enforce, o2 = String(String).split("String");
  (t2.exports = function(t3, e3, i2, u2) {
    var a2, c2 = !!u2 && !!u2.unsafe, l2 = !!u2 && !!u2.enumerable, f2 = !!u2 && !!u2.noTargetGet;
    "function" == typeof i2 && ("string" != typeof e3 || S(i2, "name") || I(i2, "name", e3), (a2 = n2(i2)).source || (a2.source = o2.join("string" == typeof e3 ? e3 : ""))), t3 !== r ? (c2 ? !f2 && t3[e3] && (l2 = true) : delete t3[e3], l2 ? t3[e3] = i2 : I(t3, e3, i2)) : l2 ? t3[e3] = i2 : j(e3, i2);
  })(Function.prototype, "toString", function() {
    return "function" == typeof this && e2(this).source || D(this);
  });
}), tt = r, et = function(t2) {
  return "function" == typeof t2 ? t2 : void 0;
}, nt = function(t2, e2) {
  return arguments.length < 2 ? et(tt[t2]) || et(r[t2]) : tt[t2] && tt[t2][e2] || r[t2] && r[t2][e2];
}, rt = Math.ceil, ot = Math.floor, it = function(t2) {
  return isNaN(t2 = +t2) ? 0 : (t2 > 0 ? ot : rt)(t2);
}, ut = Math.min, at = function(t2) {
  return t2 > 0 ? ut(it(t2), 9007199254740991) : 0;
}, ct = Math.max, lt = Math.min, ft = function(t2, e2) {
  var n2 = it(t2);
  return n2 < 0 ? ct(n2 + e2, 0) : lt(n2, e2);
}, st = function(t2) {
  return function(e2, n2, r2) {
    var o2, i2 = g(e2), u2 = at(i2.length), a2 = ft(r2, u2);
    if (t2 && n2 != n2) {
      for (; u2 > a2; )
        if ((o2 = i2[a2++]) != o2)
          return true;
    } else
      for (; u2 > a2; a2++)
        if ((t2 || a2 in i2) && i2[a2] === n2)
          return t2 || a2 || 0;
    return !t2 && -1;
  };
}, dt = { includes: st(true), indexOf: st(false) }, vt = dt.indexOf, pt = function(t2, e2) {
  var n2, r2 = g(t2), o2 = 0, i2 = [];
  for (n2 in r2)
    !S(G, n2) && S(r2, n2) && i2.push(n2);
  for (; e2.length > o2; )
    S(r2, n2 = e2[o2++]) && (~vt(i2, n2) || i2.push(n2));
  return i2;
}, gt = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], ht = gt.concat("length", "prototype"), yt = { f: Object.getOwnPropertyNames || function(t2) {
  return pt(t2, ht);
} }, mt = { f: Object.getOwnPropertySymbols }, St = nt("Reflect", "ownKeys") || function(t2) {
  var e2 = yt.f(A(t2)), n2 = mt.f;
  return n2 ? e2.concat(n2(t2)) : e2;
}, xt = function(t2, e2) {
  for (var n2 = St(e2), r2 = R.f, o2 = T.f, i2 = 0; i2 < n2.length; i2++) {
    var u2 = n2[i2];
    S(t2, u2) || r2(t2, u2, o2(e2, u2));
  }
}, bt = /#|\.prototype\./, Et = function(t2, e2) {
  var n2 = Ot[wt(t2)];
  return n2 == At || n2 != Tt && ("function" == typeof e2 ? o(e2) : !!e2);
}, wt = Et.normalize = function(t2) {
  return String(t2).replace(bt, ".").toLowerCase();
}, Ot = Et.data = {}, Tt = Et.NATIVE = "N", At = Et.POLYFILL = "P", kt = Et, Rt = T.f, It = function(t2, e2) {
  var n2, o2, i2, u2, a2, c2 = t2.target, l2 = t2.global, f2 = t2.stat;
  if (n2 = l2 ? r : f2 ? r[c2] || j(c2, {}) : (r[c2] || {}).prototype)
    for (o2 in e2) {
      if (u2 = e2[o2], i2 = t2.noTargetGet ? (a2 = Rt(n2, o2)) && a2.value : n2[o2], !kt(l2 ? o2 : c2 + (f2 ? "." : "#") + o2, t2.forced) && void 0 !== i2) {
        if (typeof u2 == typeof i2)
          continue;
        xt(u2, i2);
      }
      (t2.sham || i2 && i2.sham) && I(u2, "sham", true), Z(n2, o2, u2, t2);
    }
}, jt = function(t2, e2) {
  var n2 = [][t2];
  return !!n2 && o(function() {
    n2.call(null, e2 || function() {
      throw 1;
    }, 1);
  });
}, Ct = Object.defineProperty, Lt = {}, Pt = function(t2) {
  throw t2;
}, Mt = function(t2, e2) {
  if (S(Lt, t2))
    return Lt[t2];
  e2 || (e2 = {});
  var n2 = [][t2], r2 = !!S(e2, "ACCESSORS") && e2.ACCESSORS, u2 = S(e2, 0) ? e2[0] : Pt, a2 = S(e2, 1) ? e2[1] : void 0;
  return Lt[t2] = !!n2 && !o(function() {
    if (r2 && !i)
      return true;
    var t3 = { length: -1 };
    r2 ? Ct(t3, 1, { enumerable: true, get: Pt }) : t3[1] = 1, n2.call(t3, u2, a2);
  });
}, _t = dt.indexOf, Dt = [].indexOf, Ut = !!Dt && 1 / [1].indexOf(1, -0) < 0, Nt = jt("indexOf"), Ft = Mt("indexOf", { ACCESSORS: true, 1: 0 });
function Wt(t2, e2) {
  if (!(t2 instanceof e2))
    throw new TypeError("Cannot call a class as a function");
}
function zt(t2, e2) {
  for (var n2 = 0; n2 < e2.length; n2++) {
    var r2 = e2[n2];
    r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t2, r2.key, r2);
  }
}
function $t(t2, e2, n2) {
  return e2 && zt(t2.prototype, e2), n2 && zt(t2, n2), t2;
}
It({ target: "Array", proto: true, forced: Ut || !Nt || !Ft }, { indexOf: function(t2) {
  return Ut ? Dt.apply(this, arguments) || 0 : _t(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} });
(function() {
  function t2() {
    Wt(this, t2);
  }
  return $t(t2, null, [{ key: "isInBrowser", value: function() {
    return "undefined" != typeof window;
  } }, { key: "isServer", value: function() {
    return "undefined" == typeof window;
  } }, { key: "getUA", value: function() {
    return t2.isInBrowser() ? window.navigator.userAgent.toLowerCase() : "";
  } }, { key: "isMobile", value: function() {
    return /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(navigator.appVersion);
  } }, { key: "isOpera", value: function() {
    return -1 !== navigator.userAgent.indexOf("Opera");
  } }, { key: "isIE", value: function() {
    var e2 = t2.getUA();
    return "" !== e2 && e2.indexOf("msie") > 0;
  } }, { key: "isIE9", value: function() {
    var e2 = t2.getUA();
    return "" !== e2 && e2.indexOf("msie 9.0") > 0;
  } }, { key: "isEdge", value: function() {
    var e2 = t2.getUA();
    return "" !== e2 && e2.indexOf("edge/") > 0;
  } }, { key: "isChrome", value: function() {
    var e2 = t2.getUA();
    return "" !== e2 && /chrome\/\d+/.test(e2) && !t2.isEdge();
  } }, { key: "isPhantomJS", value: function() {
    var e2 = t2.getUA();
    return "" !== e2 && /phantomjs/.test(e2);
  } }, { key: "isFirefox", value: function() {
    var e2 = t2.getUA();
    return "" !== e2 && /firefox/.test(e2);
  } }]), t2;
})();
var Yt = [].join, Gt = v != Object, Ht = jt("join", ",");
It({ target: "Array", proto: true, forced: Gt || !Ht }, { join: function(t2) {
  return Yt.call(g(this), void 0 === t2 ? "," : t2);
} });
var Xt, Vt, Kt = function(t2) {
  return Object(p(t2));
}, qt = Array.isArray || function(t2) {
  return "Array" == s(t2);
}, Qt = !!Object.getOwnPropertySymbols && !o(function() {
  return !String(Symbol());
}), Jt = Qt && !Symbol.sham && "symbol" == typeof Symbol.iterator, Zt = F("wks"), te = r.Symbol, ee = Jt ? te : te && te.withoutSetter || $, ne = function(t2) {
  return S(Zt, t2) || (Qt && S(te, t2) ? Zt[t2] = te[t2] : Zt[t2] = ee("Symbol." + t2)), Zt[t2];
}, re = ne("species"), oe = function(t2, e2) {
  var n2;
  return qt(t2) && ("function" != typeof (n2 = t2.constructor) || n2 !== Array && !qt(n2.prototype) ? h(n2) && null === (n2 = n2[re]) && (n2 = void 0) : n2 = void 0), new (void 0 === n2 ? Array : n2)(0 === e2 ? 0 : e2);
}, ie = function(t2, e2, n2) {
  var r2 = y(e2);
  r2 in t2 ? R.f(t2, r2, l(0, n2)) : t2[r2] = n2;
}, ue = nt("navigator", "userAgent") || "", ae = r.process, ce = ae && ae.versions, le = ce && ce.v8;
le ? Vt = (Xt = le.split("."))[0] + Xt[1] : ue && (!(Xt = ue.match(/Edge\/(\d+)/)) || Xt[1] >= 74) && (Xt = ue.match(/Chrome\/(\d+)/)) && (Vt = Xt[1]);
var fe = Vt && +Vt, se = ne("species"), de = function(t2) {
  return fe >= 51 || !o(function() {
    var e2 = [];
    return (e2.constructor = {})[se] = function() {
      return { foo: 1 };
    }, 1 !== e2[t2](Boolean).foo;
  });
}, ve = de("splice"), pe = Mt("splice", { ACCESSORS: true, 0: 0, 1: 2 }), ge = Math.max, he = Math.min;
It({ target: "Array", proto: true, forced: !ve || !pe }, { splice: function(t2, e2) {
  var n2, r2, o2, i2, u2, a2, c2 = Kt(this), l2 = at(c2.length), f2 = ft(t2, l2), s2 = arguments.length;
  if (0 === s2 ? n2 = r2 = 0 : 1 === s2 ? (n2 = 0, r2 = l2 - f2) : (n2 = s2 - 2, r2 = he(ge(it(e2), 0), l2 - f2)), l2 + n2 - r2 > 9007199254740991)
    throw TypeError("Maximum allowed length exceeded");
  for (o2 = oe(c2, r2), i2 = 0; i2 < r2; i2++)
    (u2 = f2 + i2) in c2 && ie(o2, i2, c2[u2]);
  if (o2.length = r2, n2 < r2) {
    for (i2 = f2; i2 < l2 - r2; i2++)
      a2 = i2 + n2, (u2 = i2 + r2) in c2 ? c2[a2] = c2[u2] : delete c2[a2];
    for (i2 = l2; i2 > l2 - r2 + n2; i2--)
      delete c2[i2 - 1];
  } else if (n2 > r2)
    for (i2 = l2 - r2; i2 > f2; i2--)
      a2 = i2 + n2 - 1, (u2 = i2 + r2 - 1) in c2 ? c2[a2] = c2[u2] : delete c2[a2];
  for (i2 = 0; i2 < n2; i2++)
    c2[i2 + f2] = arguments[i2 + 2];
  return c2.length = l2 - r2 + n2, o2;
} });
var ye = {};
ye[ne("toStringTag")] = "z";
var me = "[object z]" === String(ye), Se = ne("toStringTag"), xe = "Arguments" == s(function() {
  return arguments;
}()), be = me ? s : function(t2) {
  var e2, n2, r2;
  return void 0 === t2 ? "Undefined" : null === t2 ? "Null" : "string" == typeof (n2 = function(t3, e3) {
    try {
      return t3[e3];
    } catch (t4) {
    }
  }(e2 = Object(t2), Se)) ? n2 : xe ? s(e2) : "Object" == (r2 = s(e2)) && "function" == typeof e2.callee ? "Arguments" : r2;
}, Ee = me ? {}.toString : function() {
  return "[object " + be(this) + "]";
};
me || Z(Object.prototype, "toString", Ee, { unsafe: true });
var we = function() {
  var t2 = A(this), e2 = "";
  return t2.global && (e2 += "g"), t2.ignoreCase && (e2 += "i"), t2.multiline && (e2 += "m"), t2.dotAll && (e2 += "s"), t2.unicode && (e2 += "u"), t2.sticky && (e2 += "y"), e2;
};
function Oe(t2, e2) {
  return RegExp(t2, e2);
}
var Te, Ae, ke = { UNSUPPORTED_Y: o(function() {
  var t2 = Oe("a", "y");
  return t2.lastIndex = 2, null != t2.exec("abcd");
}), BROKEN_CARET: o(function() {
  var t2 = Oe("^r", "gy");
  return t2.lastIndex = 2, null != t2.exec("str");
}) }, Re = RegExp.prototype.exec, Ie = String.prototype.replace, je = Re, Ce = (Te = /a/, Ae = /b*/g, Re.call(Te, "a"), Re.call(Ae, "a"), 0 !== Te.lastIndex || 0 !== Ae.lastIndex), Le = ke.UNSUPPORTED_Y || ke.BROKEN_CARET, Pe = void 0 !== /()??/.exec("")[1];
(Ce || Pe || Le) && (je = function(t2) {
  var e2, n2, r2, o2, i2 = this, u2 = Le && i2.sticky, a2 = we.call(i2), c2 = i2.source, l2 = 0, f2 = t2;
  return u2 && (-1 === (a2 = a2.replace("y", "")).indexOf("g") && (a2 += "g"), f2 = String(t2).slice(i2.lastIndex), i2.lastIndex > 0 && (!i2.multiline || i2.multiline && "\n" !== t2[i2.lastIndex - 1]) && (c2 = "(?: " + c2 + ")", f2 = " " + f2, l2++), n2 = new RegExp("^(?:" + c2 + ")", a2)), Pe && (n2 = new RegExp("^" + c2 + "$(?!\\s)", a2)), Ce && (e2 = i2.lastIndex), r2 = Re.call(u2 ? n2 : i2, f2), u2 ? r2 ? (r2.input = r2.input.slice(l2), r2[0] = r2[0].slice(l2), r2.index = i2.lastIndex, i2.lastIndex += r2[0].length) : i2.lastIndex = 0 : Ce && r2 && (i2.lastIndex = i2.global ? r2.index + r2[0].length : e2), Pe && r2 && r2.length > 1 && Ie.call(r2[0], n2, function() {
    for (o2 = 1; o2 < arguments.length - 2; o2++)
      void 0 === arguments[o2] && (r2[o2] = void 0);
  }), r2;
});
var Me = je;
It({ target: "RegExp", proto: true, forced: /./.exec !== Me }, { exec: Me });
var _e = RegExp.prototype, De = _e.toString, Ue = o(function() {
  return "/a/b" != De.call({ source: "a", flags: "b" });
}), Ne = "toString" != De.name;
(Ue || Ne) && Z(RegExp.prototype, "toString", function() {
  var t2 = A(this), e2 = String(t2.source), n2 = t2.flags;
  return "/" + e2 + "/" + String(void 0 === n2 && t2 instanceof RegExp && !("flags" in _e) ? we.call(t2) : n2);
}, { unsafe: true });
var Fe = ne("species"), We = !o(function() {
  var t2 = /./;
  return t2.exec = function() {
    var t3 = [];
    return t3.groups = { a: "7" }, t3;
  }, "7" !== "".replace(t2, "$<a>");
}), ze = "$0" === "a".replace(/./, "$0"), $e = ne("replace"), Be = !!/./[$e] && "" === /./[$e]("a", "$0"), Ye = !o(function() {
  var t2 = /(?:)/, e2 = t2.exec;
  t2.exec = function() {
    return e2.apply(this, arguments);
  };
  var n2 = "ab".split(t2);
  return 2 !== n2.length || "a" !== n2[0] || "b" !== n2[1];
}), Ge = function(t2, e2, n2, r2) {
  var i2 = ne(t2), u2 = !o(function() {
    var e3 = {};
    return e3[i2] = function() {
      return 7;
    }, 7 != ""[t2](e3);
  }), a2 = u2 && !o(function() {
    var e3 = false, n3 = /a/;
    return "split" === t2 && ((n3 = {}).constructor = {}, n3.constructor[Fe] = function() {
      return n3;
    }, n3.flags = "", n3[i2] = /./[i2]), n3.exec = function() {
      return e3 = true, null;
    }, n3[i2](""), !e3;
  });
  if (!u2 || !a2 || "replace" === t2 && (!We || !ze || Be) || "split" === t2 && !Ye) {
    var c2 = /./[i2], l2 = n2(i2, ""[t2], function(t3, e3, n3, r3, o2) {
      return e3.exec === Me ? u2 && !o2 ? { done: true, value: c2.call(e3, n3, r3) } : { done: true, value: t3.call(n3, e3, r3) } : { done: false };
    }, { REPLACE_KEEPS_$0: ze, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: Be }), f2 = l2[0], s2 = l2[1];
    Z(String.prototype, t2, f2), Z(RegExp.prototype, i2, 2 == e2 ? function(t3, e3) {
      return s2.call(t3, this, e3);
    } : function(t3) {
      return s2.call(t3, this);
    });
  }
  r2 && I(RegExp.prototype[i2], "sham", true);
}, He = ne("match"), Xe = function(t2) {
  var e2;
  return h(t2) && (void 0 !== (e2 = t2[He]) ? !!e2 : "RegExp" == s(t2));
}, Ve = function(t2) {
  if ("function" != typeof t2)
    throw TypeError(String(t2) + " is not a function");
  return t2;
}, Ke = ne("species"), qe = function(t2) {
  return function(e2, n2) {
    var r2, o2, i2 = String(p(e2)), u2 = it(n2), a2 = i2.length;
    return u2 < 0 || u2 >= a2 ? t2 ? "" : void 0 : (r2 = i2.charCodeAt(u2)) < 55296 || r2 > 56319 || u2 + 1 === a2 || (o2 = i2.charCodeAt(u2 + 1)) < 56320 || o2 > 57343 ? t2 ? i2.charAt(u2) : r2 : t2 ? i2.slice(u2, u2 + 2) : o2 - 56320 + (r2 - 55296 << 10) + 65536;
  };
}, Qe = { codeAt: qe(false), charAt: qe(true) }, Je = Qe.charAt, Ze = function(t2, e2, n2) {
  return e2 + (n2 ? Je(t2, e2).length : 1);
}, tn = function(t2, e2) {
  var n2 = t2.exec;
  if ("function" == typeof n2) {
    var r2 = n2.call(t2, e2);
    if ("object" != typeof r2)
      throw TypeError("RegExp exec method returned something other than an Object or null");
    return r2;
  }
  if ("RegExp" !== s(t2))
    throw TypeError("RegExp#exec called on incompatible receiver");
  return Me.call(t2, e2);
}, en = [].push, nn = Math.min, rn = !o(function() {
  return !RegExp(4294967295, "y");
});
Ge("split", 2, function(t2, e2, n2) {
  var r2;
  return r2 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t3, n3) {
    var r3 = String(p(this)), o2 = void 0 === n3 ? 4294967295 : n3 >>> 0;
    if (0 === o2)
      return [];
    if (void 0 === t3)
      return [r3];
    if (!Xe(t3))
      return e2.call(r3, t3, o2);
    for (var i2, u2, a2, c2 = [], l2 = (t3.ignoreCase ? "i" : "") + (t3.multiline ? "m" : "") + (t3.unicode ? "u" : "") + (t3.sticky ? "y" : ""), f2 = 0, s2 = new RegExp(t3.source, l2 + "g"); (i2 = Me.call(s2, r3)) && !((u2 = s2.lastIndex) > f2 && (c2.push(r3.slice(f2, i2.index)), i2.length > 1 && i2.index < r3.length && en.apply(c2, i2.slice(1)), a2 = i2[0].length, f2 = u2, c2.length >= o2)); )
      s2.lastIndex === i2.index && s2.lastIndex++;
    return f2 === r3.length ? !a2 && s2.test("") || c2.push("") : c2.push(r3.slice(f2)), c2.length > o2 ? c2.slice(0, o2) : c2;
  } : "0".split(void 0, 0).length ? function(t3, n3) {
    return void 0 === t3 && 0 === n3 ? [] : e2.call(this, t3, n3);
  } : e2, [function(e3, n3) {
    var o2 = p(this), i2 = null == e3 ? void 0 : e3[t2];
    return void 0 !== i2 ? i2.call(e3, o2, n3) : r2.call(String(o2), e3, n3);
  }, function(t3, o2) {
    var i2 = n2(r2, t3, this, o2, r2 !== e2);
    if (i2.done)
      return i2.value;
    var u2 = A(t3), a2 = String(this), c2 = function(t4, e3) {
      var n3, r3 = A(t4).constructor;
      return void 0 === r3 || null == (n3 = A(r3)[Ke]) ? e3 : Ve(n3);
    }(u2, RegExp), l2 = u2.unicode, f2 = (u2.ignoreCase ? "i" : "") + (u2.multiline ? "m" : "") + (u2.unicode ? "u" : "") + (rn ? "y" : "g"), s2 = new c2(rn ? u2 : "^(?:" + u2.source + ")", f2), d2 = void 0 === o2 ? 4294967295 : o2 >>> 0;
    if (0 === d2)
      return [];
    if (0 === a2.length)
      return null === tn(s2, a2) ? [a2] : [];
    for (var v2 = 0, p2 = 0, g2 = []; p2 < a2.length; ) {
      s2.lastIndex = rn ? p2 : 0;
      var h2, y2 = tn(s2, rn ? a2 : a2.slice(p2));
      if (null === y2 || (h2 = nn(at(s2.lastIndex + (rn ? 0 : p2)), a2.length)) === v2)
        p2 = Ze(a2, p2, l2);
      else {
        if (g2.push(a2.slice(v2, p2)), g2.length === d2)
          return g2;
        for (var m2 = 1; m2 <= y2.length - 1; m2++)
          if (g2.push(y2[m2]), g2.length === d2)
            return g2;
        p2 = v2 = h2;
      }
    }
    return g2.push(a2.slice(v2)), g2;
  }];
}, !rn);
var on$1 = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF", un = "[" + on$1 + "]", an = RegExp("^" + un + un + "*"), cn = RegExp(un + un + "*$"), ln = function(t2) {
  return function(e2) {
    var n2 = String(p(e2));
    return 1 & t2 && (n2 = n2.replace(an, "")), 2 & t2 && (n2 = n2.replace(cn, "")), n2;
  };
}, fn = { start: ln(1), end: ln(2), trim: ln(3) }, sn = fn.trim;
It({ target: "String", proto: true, forced: function(t2) {
  return o(function() {
    return !!on$1[t2]() || "\u200B\x85\u180E" != "\u200B\x85\u180E"[t2]() || on$1[t2].name !== t2;
  });
}("trim") }, { trim: function() {
  return sn(this);
} });
var dn = de("slice"), vn = Mt("slice", { ACCESSORS: true, 0: 0, 1: 2 }), pn = ne("species"), gn = [].slice, hn = Math.max;
It({ target: "Array", proto: true, forced: !dn || !vn }, { slice: function(t2, e2) {
  var n2, r2, o2, i2 = g(this), u2 = at(i2.length), a2 = ft(t2, u2), c2 = ft(void 0 === e2 ? u2 : e2, u2);
  if (qt(i2) && ("function" != typeof (n2 = i2.constructor) || n2 !== Array && !qt(n2.prototype) ? h(n2) && null === (n2 = n2[pn]) && (n2 = void 0) : n2 = void 0, n2 === Array || void 0 === n2))
    return gn.call(i2, a2, c2);
  for (r2 = new (void 0 === n2 ? Array : n2)(hn(c2 - a2, 0)), o2 = 0; a2 < c2; a2++, o2++)
    a2 in i2 && ie(r2, o2, i2[a2]);
  return r2.length = o2, r2;
} });
var yn = Object.keys || function(t2) {
  return pt(t2, gt);
}, mn = o(function() {
  yn(1);
});
It({ target: "Object", stat: true, forced: mn }, { keys: function(t2) {
  return yn(Kt(t2));
} });
var Sn, xn = function(t2) {
  if (Xe(t2))
    throw TypeError("The method doesn't accept regular expressions");
  return t2;
}, bn = ne("match"), En = T.f, wn = "".startsWith, On = Math.min, Tn = function(t2) {
  var e2 = /./;
  try {
    "/./"[t2](e2);
  } catch (n2) {
    try {
      return e2[bn] = false, "/./"[t2](e2);
    } catch (t3) {
    }
  }
  return false;
}("startsWith"), An = !(Tn || (Sn = En(String.prototype, "startsWith"), !Sn || Sn.writable));
function kn(t2) {
  return (kn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
    return typeof t3;
  } : function(t3) {
    return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
  })(t2);
}
It({ target: "String", proto: true, forced: !An && !Tn }, { startsWith: function(t2) {
  var e2 = String(p(this));
  xn(t2);
  var n2 = at(On(arguments.length > 1 ? arguments[1] : void 0, e2.length)), r2 = String(t2);
  return wn ? wn.call(e2, r2, n2) : e2.slice(n2, n2 + r2.length) === r2;
} });
var jn = function(t2) {
  return "string" == typeof t2;
}, Mn = function(t2) {
  return null !== t2 && "object" === kn(t2);
}, Vn = function() {
  function t2() {
    Wt(this, t2);
  }
  return $t(t2, null, [{ key: "isWindow", value: function(t3) {
    return t3 === window;
  } }, { key: "addEventListener", value: function(t3, e2, n2) {
    var r2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    t3 && e2 && n2 && t3.addEventListener(e2, n2, r2);
  } }, { key: "removeEventListener", value: function(t3, e2, n2) {
    var r2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    t3 && e2 && n2 && t3.removeEventListener(e2, n2, r2);
  } }, { key: "triggerDragEvent", value: function(e2, n2) {
    var r2 = false, o2 = function(t3) {
      var e3;
      null === (e3 = n2.drag) || void 0 === e3 || e3.call(n2, t3);
    }, i2 = function e3(i3) {
      var u2;
      t2.removeEventListener(document, "mousemove", o2), t2.removeEventListener(document, "mouseup", e3), document.onselectstart = null, document.ondragstart = null, r2 = false, null === (u2 = n2.end) || void 0 === u2 || u2.call(n2, i3);
    };
    t2.addEventListener(e2, "mousedown", function(e3) {
      var u2;
      r2 || (document.onselectstart = function() {
        return false;
      }, document.ondragstart = function() {
        return false;
      }, t2.addEventListener(document, "mousemove", o2), t2.addEventListener(document, "mouseup", i2), r2 = true, null === (u2 = n2.start) || void 0 === u2 || u2.call(n2, e3));
    });
  } }, { key: "getBoundingClientRect", value: function(t3) {
    return t3 && Mn(t3) && 1 === t3.nodeType ? t3.getBoundingClientRect() : null;
  } }, { key: "hasClass", value: function(t3, e2) {
    return !!(t3 && Mn(t3) && jn(e2) && 1 === t3.nodeType) && t3.classList.contains(e2.trim());
  } }, { key: "addClass", value: function(e2, n2) {
    if (e2 && Mn(e2) && jn(n2) && 1 === e2.nodeType && (n2 = n2.trim(), !t2.hasClass(e2, n2))) {
      var r2 = e2.className;
      e2.className = r2 ? r2 + " " + n2 : n2;
    }
  } }, { key: "removeClass", value: function(t3, e2) {
    if (t3 && Mn(t3) && jn(e2) && 1 === t3.nodeType && "string" == typeof t3.className) {
      e2 = e2.trim();
      for (var n2 = t3.className.trim().split(" "), r2 = n2.length - 1; r2 >= 0; r2--)
        n2[r2] = n2[r2].trim(), n2[r2] && n2[r2] !== e2 || n2.splice(r2, 1);
      t3.className = n2.join(" ");
    }
  } }, { key: "toggleClass", value: function(t3, e2, n2) {
    t3 && Mn(t3) && jn(e2) && 1 === t3.nodeType && t3.classList.toggle(e2, n2);
  } }, { key: "replaceClass", value: function(e2, n2, r2) {
    e2 && Mn(e2) && jn(n2) && jn(r2) && 1 === e2.nodeType && (n2 = n2.trim(), r2 = r2.trim(), t2.removeClass(e2, n2), t2.addClass(e2, r2));
  } }, { key: "getScrollTop", value: function(t3) {
    var e2 = "scrollTop" in t3 ? t3.scrollTop : t3.pageYOffset;
    return Math.max(e2, 0);
  } }, { key: "setScrollTop", value: function(t3, e2) {
    "scrollTop" in t3 ? t3.scrollTop = e2 : t3.scrollTo(t3.scrollX, e2);
  } }, { key: "getRootScrollTop", value: function() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  } }, { key: "setRootScrollTop", value: function(e2) {
    t2.setScrollTop(window, e2), t2.setScrollTop(document.body, e2);
  } }, { key: "getElementTop", value: function(e2, n2) {
    if (t2.isWindow(e2))
      return 0;
    var r2 = n2 ? t2.getScrollTop(n2) : t2.getRootScrollTop();
    return e2.getBoundingClientRect().top + r2;
  } }, { key: "getVisibleHeight", value: function(e2) {
    return t2.isWindow(e2) ? e2.innerHeight : e2.getBoundingClientRect().height;
  } }, { key: "isHidden", value: function(t3) {
    if (!t3)
      return false;
    var e2 = window.getComputedStyle(t3), n2 = "none" === e2.display, r2 = null === t3.offsetParent && "fixed" !== e2.position;
    return n2 || r2;
  } }, { key: "triggerEvent", value: function(t3, e2) {
    if ("createEvent" in document) {
      var n2 = document.createEvent("HTMLEvents");
      n2.initEvent(e2, false, true), t3.dispatchEvent(n2);
    }
  } }, { key: "calcAngle", value: function(t3, e2) {
    var n2 = t3.getBoundingClientRect(), r2 = n2.left + n2.width / 2, o2 = n2.top + n2.height / 2, i2 = Math.abs(r2 - e2.clientX), u2 = Math.abs(o2 - e2.clientY), a2 = u2 / Math.sqrt(Math.pow(i2, 2) + Math.pow(u2, 2)), c2 = Math.acos(a2), l2 = Math.floor(180 / (Math.PI / c2));
    return e2.clientX > r2 && e2.clientY > o2 && (l2 = 180 - l2), e2.clientX == r2 && e2.clientY > o2 && (l2 = 180), e2.clientX > r2 && e2.clientY == o2 && (l2 = 90), e2.clientX < r2 && e2.clientY > o2 && (l2 = 180 + l2), e2.clientX < r2 && e2.clientY == o2 && (l2 = 270), e2.clientX < r2 && e2.clientY < o2 && (l2 = 360 - l2), l2;
  } }, { key: "querySelector", value: function(t3, e2) {
    return e2 ? e2.querySelector(t3) : document.querySelector(t3);
  } }, { key: "createElement", value: function(t3) {
    for (var e2 = document.createElement(t3), n2 = arguments.length, r2 = new Array(n2 > 1 ? n2 - 1 : 0), o2 = 1; o2 < n2; o2++)
      r2[o2 - 1] = arguments[o2];
    for (var i2 = 0; i2 < r2.length; i2++)
      r2[i2] && e2.classList.add(r2[i2]);
    return e2;
  } }, { key: "appendChild", value: function(t3) {
    for (var e2 = 0; e2 < (arguments.length <= 1 ? 0 : arguments.length - 1); e2++)
      t3.appendChild(e2 + 1 < 1 || arguments.length <= e2 + 1 ? void 0 : arguments[e2 + 1]);
  } }, { key: "getWindow", value: function(t3) {
    if ("[object Window]" !== t3.toString()) {
      var e2 = t3.ownerDocument;
      return e2 && e2.defaultView || window;
    }
    return t3;
  } }, { key: "isElement", value: function(t3) {
    return t3 instanceof this.getWindow(t3).Element || t3 instanceof Element;
  } }, { key: "isHTMLElement", value: function(t3) {
    return t3 instanceof this.getWindow(t3).HTMLElement || t3 instanceof HTMLElement;
  } }, { key: "isShadowRoot", value: function(t3) {
    return "undefined" != typeof ShadowRoot && (t3 instanceof this.getWindow(t3).ShadowRoot || t3 instanceof ShadowRoot);
  } }, { key: "getWindowScroll", value: function(t3) {
    var e2 = this.getWindow(t3);
    return { scrollLeft: e2.pageXOffset || 0, scrollTop: e2.pageYOffset || 0 };
  } }]), t2;
}(), Kn = Math.floor, qn = "".replace, Qn = /\$([$&'`]|\d\d?|<[^>]*>)/g, Jn = /\$([$&'`]|\d\d?)/g, Zn = function(t2, e2, n2, r2, o2, i2) {
  var u2 = n2 + t2.length, a2 = r2.length, c2 = Jn;
  return void 0 !== o2 && (o2 = Kt(o2), c2 = Qn), qn.call(i2, c2, function(i3, c3) {
    var l2;
    switch (c3.charAt(0)) {
      case "$":
        return "$";
      case "&":
        return t2;
      case "`":
        return e2.slice(0, n2);
      case "'":
        return e2.slice(u2);
      case "<":
        l2 = o2[c3.slice(1, -1)];
        break;
      default:
        var f2 = +c3;
        if (0 === f2)
          return i3;
        if (f2 > a2) {
          var s2 = Kn(f2 / 10);
          return 0 === s2 ? i3 : s2 <= a2 ? void 0 === r2[s2 - 1] ? c3.charAt(1) : r2[s2 - 1] + c3.charAt(1) : i3;
        }
        l2 = r2[f2 - 1];
    }
    return void 0 === l2 ? "" : l2;
  });
}, tr = Math.max, er = Math.min;
Ge("replace", 2, function(t2, e2, n2, r2) {
  var o2 = r2.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, i2 = r2.REPLACE_KEEPS_$0, u2 = o2 ? "$" : "$0";
  return [function(n3, r3) {
    var o3 = p(this), i3 = null == n3 ? void 0 : n3[t2];
    return void 0 !== i3 ? i3.call(n3, o3, r3) : e2.call(String(o3), n3, r3);
  }, function(t3, r3) {
    if (!o2 && i2 || "string" == typeof r3 && -1 === r3.indexOf(u2)) {
      var a2 = n2(e2, t3, this, r3);
      if (a2.done)
        return a2.value;
    }
    var c2 = A(t3), l2 = String(this), f2 = "function" == typeof r3;
    f2 || (r3 = String(r3));
    var s2 = c2.global;
    if (s2) {
      var d2 = c2.unicode;
      c2.lastIndex = 0;
    }
    for (var v2 = []; ; ) {
      var p2 = tn(c2, l2);
      if (null === p2)
        break;
      if (v2.push(p2), !s2)
        break;
      "" === String(p2[0]) && (c2.lastIndex = Ze(l2, at(c2.lastIndex), d2));
    }
    for (var g2, h2 = "", y2 = 0, m2 = 0; m2 < v2.length; m2++) {
      p2 = v2[m2];
      for (var S2 = String(p2[0]), x2 = tr(er(it(p2.index), l2.length), 0), b2 = [], E2 = 1; E2 < p2.length; E2++)
        b2.push(void 0 === (g2 = p2[E2]) ? g2 : String(g2));
      var w2 = p2.groups;
      if (f2) {
        var O2 = [S2].concat(b2, x2, l2);
        void 0 !== w2 && O2.push(w2);
        var T2 = String(r3.apply(void 0, O2));
      } else
        T2 = Zn(S2, l2, x2, b2, w2, r3);
      x2 >= y2 && (h2 += l2.slice(y2, x2) + T2, y2 = x2 + S2.length);
    }
    return h2 + l2.slice(y2);
  }];
});
(function() {
  function t2() {
    Wt(this, t2);
  }
  return $t(t2, null, [{ key: "camelize", value: function(t3) {
    return t3.replace(/-(\w)/g, function(t4, e2) {
      return e2 ? e2.toUpperCase() : "";
    });
  } }, { key: "capitalize", value: function(t3) {
    return t3.charAt(0).toUpperCase() + t3.slice(1);
  } }]), t2;
})();
(function() {
  function t2() {
    Wt(this, t2);
  }
  return $t(t2, null, [{ key: "_clone", value: function() {
  } }]), t2;
})();
var or = ne("isConcatSpreadable"), ir = fe >= 51 || !o(function() {
  var t2 = [];
  return t2[or] = false, t2.concat()[0] !== t2;
}), ur = de("concat"), ar = function(t2) {
  if (!h(t2))
    return false;
  var e2 = t2[or];
  return void 0 !== e2 ? !!e2 : qt(t2);
};
It({ target: "Array", proto: true, forced: !ir || !ur }, { concat: function(t2) {
  var e2, n2, r2, o2, i2, u2 = Kt(this), a2 = oe(u2, 0), c2 = 0;
  for (e2 = -1, r2 = arguments.length; e2 < r2; e2++)
    if (ar(i2 = -1 === e2 ? u2 : arguments[e2])) {
      if (c2 + (o2 = at(i2.length)) > 9007199254740991)
        throw TypeError("Maximum allowed index exceeded");
      for (n2 = 0; n2 < o2; n2++, c2++)
        n2 in i2 && ie(a2, c2, i2[n2]);
    } else {
      if (c2 >= 9007199254740991)
        throw TypeError("Maximum allowed index exceeded");
      ie(a2, c2++, i2);
    }
  return a2.length = c2, a2;
} });
var cr, lr = function(t2, e2, n2) {
  if (Ve(t2), void 0 === e2)
    return t2;
  switch (n2) {
    case 0:
      return function() {
        return t2.call(e2);
      };
    case 1:
      return function(n3) {
        return t2.call(e2, n3);
      };
    case 2:
      return function(n3, r2) {
        return t2.call(e2, n3, r2);
      };
    case 3:
      return function(n3, r2, o2) {
        return t2.call(e2, n3, r2, o2);
      };
  }
  return function() {
    return t2.apply(e2, arguments);
  };
}, fr = [].push, sr = function(t2) {
  var e2 = 1 == t2, n2 = 2 == t2, r2 = 3 == t2, o2 = 4 == t2, i2 = 6 == t2, u2 = 7 == t2, a2 = 5 == t2 || i2;
  return function(c2, l2, f2, s2) {
    for (var d2, p2, g2 = Kt(c2), h2 = v(g2), y2 = lr(l2, f2, 3), m2 = at(h2.length), S2 = 0, x2 = s2 || oe, b2 = e2 ? x2(c2, m2) : n2 || u2 ? x2(c2, 0) : void 0; m2 > S2; S2++)
      if ((a2 || S2 in h2) && (p2 = y2(d2 = h2[S2], S2, g2), t2))
        if (e2)
          b2[S2] = p2;
        else if (p2)
          switch (t2) {
            case 3:
              return true;
            case 5:
              return d2;
            case 6:
              return S2;
            case 2:
              fr.call(b2, d2);
          }
        else
          switch (t2) {
            case 4:
              return false;
            case 7:
              fr.call(b2, d2);
          }
    return i2 ? -1 : r2 || o2 ? o2 : b2;
  };
}, dr = { forEach: sr(0), map: sr(1), filter: sr(2), some: sr(3), every: sr(4), find: sr(5), findIndex: sr(6), filterOut: sr(7) }, vr = i ? Object.defineProperties : function(t2, e2) {
  A(t2);
  for (var n2, r2 = yn(e2), o2 = r2.length, i2 = 0; o2 > i2; )
    R.f(t2, n2 = r2[i2++], e2[n2]);
  return t2;
}, pr = nt("document", "documentElement"), gr = Y("IE_PROTO"), hr = function() {
}, yr = function(t2) {
  return "<script>" + t2 + "<\/script>";
}, mr = function() {
  try {
    cr = document.domain && new ActiveXObject("htmlfile");
  } catch (t3) {
  }
  var t2, e2;
  mr = cr ? function(t3) {
    t3.write(yr("")), t3.close();
    var e3 = t3.parentWindow.Object;
    return t3 = null, e3;
  }(cr) : ((e2 = E("iframe")).style.display = "none", pr.appendChild(e2), e2.src = String("javascript:"), (t2 = e2.contentWindow.document).open(), t2.write(yr("document.F=Object")), t2.close(), t2.F);
  for (var n2 = gt.length; n2--; )
    delete mr.prototype[gt[n2]];
  return mr();
};
G[gr] = true;
var Sr = Object.create || function(t2, e2) {
  var n2;
  return null !== t2 ? (hr.prototype = A(t2), n2 = new hr(), hr.prototype = null, n2[gr] = t2) : n2 = mr(), void 0 === e2 ? n2 : vr(n2, e2);
}, xr = ne("unscopables"), br = Array.prototype;
null == br[xr] && R.f(br, xr, { configurable: true, value: Sr(null) });
var Er = function(t2) {
  br[xr][t2] = true;
}, wr = dr.find, Or = true, Tr = Mt("find");
"find" in [] && Array(1).find(function() {
  Or = false;
}), It({ target: "Array", proto: true, forced: Or || !Tr }, { find: function(t2) {
  return wr(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("find");
var Ar = dr.findIndex, kr = true, Rr = Mt("findIndex");
"findIndex" in [] && Array(1).findIndex(function() {
  kr = false;
}), It({ target: "Array", proto: true, forced: kr || !Rr }, { findIndex: function(t2) {
  return Ar(this, t2, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("findIndex");
var Ir = function(t2, e2, n2, r2, o2, i2, u2, a2) {
  for (var c2, l2 = o2, f2 = 0, s2 = !!u2 && lr(u2, a2, 3); f2 < r2; ) {
    if (f2 in n2) {
      if (c2 = s2 ? s2(n2[f2], f2, e2) : n2[f2], i2 > 0 && qt(c2))
        l2 = Ir(t2, e2, c2, at(c2.length), l2, i2 - 1) - 1;
      else {
        if (l2 >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        t2[l2] = c2;
      }
      l2++;
    }
    f2++;
  }
  return l2;
}, jr = Ir;
It({ target: "Array", proto: true }, { flat: function() {
  var t2 = arguments.length ? arguments[0] : void 0, e2 = Kt(this), n2 = at(e2.length), r2 = oe(e2, 0);
  return r2.length = jr(r2, e2, e2, n2, 0, void 0 === t2 ? 1 : it(t2)), r2;
} });
var Cr = function(t2) {
  var e2 = t2.return;
  if (void 0 !== e2)
    return A(e2.call(t2)).value;
}, Lr = function(t2, e2, n2, r2) {
  try {
    return r2 ? e2(A(n2)[0], n2[1]) : e2(n2);
  } catch (e3) {
    throw Cr(t2), e3;
  }
}, Pr = {}, Mr = ne("iterator"), _r = Array.prototype, Dr = function(t2) {
  return void 0 !== t2 && (Pr.Array === t2 || _r[Mr] === t2);
}, Ur = ne("iterator"), Nr = function(t2) {
  if (null != t2)
    return t2[Ur] || t2["@@iterator"] || Pr[be(t2)];
}, Fr = ne("iterator"), Wr = false;
try {
  var zr = 0, $r = { next: function() {
    return { done: !!zr++ };
  }, return: function() {
    Wr = true;
  } };
  $r[Fr] = function() {
    return this;
  }, Array.from($r, function() {
    throw 2;
  });
} catch (t2) {
}
var Br = function(t2, e2) {
  if (!e2 && !Wr)
    return false;
  var n2 = false;
  try {
    var r2 = {};
    r2[Fr] = function() {
      return { next: function() {
        return { done: n2 = true };
      } };
    }, t2(r2);
  } catch (t3) {
  }
  return n2;
}, Yr = !Br(function(t2) {
  Array.from(t2);
});
It({ target: "Array", stat: true, forced: Yr }, { from: function(t2) {
  var e2, n2, r2, o2, i2, u2, a2 = Kt(t2), c2 = "function" == typeof this ? this : Array, l2 = arguments.length, f2 = l2 > 1 ? arguments[1] : void 0, s2 = void 0 !== f2, d2 = Nr(a2), v2 = 0;
  if (s2 && (f2 = lr(f2, l2 > 2 ? arguments[2] : void 0, 2)), null == d2 || c2 == Array && Dr(d2))
    for (n2 = new c2(e2 = at(a2.length)); e2 > v2; v2++)
      u2 = s2 ? f2(a2[v2], v2) : a2[v2], ie(n2, v2, u2);
  else
    for (i2 = (o2 = d2.call(a2)).next, n2 = new c2(); !(r2 = i2.call(o2)).done; v2++)
      u2 = s2 ? Lr(o2, f2, [r2.value, v2], true) : r2.value, ie(n2, v2, u2);
  return n2.length = v2, n2;
} });
var Gr = function(t2) {
  return function(e2, n2, r2, o2) {
    Ve(n2);
    var i2 = Kt(e2), u2 = v(i2), a2 = at(i2.length), c2 = t2 ? a2 - 1 : 0, l2 = t2 ? -1 : 1;
    if (r2 < 2)
      for (; ; ) {
        if (c2 in u2) {
          o2 = u2[c2], c2 += l2;
          break;
        }
        if (c2 += l2, t2 ? c2 < 0 : a2 <= c2)
          throw TypeError("Reduce of empty array with no initial value");
      }
    for (; t2 ? c2 >= 0 : a2 > c2; c2 += l2)
      c2 in u2 && (o2 = n2(o2, u2[c2], c2, i2));
    return o2;
  };
}, Hr = { left: Gr(false), right: Gr(true) }, Xr = "process" == s(r.process), Vr = Hr.left, Kr = jt("reduce"), qr = Mt("reduce", { 1: 0 });
It({ target: "Array", proto: true, forced: !Kr || !qr || !Xr && fe > 79 && fe < 83 }, { reduce: function(t2) {
  return Vr(this, t2, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("flat");
var Qr, Jr, Zr, to$1 = !o(function() {
  return Object.isExtensible(Object.preventExtensions({}));
}), eo = e(function(t2) {
  var e2 = R.f, n2 = $("meta"), r2 = 0, o2 = Object.isExtensible || function() {
    return true;
  }, i2 = function(t3) {
    e2(t3, n2, { value: { objectID: "O" + ++r2, weakData: {} } });
  }, u2 = t2.exports = { REQUIRED: false, fastKey: function(t3, e3) {
    if (!h(t3))
      return "symbol" == typeof t3 ? t3 : ("string" == typeof t3 ? "S" : "P") + t3;
    if (!S(t3, n2)) {
      if (!o2(t3))
        return "F";
      if (!e3)
        return "E";
      i2(t3);
    }
    return t3[n2].objectID;
  }, getWeakData: function(t3, e3) {
    if (!S(t3, n2)) {
      if (!o2(t3))
        return true;
      if (!e3)
        return false;
      i2(t3);
    }
    return t3[n2].weakData;
  }, onFreeze: function(t3) {
    return to$1 && u2.REQUIRED && o2(t3) && !S(t3, n2) && i2(t3), t3;
  } };
  G[n2] = true;
}), no = function(t2, e2) {
  this.stopped = t2, this.result = e2;
}, ro = function(t2, e2, n2) {
  var r2, o2, i2, u2, a2, c2, l2, f2 = n2 && n2.that, s2 = !(!n2 || !n2.AS_ENTRIES), d2 = !(!n2 || !n2.IS_ITERATOR), v2 = !(!n2 || !n2.INTERRUPTED), p2 = lr(e2, f2, 1 + s2 + v2), g2 = function(t3) {
    return r2 && Cr(r2), new no(true, t3);
  }, h2 = function(t3) {
    return s2 ? (A(t3), v2 ? p2(t3[0], t3[1], g2) : p2(t3[0], t3[1])) : v2 ? p2(t3, g2) : p2(t3);
  };
  if (d2)
    r2 = t2;
  else {
    if ("function" != typeof (o2 = Nr(t2)))
      throw TypeError("Target is not iterable");
    if (Dr(o2)) {
      for (i2 = 0, u2 = at(t2.length); u2 > i2; i2++)
        if ((a2 = h2(t2[i2])) && a2 instanceof no)
          return a2;
      return new no(false);
    }
    r2 = o2.call(t2);
  }
  for (c2 = r2.next; !(l2 = c2.call(r2)).done; ) {
    try {
      a2 = h2(l2.value);
    } catch (t3) {
      throw Cr(r2), t3;
    }
    if ("object" == typeof a2 && a2 && a2 instanceof no)
      return a2;
  }
  return new no(false);
}, oo = function(t2, e2, n2) {
  if (!(t2 instanceof e2))
    throw TypeError("Incorrect " + (n2 ? n2 + " " : "") + "invocation");
  return t2;
}, io = R.f, uo = ne("toStringTag"), ao = function(t2, e2, n2) {
  t2 && !S(t2 = n2 ? t2 : t2.prototype, uo) && io(t2, uo, { configurable: true, value: e2 });
}, co = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var t2, e2 = false, n2 = {};
  try {
    (t2 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n2, []), e2 = n2 instanceof Array;
  } catch (t3) {
  }
  return function(n3, r2) {
    return A(n3), function(t3) {
      if (!h(t3) && null !== t3)
        throw TypeError("Can't set " + String(t3) + " as a prototype");
    }(r2), e2 ? t2.call(n3, r2) : n3.__proto__ = r2, n3;
  };
}() : void 0), lo = function(t2, e2, n2) {
  for (var r2 in e2)
    Z(t2, r2, e2[r2], n2);
  return t2;
}, fo = !o(function() {
  function t2() {
  }
  return t2.prototype.constructor = null, Object.getPrototypeOf(new t2()) !== t2.prototype;
}), so = Y("IE_PROTO"), vo = Object.prototype, po = fo ? Object.getPrototypeOf : function(t2) {
  return t2 = Kt(t2), S(t2, so) ? t2[so] : "function" == typeof t2.constructor && t2 instanceof t2.constructor ? t2.constructor.prototype : t2 instanceof Object ? vo : null;
}, go = ne("iterator"), ho = false;
[].keys && ("next" in (Zr = [].keys()) ? (Jr = po(po(Zr))) !== Object.prototype && (Qr = Jr) : ho = true), (null == Qr || o(function() {
  var t2 = {};
  return Qr[go].call(t2) !== t2;
})) && (Qr = {}), S(Qr, go) || I(Qr, go, function() {
  return this;
});
var yo = { IteratorPrototype: Qr, BUGGY_SAFARI_ITERATORS: ho }, mo = yo.IteratorPrototype, So = function() {
  return this;
}, xo = yo.IteratorPrototype, bo = yo.BUGGY_SAFARI_ITERATORS, Eo = ne("iterator"), wo = function() {
  return this;
}, Oo = function(t2, e2, n2, r2, o2, i2, u2) {
  !function(t3, e3, n3) {
    var r3 = e3 + " Iterator";
    t3.prototype = Sr(mo, { next: l(1, n3) }), ao(t3, r3, false), Pr[r3] = So;
  }(n2, e2, r2);
  var a2, c2, f2, s2 = function(t3) {
    if (t3 === o2 && h2)
      return h2;
    if (!bo && t3 in p2)
      return p2[t3];
    switch (t3) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n2(this, t3);
        };
    }
    return function() {
      return new n2(this);
    };
  }, d2 = e2 + " Iterator", v2 = false, p2 = t2.prototype, g2 = p2[Eo] || p2["@@iterator"] || o2 && p2[o2], h2 = !bo && g2 || s2(o2), y2 = "Array" == e2 && p2.entries || g2;
  if (y2 && (a2 = po(y2.call(new t2())), xo !== Object.prototype && a2.next && (po(a2) !== xo && (co ? co(a2, xo) : "function" != typeof a2[Eo] && I(a2, Eo, wo)), ao(a2, d2, true))), "values" == o2 && g2 && "values" !== g2.name && (v2 = true, h2 = function() {
    return g2.call(this);
  }), p2[Eo] !== h2 && I(p2, Eo, h2), Pr[e2] = h2, o2)
    if (c2 = { values: s2("values"), keys: i2 ? h2 : s2("keys"), entries: s2("entries") }, u2)
      for (f2 in c2)
        (bo || v2 || !(f2 in p2)) && Z(p2, f2, c2[f2]);
    else
      It({ target: e2, proto: true, forced: bo || v2 }, c2);
  return c2;
}, To = ne("species"), Ao = R.f, ko = eo.fastKey, Ro = J.set, Io = J.getterFor;
!function(t2, e2, n2) {
  var i2 = -1 !== t2.indexOf("Map"), u2 = -1 !== t2.indexOf("Weak"), a2 = i2 ? "set" : "add", c2 = r[t2], l2 = c2 && c2.prototype, f2 = c2, s2 = {}, d2 = function(t3) {
    var e3 = l2[t3];
    Z(l2, t3, "add" == t3 ? function(t4) {
      return e3.call(this, 0 === t4 ? 0 : t4), this;
    } : "delete" == t3 ? function(t4) {
      return !(u2 && !h(t4)) && e3.call(this, 0 === t4 ? 0 : t4);
    } : "get" == t3 ? function(t4) {
      return u2 && !h(t4) ? void 0 : e3.call(this, 0 === t4 ? 0 : t4);
    } : "has" == t3 ? function(t4) {
      return !(u2 && !h(t4)) && e3.call(this, 0 === t4 ? 0 : t4);
    } : function(t4, n3) {
      return e3.call(this, 0 === t4 ? 0 : t4, n3), this;
    });
  };
  if (kt(t2, "function" != typeof c2 || !(u2 || l2.forEach && !o(function() {
    new c2().entries().next();
  }))))
    f2 = n2.getConstructor(e2, t2, i2, a2), eo.REQUIRED = true;
  else if (kt(t2, true)) {
    var v2 = new f2(), p2 = v2[a2](u2 ? {} : -0, 1) != v2, g2 = o(function() {
      v2.has(1);
    }), y2 = Br(function(t3) {
      new c2(t3);
    }), m2 = !u2 && o(function() {
      for (var t3 = new c2(), e3 = 5; e3--; )
        t3[a2](e3, e3);
      return !t3.has(-0);
    });
    y2 || ((f2 = e2(function(e3, n3) {
      oo(e3, f2, t2);
      var r2 = function(t3, e4, n4) {
        var r3, o2;
        return co && "function" == typeof (r3 = e4.constructor) && r3 !== n4 && h(o2 = r3.prototype) && o2 !== n4.prototype && co(t3, o2), t3;
      }(new c2(), e3, f2);
      return null != n3 && ro(n3, r2[a2], { that: r2, AS_ENTRIES: i2 }), r2;
    })).prototype = l2, l2.constructor = f2), (g2 || m2) && (d2("delete"), d2("has"), i2 && d2("get")), (m2 || p2) && d2(a2), u2 && l2.clear && delete l2.clear;
  }
  s2[t2] = f2, It({ global: true, forced: f2 != c2 }, s2), ao(f2, t2), u2 || n2.setStrong(f2, t2, i2);
}("Set", function(t2) {
  return function() {
    return t2(this, arguments.length ? arguments[0] : void 0);
  };
}, { getConstructor: function(t2, e2, n2, r2) {
  var o2 = t2(function(t3, u3) {
    oo(t3, o2, e2), Ro(t3, { type: e2, index: Sr(null), first: void 0, last: void 0, size: 0 }), i || (t3.size = 0), null != u3 && ro(u3, t3[r2], { that: t3, AS_ENTRIES: n2 });
  }), u2 = Io(e2), a2 = function(t3, e3, n3) {
    var r3, o3, a3 = u2(t3), l2 = c2(t3, e3);
    return l2 ? l2.value = n3 : (a3.last = l2 = { index: o3 = ko(e3, true), key: e3, value: n3, previous: r3 = a3.last, next: void 0, removed: false }, a3.first || (a3.first = l2), r3 && (r3.next = l2), i ? a3.size++ : t3.size++, "F" !== o3 && (a3.index[o3] = l2)), t3;
  }, c2 = function(t3, e3) {
    var n3, r3 = u2(t3), o3 = ko(e3);
    if ("F" !== o3)
      return r3.index[o3];
    for (n3 = r3.first; n3; n3 = n3.next)
      if (n3.key == e3)
        return n3;
  };
  return lo(o2.prototype, { clear: function() {
    for (var t3 = u2(this), e3 = t3.index, n3 = t3.first; n3; )
      n3.removed = true, n3.previous && (n3.previous = n3.previous.next = void 0), delete e3[n3.index], n3 = n3.next;
    t3.first = t3.last = void 0, i ? t3.size = 0 : this.size = 0;
  }, delete: function(t3) {
    var e3 = this, n3 = u2(e3), r3 = c2(e3, t3);
    if (r3) {
      var o3 = r3.next, a3 = r3.previous;
      delete n3.index[r3.index], r3.removed = true, a3 && (a3.next = o3), o3 && (o3.previous = a3), n3.first == r3 && (n3.first = o3), n3.last == r3 && (n3.last = a3), i ? n3.size-- : e3.size--;
    }
    return !!r3;
  }, forEach: function(t3) {
    for (var e3, n3 = u2(this), r3 = lr(t3, arguments.length > 1 ? arguments[1] : void 0, 3); e3 = e3 ? e3.next : n3.first; )
      for (r3(e3.value, e3.key, this); e3 && e3.removed; )
        e3 = e3.previous;
  }, has: function(t3) {
    return !!c2(this, t3);
  } }), lo(o2.prototype, n2 ? { get: function(t3) {
    var e3 = c2(this, t3);
    return e3 && e3.value;
  }, set: function(t3, e3) {
    return a2(this, 0 === t3 ? 0 : t3, e3);
  } } : { add: function(t3) {
    return a2(this, t3 = 0 === t3 ? 0 : t3, t3);
  } }), i && Ao(o2.prototype, "size", { get: function() {
    return u2(this).size;
  } }), o2;
}, setStrong: function(t2, e2, n2) {
  var r2 = e2 + " Iterator", o2 = Io(e2), u2 = Io(r2);
  Oo(t2, e2, function(t3, e3) {
    Ro(this, { type: r2, target: t3, state: o2(t3), kind: e3, last: void 0 });
  }, function() {
    for (var t3 = u2(this), e3 = t3.kind, n3 = t3.last; n3 && n3.removed; )
      n3 = n3.previous;
    return t3.target && (t3.last = n3 = n3 ? n3.next : t3.state.first) ? "keys" == e3 ? { value: n3.key, done: false } : "values" == e3 ? { value: n3.value, done: false } : { value: [n3.key, n3.value], done: false } : (t3.target = void 0, { value: void 0, done: true });
  }, n2 ? "entries" : "values", !n2, true), function(t3) {
    var e3 = nt(t3), n3 = R.f;
    i && e3 && !e3[To] && n3(e3, To, { configurable: true, get: function() {
      return this;
    } });
  }(e2);
} });
var jo = Qe.charAt, Co = J.set, Lo = J.getterFor("String Iterator");
Oo(String, "String", function(t2) {
  Co(this, { type: "String Iterator", string: String(t2), index: 0 });
}, function() {
  var t2, e2 = Lo(this), n2 = e2.string, r2 = e2.index;
  return r2 >= n2.length ? { value: void 0, done: true } : (t2 = jo(n2, r2), e2.index += t2.length, { value: t2, done: false });
});
var Po = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, Mo = J.set, _o = J.getterFor("Array Iterator"), Do = Oo(Array, "Array", function(t2, e2) {
  Mo(this, { type: "Array Iterator", target: g(t2), index: 0, kind: e2 });
}, function() {
  var t2 = _o(this), e2 = t2.target, n2 = t2.kind, r2 = t2.index++;
  return !e2 || r2 >= e2.length ? (t2.target = void 0, { value: void 0, done: true }) : "keys" == n2 ? { value: r2, done: false } : "values" == n2 ? { value: e2[r2], done: false } : { value: [r2, e2[r2]], done: false };
}, "values");
Pr.Arguments = Pr.Array, Er("keys"), Er("values"), Er("entries");
var Uo = ne("iterator"), No = ne("toStringTag"), Fo = Do.values;
for (var Wo in Po) {
  var zo = r[Wo], $o = zo && zo.prototype;
  if ($o) {
    if ($o[Uo] !== Fo)
      try {
        I($o, Uo, Fo);
      } catch (t2) {
        $o[Uo] = Fo;
      }
    if ($o[No] || I($o, No, Wo), Po[Wo]) {
      for (var Bo in Do)
        if ($o[Bo] !== Do[Bo])
          try {
            I($o, Bo, Do[Bo]);
          } catch (t2) {
            $o[Bo] = Do[Bo];
          }
    }
  }
}
(function() {
  function t2() {
    Wt(this, t2);
  }
  return $t(t2, null, [{ key: "deduplicate", value: function(t3) {
    return Array.from(new Set(t3));
  } }, { key: "flat", value: function(e2) {
    return e2.reduce(function(e3, n2) {
      var r2 = Array.isArray(n2) ? t2.flat(n2) : n2;
      return e3.concat(r2);
    }, []);
  } }, { key: "find", value: function(t3, e2) {
    return t3.find(e2);
  } }, { key: "findIndex", value: function(t3, e2) {
    return t3.findIndex(e2);
  } }]), t2;
})();
(function() {
  function t2() {
    Wt(this, t2);
  }
  return $t(t2, null, [{ key: "today", value: function() {
    return new Date();
  } }]), t2;
})();
(function() {
  function t2() {
    Wt(this, t2);
  }
  return $t(t2, null, [{ key: "range", value: function(t3, e2, n2) {
    return Math.min(Math.max(t3, e2), n2);
  } }, { key: "clamp", value: function(t3, e2, n2) {
    return e2 < n2 ? t3 < e2 ? e2 : t3 > n2 ? n2 : t3 : t3 < n2 ? n2 : t3 > e2 ? e2 : t3;
  } }]), t2;
})();
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
var nativeObjectToString$1 = objectProto$a.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$9 = Object.prototype;
var nativeObjectToString = objectProto$9.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isArray$1 = Array.isArray;
var isArray$2 = isArray$1;
function isObject$1(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
function identity(value) {
  return value;
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject$1(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$8 = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto2) {
    if (!isObject$1(proto2)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto2);
    }
    object.prototype = proto2;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate$1 = baseCreate;
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function copyArray(source2, array) {
  var index2 = -1, length = source2.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source2[index2];
  }
  return array;
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var defineProperty$1 = defineProperty;
var baseSetToString = !defineProperty$1 ? identity : function(func, string) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
var setToString$1 = setToString;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$6.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source2, props2, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props2.length;
  while (++index2 < length) {
    var key = props2[index2];
    var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : void 0;
    if (newValue === void 0) {
      newValue = source2[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
var nativeMax = Math.max;
function overRest(func, start2, transform) {
  start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start2) {
  return setToString$1(overRest(func, start2, identity), func + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}
function isIterateeCall(value, index2, object) {
  if (!isObject$1(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
    return eq(object[index2], value);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source2 = sources[index2];
      if (source2) {
        assigner(object, source2, index2, customizer);
      }
    }
    return object;
  });
}
var objectProto$6 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$6;
  return value === proto2;
}
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$1 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$1;
}
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$5.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag$1 = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$2(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject$1(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function hashGet(key) {
  var data2 = this.__data__;
  if (nativeCreate$1) {
    var result = data2[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$2.call(data2, key) ? data2[key] : void 0;
}
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function hashHas(key) {
  var data2 = this.__data__;
  return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$1.call(data2, key);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  return index2 < 0 ? void 0 : data2[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  if (index2 < 0) {
    ++this.size;
    data2.push([key, value]);
  } else {
    data2[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$1, "Map");
var Map$2 = Map$1;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map2, key) {
  var data2 = map2.__data__;
  return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data2 = getMapData(this, key), size = data2.size;
  data2.set(key, value);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
var objectTag = "[object Object]";
var funcProto = Function.prototype, objectProto = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto2 = getPrototype$1(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data2 = this.__data__, result = data2["delete"](key);
  this.size = data2.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache) {
    var pairs = data2.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache(pairs);
  }
  data2.set(key, value);
  this.size = data2.size;
  return this;
}
function Stack(entries) {
  var data2 = this.__data__ = new ListCache(entries);
  this.size = data2.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var Uint8Array$1 = root$1.Uint8Array;
var Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props2 = keysFunc(object), length = props2.length;
    while (length--) {
      var key = props2[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
var baseFor$1 = baseFor;
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}
function baseMergeDeep(object, source2, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key), srcValue = safeGet(source2, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source2, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$2(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$2(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject$1(objValue) || isFunction$1(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue(object, key, newValue);
}
function baseMerge(object, source2, srcIndex, customizer, stack) {
  if (object === source2) {
    return;
  }
  baseFor$1(source2, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject$1(srcValue)) {
      baseMergeDeep(object, source2, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source2, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
var merge = createAssigner(function(object, source2, srcIndex) {
  baseMerge(object, source2, srcIndex);
});
var merge$1 = merge;
const calcAngle = (element2, event) => {
  const rect = element2.getBoundingClientRect();
  const originX = rect.left + rect.width / 2;
  const originY = rect.top + rect.height / 2;
  const x2 = Math.abs(originX - event.clientX);
  const y2 = Math.abs(originY - event.clientY);
  const z2 = Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2));
  const cos = y2 / z2;
  const rad = Math.acos(cos);
  let angle = Math.floor(180 / (Math.PI / rad));
  if (event.clientX > originX && event.clientY > originY) {
    angle = 180 - angle;
  }
  if (event.clientX == originX && event.clientY > originY) {
    angle = 180;
  }
  if (event.clientX > originX && event.clientY == originY) {
    angle = 90;
  }
  if (event.clientX < originX && event.clientY > originY) {
    angle = 180 + angle;
  }
  if (event.clientX < originX && event.clientY == originY) {
    angle = 270;
  }
  if (event.clientX < originX && event.clientY < originY) {
    angle = 360 - angle;
  }
  return angle;
};
let isDragging = false;
const triggerDragEvent = (element2, options) => {
  const moveFn = function(event) {
    var _a;
    (_a = options.drag) == null ? void 0 : _a.call(options, event);
  };
  const upFn = function(event) {
    var _a;
    document.removeEventListener("mousemove", moveFn, false);
    document.removeEventListener("mouseup", upFn, false);
    document.onselectstart = null;
    document.ondragstart = null;
    isDragging = false;
    (_a = options.end) == null ? void 0 : _a.call(options, event);
  };
  if (element2) {
    element2.addEventListener("mousedown", (event) => {
      var _a;
      if (isDragging)
        return;
      document.onselectstart = () => false;
      document.ondragstart = () => false;
      document.addEventListener("mousemove", moveFn, false);
      document.addEventListener("mouseup", upFn, false);
      isDragging = true;
      (_a = options.start) == null ? void 0 : _a.call(options, event);
    });
  }
  return;
};
const angleProps = {
  angle: {
    type: Number,
    default: 0
  },
  size: {
    type: Number,
    default: 16,
    validator: (value) => {
      return value >= 16;
    }
  },
  borderWidth: {
    type: Number,
    default: 1,
    validator: (value) => {
      return value >= 1;
    }
  },
  borderColor: {
    type: String,
    default: "#666"
  }
};
var Angle = defineComponent({
  name: "Angle",
  props: angleProps,
  emits: ["update:angle", "change"],
  setup(props2, {
    emit: emit2
  }) {
    const angleRef = ref(null);
    const rotate = ref(props2.angle);
    watch(() => props2.angle, (angle) => {
      rotate.value = angle;
    });
    const updateAngle = () => {
      let value = Number(rotate.value);
      if (!isNaN(value)) {
        value = value > 360 || value < 0 ? props2.angle : value;
        rotate.value = value === 360 ? 0 : value;
        emit2("update:angle", rotate.value);
        emit2("change", rotate.value);
      }
    };
    const getStyle = computed(() => {
      return {
        width: props2.size + "px",
        height: props2.size + "px",
        borderWidth: props2.borderWidth + "px",
        borderColor: props2.borderColor,
        transform: `rotate(${rotate.value}deg)`
      };
    });
    const handleDrag = (event) => {
      if (angleRef.value) {
        rotate.value = calcAngle(angleRef.value, event) % 360;
        updateAngle();
      }
    };
    onMounted(() => {
      const dragConfig = {
        drag: (event) => {
          handleDrag(event);
        },
        end: (event) => {
          handleDrag(event);
        }
      };
      if (angleRef.value) {
        triggerDragEvent(angleRef.value, dragConfig);
      }
    });
    return () => {
      return createVNode("div", {
        "class": "bee-angle"
      }, [createVNode("div", {
        "class": "bee-angle__round",
        "ref": angleRef,
        "style": getStyle.value
      }, null)]);
    };
  }
});
var style = "";
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max$1 = Math.max;
var min$1 = Math.min;
var round$1 = Math.round;
function getBoundingClientRect(element2, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  var rect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (isHTMLElement(element2) && includeScale) {
    var offsetHeight = element2.offsetHeight;
    var offsetWidth = element2.offsetWidth;
    if (offsetWidth > 0) {
      scaleX = round$1(rect.width) / offsetWidth || 1;
    }
    if (offsetHeight > 0) {
      scaleY = round$1(rect.height) / offsetHeight || 1;
    }
  }
  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element2) {
  return getWindow(element2).getComputedStyle(element2);
}
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
}
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement(element2);
}
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || getComputedStyle$1(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
  var isIE = navigator.userAgent.indexOf("Trident") !== -1;
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle$1(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle$1(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min2, value, max2) {
  return max$1(min2, min$1(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x2 = _ref.x, y2 = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x2 * dpr) / dpr || 0,
    y: round$1(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance2 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance2.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance2.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance2.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance2.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn2() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}
function getViewportRect(element2) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element2),
    y: y2
  };
}
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle$1(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element2) {
  var rect = getBoundingClientRect(element2);
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset$1(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data2 = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data2[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name] = data2;
}
var offset$2 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset$1
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data2 = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data2[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data2[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data2;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element2.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn3());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance2 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance2.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance: instance2
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance2.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy2() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance2;
    }
    instance2.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance: instance2,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance2;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$2, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var GradientParser = GradientParser || {};
GradientParser.stringify = function() {
  var visitor = {
    "visit_linear-gradient": function(node) {
      return visitor.visit_gradient(node);
    },
    "visit_repeating-linear-gradient": function(node) {
      return visitor.visit_gradient(node);
    },
    "visit_radial-gradient": function(node) {
      return visitor.visit_gradient(node);
    },
    "visit_repeating-radial-gradient": function(node) {
      return visitor.visit_gradient(node);
    },
    "visit_gradient": function(node) {
      var orientation = visitor.visit(node.orientation);
      if (orientation) {
        orientation += ", ";
      }
      return node.type + "(" + orientation + visitor.visit(node.colorStops) + ")";
    },
    "visit_shape": function(node) {
      var result = node.value, at2 = visitor.visit(node.at), style2 = visitor.visit(node.style);
      if (style2) {
        result += " " + style2;
      }
      if (at2) {
        result += " at " + at2;
      }
      return result;
    },
    "visit_default-radial": function(node) {
      var result = "", at2 = visitor.visit(node.at);
      if (at2) {
        result += at2;
      }
      return result;
    },
    "visit_extent-keyword": function(node) {
      var result = node.value, at2 = visitor.visit(node.at);
      if (at2) {
        result += " at " + at2;
      }
      return result;
    },
    "visit_position-keyword": function(node) {
      return node.value;
    },
    "visit_position": function(node) {
      return visitor.visit(node.value.x) + " " + visitor.visit(node.value.y);
    },
    "visit_%": function(node) {
      return node.value + "%";
    },
    "visit_em": function(node) {
      return node.value + "em";
    },
    "visit_px": function(node) {
      return node.value + "px";
    },
    "visit_literal": function(node) {
      return visitor.visit_color(node.value, node);
    },
    "visit_hex": function(node) {
      return visitor.visit_color("#" + node.value, node);
    },
    "visit_rgb": function(node) {
      return visitor.visit_color("rgb(" + node.value.join(", ") + ")", node);
    },
    "visit_rgba": function(node) {
      return visitor.visit_color("rgba(" + node.value.join(", ") + ")", node);
    },
    "visit_color": function(resultColor, node) {
      var result = resultColor, length = visitor.visit(node.length);
      if (length) {
        result += " " + length;
      }
      return result;
    },
    "visit_angular": function(node) {
      return node.value + "deg";
    },
    "visit_directional": function(node) {
      return "to " + node.value;
    },
    "visit_array": function(elements) {
      var result = "", size = elements.length;
      elements.forEach(function(element2, i2) {
        result += visitor.visit(element2);
        if (i2 < size - 1) {
          result += ", ";
        }
      });
      return result;
    },
    "visit": function(element2) {
      if (!element2) {
        return "";
      }
      var result = "";
      if (element2 instanceof Array) {
        return visitor.visit_array(element2, result);
      } else if (element2.type) {
        var nodeVisitor = visitor["visit_" + element2.type];
        if (nodeVisitor) {
          return nodeVisitor(element2);
        } else {
          throw Error("Missing visitor visit_" + element2.type);
        }
      } else {
        throw Error("Invalid node.");
      }
    }
  };
  return function(root2) {
    return visitor.visit(root2);
  };
}();
var GradientParser = GradientParser || {};
GradientParser.parse = function() {
  var tokens2 = {
    linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
    repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
    radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
    repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  var input = "";
  function error(msg) {
    var err = new Error(input + ": " + msg);
    err.source = input;
    throw err;
  }
  function getAST() {
    var ast = matchListDefinitions();
    if (input.length > 0) {
      error("Invalid input not EOF");
    }
    return ast;
  }
  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }
  function matchDefinition() {
    return matchGradient(
      "linear-gradient",
      tokens2.linearGradient,
      matchLinearOrientation
    ) || matchGradient(
      "repeating-linear-gradient",
      tokens2.repeatingLinearGradient,
      matchLinearOrientation
    ) || matchGradient(
      "radial-gradient",
      tokens2.radialGradient,
      matchListRadialOrientations
    ) || matchGradient(
      "repeating-radial-gradient",
      tokens2.repeatingRadialGradient,
      matchListRadialOrientations
    );
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function(captures) {
      var orientation = orientationMatcher();
      if (orientation) {
        if (!scan(tokens2.comma)) {
          error("Missing comma before color stops");
        }
      }
      return {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchCall(pattern, callback) {
    var captures = scan(pattern);
    if (captures) {
      if (!scan(tokens2.startCall)) {
        error("Missing (");
      }
      var result = callback(captures);
      if (!scan(tokens2.endCall)) {
        error("Missing )");
      }
      return result;
    }
  }
  function matchLinearOrientation() {
    return matchSideOrCorner() || matchAngle();
  }
  function matchSideOrCorner() {
    return match("directional", tokens2.sideOrCorner, 1);
  }
  function matchAngle() {
    return match("angular", tokens2.angleValue, 1);
  }
  function matchListRadialOrientations() {
    var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);
      lookaheadCache = input;
      if (scan(tokens2.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input = lookaheadCache;
        }
      }
    }
    return radialOrientations;
  }
  function matchRadialOrientation() {
    var radialType = matchCircle() || matchEllipse();
    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      var extent = matchExtentKeyword();
      if (extent) {
        radialType = extent;
        var positionAt = matchAtPosition();
        if (positionAt) {
          radialType.at = positionAt;
        }
      } else {
        var defaultPosition = matchPositioning();
        if (defaultPosition) {
          radialType = {
            type: "default-radial",
            at: defaultPosition
          };
        }
      }
    }
    return radialType;
  }
  function matchCircle() {
    var circle = match("shape", /^(circle)/i, 0);
    if (circle) {
      circle.style = matchLength() || matchExtentKeyword();
    }
    return circle;
  }
  function matchEllipse() {
    var ellipse = match("shape", /^(ellipse)/i, 0);
    if (ellipse) {
      ellipse.style = matchDistance() || matchExtentKeyword();
    }
    return ellipse;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens2.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      var positioning = matchPositioning();
      if (!positioning) {
        error("Missing positioning value");
      }
      return positioning;
    }
  }
  function matchPositioning() {
    var location = matchCoordinates();
    if (location.x || location.y) {
      return {
        type: "position",
        value: location
      };
    }
  }
  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }
  function matchListing(matcher) {
    var captures = matcher(), result = [];
    if (captures) {
      result.push(captures);
      while (scan(tokens2.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error("One extra comma");
        }
      }
    }
    return result;
  }
  function matchColorStop() {
    var color = matchColor();
    if (!color) {
      error("Expected color definition");
    }
    color.length = matchDistance();
    return color;
  }
  function matchColor() {
    return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
  }
  function matchLiteralColor() {
    return match("literal", tokens2.literalColor, 0);
  }
  function matchHexColor() {
    return match("hex", tokens2.hexColor, 1);
  }
  function matchRGBColor() {
    return matchCall(tokens2.rgbColor, function() {
      return {
        type: "rgb",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchRGBAColor() {
    return matchCall(tokens2.rgbaColor, function() {
      return {
        type: "rgba",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchNumber() {
    return scan(tokens2.number)[1];
  }
  function matchDistance() {
    return match("%", tokens2.percentageValue, 1) || matchPositionKeyword() || matchLength();
  }
  function matchPositionKeyword() {
    return match("position-keyword", tokens2.positionKeywords, 1);
  }
  function matchLength() {
    return match("px", tokens2.pixelValue, 1) || match("em", tokens2.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    var captures = scan(pattern);
    if (captures) {
      return {
        type,
        value: captures[captureIndex]
      };
    }
  }
  function scan(regexp) {
    var captures, blankCaptures;
    blankCaptures = /^[\n\r\t\s]+/.exec(input);
    if (blankCaptures) {
      consume(blankCaptures[0].length);
    }
    captures = regexp.exec(input);
    if (captures) {
      consume(captures[0].length);
    }
    return captures;
  }
  function consume(size) {
    input = input.substr(size);
  }
  return function(code) {
    input = code.toString();
    return getAST();
  };
}();
var parse = GradientParser.parse;
var stringify = GradientParser.stringify;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const double = (num) => {
  return Math.round(num * 100) / 100;
};
class Color {
  constructor(input) {
    __publicField(this, "instance");
    __publicField(this, "alphaValue", 0);
    __publicField(this, "redValue", 0);
    __publicField(this, "greenValue", 0);
    __publicField(this, "blueValue", 0);
    __publicField(this, "hueValue", 0);
    __publicField(this, "saturationValue", 0);
    __publicField(this, "brightnessValue", 0);
    __publicField(this, "hslSaturationValue", 0);
    __publicField(this, "lightnessValue", 0);
    __publicField(this, "initAlpha", () => {
      const initAlpha = this.instance.getAlpha();
      this.alphaValue = Math.min(1, initAlpha) * 100;
    });
    __publicField(this, "initLightness", () => {
      const { s: s2, l: l2 } = this.instance.toHsl();
      this.hslSaturationValue = double(s2);
      this.lightnessValue = double(l2);
    });
    __publicField(this, "initRgb", () => {
      const { r: r2, g: g2, b: b2 } = this.instance.toRgb();
      this.redValue = double(r2);
      this.greenValue = double(g2);
      this.blueValue = double(b2);
    });
    __publicField(this, "initHsb", () => {
      const { h: h2, s: s2, v: v2 } = this.instance.toHsv();
      this.hueValue = Math.min(360, Math.ceil(h2));
      this.saturationValue = double(s2);
      this.brightnessValue = double(v2);
    });
    __publicField(this, "toHexString", () => {
      return this.instance.toHexString();
    });
    __publicField(this, "toRgbString", () => {
      return this.instance.toRgbString();
    });
    this.instance = tinycolor(input);
    this.initRgb();
    this.initHsb();
    this.initLightness();
    this.initAlpha();
  }
  toString(format2) {
    return this.instance.toString(format2);
  }
  get hex() {
    return this.instance.toHex();
  }
  set hex(hexString) {
    this.instance = tinycolor(hexString);
    this.initHsb();
    this.initRgb();
    this.initAlpha();
    this.initLightness();
  }
  set hue(value) {
    if (this.saturation === 0 && this.brightness === 0) {
      this.saturationValue = 1;
      this.brightnessValue = 1;
    }
    this.instance = tinycolor({
      h: double(value),
      s: this.saturation,
      v: this.brightness,
      a: this.alphaValue / 100
    });
    this.initRgb();
    this.initLightness();
    this.hueValue = double(value);
  }
  get hue() {
    return this.hueValue;
  }
  set saturation(value) {
    this.instance = tinycolor({
      h: this.hue,
      s: double(value),
      v: this.brightness,
      a: this.alphaValue / 100
    });
    this.initRgb();
    this.initLightness();
    this.saturationValue = double(value);
  }
  get saturation() {
    return this.saturationValue;
  }
  set brightness(value) {
    this.instance = tinycolor({
      h: this.hue,
      s: this.saturation,
      v: double(value),
      a: this.alphaValue / 100
    });
    this.initRgb();
    this.initLightness();
    this.brightnessValue = double(value);
  }
  get brightness() {
    return this.brightnessValue;
  }
  set lightness(value) {
    this.instance = tinycolor({
      h: this.hue,
      s: this.hslSaturationValue,
      l: double(value),
      a: this.alphaValue / 100
    });
    this.initRgb();
    this.initHsb();
    this.lightnessValue = double(value);
  }
  get lightness() {
    return this.lightnessValue;
  }
  set red(value) {
    const rgb = this.instance.toRgb();
    this.instance = tinycolor(__spreadProps(__spreadValues({}, rgb), {
      r: double(value),
      a: this.alphaValue / 100
    }));
    this.initHsb();
    this.initLightness();
    this.redValue = double(value);
  }
  get red() {
    return this.redValue;
  }
  set green(value) {
    const rgb = this.instance.toRgb();
    this.instance = tinycolor(__spreadProps(__spreadValues({}, rgb), {
      g: double(value),
      a: this.alphaValue / 100
    }));
    this.initHsb();
    this.initLightness();
    this.greenValue = double(value);
  }
  get green() {
    return this.greenValue;
  }
  set blue(value) {
    const rgb = this.instance.toRgb();
    this.instance = tinycolor(__spreadProps(__spreadValues({}, rgb), {
      b: double(value),
      a: this.alphaValue / 100
    }));
    this.initHsb();
    this.initLightness();
    this.blueValue = double(value);
  }
  get blue() {
    return this.blueValue;
  }
  set alpha(value) {
    this.instance.setAlpha(value / 100);
    this.alphaValue = value;
  }
  get alpha() {
    return this.alphaValue;
  }
  get RGB() {
    return [this.red, this.green, this.blue, this.alpha / 100];
  }
  get HSB() {
    return [this.hue, this.saturation, this.brightness, this.alpha / 100];
  }
  get HSL() {
    return [this.hue, this.hslSaturationValue, this.lightness, this.alpha / 100];
  }
}
function rgbaColor(r2, g2, b2, a2) {
  return `rgba(${[r2, g2, b2, a2 / 100].join(",")})`;
}
const clamp = (value, min2, max2) => {
  return min2 < max2 ? value < min2 ? min2 : value > max2 ? max2 : value : value < max2 ? max2 : value > min2 ? min2 : value;
};
const HistoryColorKey = "color-history";
const MAX_STORAGE_LENGTH = 8;
var _export_sfc = (sfc, props2) => {
  for (const [key, val] of props2) {
    sfc[key] = val;
  }
  return sfc;
};
const _sfc_main$b$1 = defineComponent({
  name: "Alpha",
  props: {
    color: C$1.instanceOf(Color),
    size: C$1.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(props2, { emit: emit2 }) {
    const barElement = ref(null);
    const cursorElement = ref(null);
    let color = props2.color || new Color();
    const state = reactive({
      red: color.red,
      green: color.green,
      blue: color.blue,
      alpha: color.alpha
    });
    watch(() => props2.color, (value) => {
      if (value) {
        color = value;
        merge$1(state, {
          red: value.red,
          green: value.green,
          blue: value.blue,
          alpha: value.alpha
        });
      }
    }, { deep: true });
    const getBackgroundStyle = computed(() => {
      const startColor = rgbaColor(state.red, state.green, state.blue, 0);
      const endColor = rgbaColor(state.red, state.green, state.blue, 100);
      return {
        background: `linear-gradient(to right, ${startColor} , ${endColor})`
      };
    });
    const getCursorLeft = () => {
      if (barElement.value && cursorElement.value) {
        const alpha = state.alpha / 100;
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        return Math.round(alpha * (rect.width - offsetWidth) + offsetWidth / 2);
      }
      return 0;
    };
    const getCursorStyle = computed(() => {
      const left2 = getCursorLeft();
      return {
        left: left2 + "px",
        top: 0
      };
    });
    const onClickSider = (event) => {
      const target = event.target;
      if (target !== barElement.value) {
        onMoveBar(event);
      }
    };
    const onMoveBar = (event) => {
      event.stopPropagation();
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        let left2 = event.clientX - rect.left;
        left2 = Math.max(offsetWidth / 2, left2);
        left2 = Math.min(left2, rect.width - offsetWidth / 2);
        const alpha = Math.round((left2 - offsetWidth / 2) / (rect.width - offsetWidth) * 100);
        color.alpha = alpha;
        state.alpha = alpha;
        emit2("change", alpha);
      }
    };
    tryOnMounted(() => {
      const dragConfig = {
        drag: (event) => {
          onMoveBar(event);
        },
        end: (event) => {
          onMoveBar(event);
        }
      };
      if (barElement.value && cursorElement.value) {
        Vn.triggerDragEvent(barElement.value, dragConfig);
      }
    });
    return { barElement, cursorElement, getCursorStyle, getBackgroundStyle, onClickSider };
  }
});
const _withScopeId$5$1 = (n2) => (pushScopeId("data-v-18925ba6"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$a$1 = /* @__PURE__ */ _withScopeId$5$1(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-alpha-slider__bar-handle" }, null, -1));
const _hoisted_2$a$1 = [
  _hoisted_1$a$1
];
function _sfc_render$b$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-alpha-slider", "transparent", { "small-slider": _ctx.size === "small" }])
  }, [
    createElementVNode("div", {
      ref: "barElement",
      class: "vc-alpha-slider__bar",
      style: normalizeStyle(_ctx.getBackgroundStyle),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickSider && _ctx.onClickSider(...args))
    }, [
      createElementVNode("div", {
        class: normalizeClass(["vc-alpha-slider__bar-pointer", { "small-bar": _ctx.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(_ctx.getCursorStyle)
      }, _hoisted_2$a$1, 6)
    ], 4)
  ], 2);
}
var Alpha = /* @__PURE__ */ _export_sfc(_sfc_main$b$1, [["render", _sfc_render$b$1], ["__scopeId", "data-v-18925ba6"]]);
const defaultColors = [
  [
    "#fcc02e",
    "#f67c01",
    "#e64a19",
    "#d81b43",
    "#8e24aa",
    "#512da7",
    "#1f87e8",
    "#008781",
    "#05a045"
  ],
  [
    "#fed835",
    "#fb8c00",
    "#f5511e",
    "#eb1d4e",
    "#9c28b1",
    "#5d35b0",
    "#2097f3",
    "#029688",
    "#4cb050"
  ],
  [
    "#ffeb3c",
    "#ffa727",
    "#fe5722",
    "#eb4165",
    "#aa47bc",
    "#673bb7",
    "#42a5f6",
    "#26a59a",
    "#83c683"
  ],
  [
    "#fff176",
    "#ffb74e",
    "#ff8a66",
    "#f1627e",
    "#b968c7",
    "#7986cc",
    "#64b5f6",
    "#80cbc4",
    "#a5d6a7"
  ],
  [
    "#fff59c",
    "#ffcc80",
    "#ffab91",
    "#fb879e",
    "#cf93d9",
    "#9ea8db",
    "#90caf8",
    "#b2dfdc",
    "#c8e6ca"
  ],
  [
    "transparent",
    "#ffffff",
    "#dedede",
    "#a9a9a9",
    "#4b4b4b",
    "#353535",
    "#212121",
    "#000000",
    "advance"
  ]
];
const _sfc_main$a$1 = defineComponent({
  name: "Palette",
  emits: ["change"],
  setup(_props, { emit: emit2 }) {
    const computedBgStyle = (color) => {
      if (color === "transparent") {
        return color;
      }
      if (color === "advance") {
        return {};
      }
      return { background: tinycolor(color).toRgbString() };
    };
    const onColorChange = (color) => {
      emit2("change", color);
    };
    return { palettes: defaultColors, computedBgStyle, onColorChange };
  }
});
const _hoisted_1$9$1 = { class: "vc-compact" };
const _hoisted_2$9$1 = ["onClick"];
function _sfc_render$a$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$9$1, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.palettes, (v2, i2) => {
      return openBlock(), createElementBlock("div", {
        key: i2,
        class: "vc-compact__row"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(v2, (v1, k2) => {
          return openBlock(), createElementBlock("div", {
            key: k2,
            class: "vc-compact__color-cube--wrap",
            onClick: ($event) => _ctx.onColorChange(v1)
          }, [
            createElementVNode("div", {
              class: normalizeClass([
                "vc-compact__color_cube",
                {
                  advance: v1 === "advance",
                  transparent: v1 === "transparent"
                }
              ]),
              style: normalizeStyle(_ctx.computedBgStyle(v1))
            }, null, 6)
          ], 8, _hoisted_2$9$1);
        }), 128))
      ]);
    }), 128))
  ]);
}
var Palette = /* @__PURE__ */ _export_sfc(_sfc_main$a$1, [["render", _sfc_render$a$1], ["__scopeId", "data-v-b969fd48"]]);
const _sfc_main$9$1 = defineComponent({
  name: "Board",
  props: {
    color: C$1.instanceOf(Color),
    round: C$1.bool.def(false),
    hide: C$1.bool.def(true)
  },
  emits: ["change"],
  setup(props2, { emit: emit2 }) {
    var _a, _b, _c;
    const instance2 = getCurrentInstance();
    const hueHsv = {
      h: ((_a = props2.color) == null ? void 0 : _a.hue) || 0,
      s: 1,
      v: 1
    };
    const hueColor = new Color(hueHsv).toHexString();
    const state = reactive({
      hueColor,
      saturation: ((_b = props2.color) == null ? void 0 : _b.saturation) || 0,
      brightness: ((_c = props2.color) == null ? void 0 : _c.brightness) || 0
    });
    const cursorTop = ref(0);
    const cursorLeft = ref(0);
    const cursorElement = ref();
    const boardElement = ref();
    const getCursorStyle = computed(() => {
      return {
        top: cursorTop.value + "px",
        left: cursorLeft.value + "px"
      };
    });
    const updatePosition = () => {
      if (instance2) {
        const el = instance2.vnode.el;
        cursorLeft.value = state.saturation * (el == null ? void 0 : el.clientWidth);
        cursorTop.value = (1 - state.brightness) * (el == null ? void 0 : el.clientHeight);
      }
    };
    const onClickBoard = (event) => {
      const target = event.target;
      if (target !== boardElement.value) {
        handleDrag(event);
      }
    };
    const handleDrag = (event) => {
      if (instance2) {
        const el = instance2.vnode.el;
        const rect = el == null ? void 0 : el.getBoundingClientRect();
        let left2 = event.clientX - rect.left;
        let top2 = event.clientY - rect.top;
        left2 = clamp(left2, 0, rect.width);
        top2 = clamp(top2, 0, rect.height);
        const saturation = left2 / rect.width;
        const bright = clamp(-(top2 / rect.height) + 1, 0, 1);
        cursorLeft.value = left2;
        cursorTop.value = top2;
        state.saturation = saturation;
        state.brightness = bright;
        emit2("change", saturation, bright);
      }
    };
    tryOnMounted(() => {
      if (instance2 && instance2.vnode.el && cursorElement.value) {
        Vn.triggerDragEvent(cursorElement.value, {
          drag: (event) => {
            handleDrag(event);
          },
          end: (event) => {
            handleDrag(event);
          }
        });
        updatePosition();
      }
    });
    whenever(() => props2.color, (value) => {
      merge$1(state, {
        hueColor: new Color({ h: value.hue, s: 1, v: 1 }).toHexString(),
        saturation: value.saturation,
        brightness: value.brightness
      });
      updatePosition();
    }, { deep: true });
    return { state, cursorElement, getCursorStyle, onClickBoard };
  }
});
const _withScopeId$4$1 = (n2) => (pushScopeId("data-v-63803390"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$8$1 = /* @__PURE__ */ _withScopeId$4$1(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-saturation__white" }, null, -1));
const _hoisted_2$8$1 = /* @__PURE__ */ _withScopeId$4$1(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-saturation__black" }, null, -1));
const _hoisted_3$6$1 = /* @__PURE__ */ _withScopeId$4$1(() => /* @__PURE__ */ createElementVNode("div", null, null, -1));
const _hoisted_4$5$1 = [
  _hoisted_3$6$1
];
function _sfc_render$9$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "boardElement",
    class: normalizeClass(["vc-saturation", { "vc-saturation__chrome": _ctx.round, "vc-saturation__hidden": _ctx.hide }]),
    style: normalizeStyle({ backgroundColor: _ctx.state.hueColor }),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickBoard && _ctx.onClickBoard(...args))
  }, [
    _hoisted_1$8$1,
    _hoisted_2$8$1,
    createElementVNode("div", {
      class: "vc-saturation__cursor",
      ref: "cursorElement",
      style: normalizeStyle(_ctx.getCursorStyle)
    }, _hoisted_4$5$1, 4)
  ], 6);
}
var Board = /* @__PURE__ */ _export_sfc(_sfc_main$9$1, [["render", _sfc_render$9$1], ["__scopeId", "data-v-63803390"]]);
const _sfc_main$8$1 = defineComponent({
  name: "Hue",
  props: {
    color: C$1.instanceOf(Color),
    size: C$1.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(props2, { emit: emit2 }) {
    const barElement = ref(null);
    const cursorElement = ref(null);
    let color = props2.color || new Color();
    const state = reactive({
      hue: color.hue || 0
    });
    watch(() => props2.color, (value) => {
      if (value) {
        color = value;
        merge$1(state, { hue: color.hue });
      }
    }, { deep: true });
    const getCursorLeft = () => {
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        if (state.hue === 360) {
          return rect.width - offsetWidth / 2;
        }
        return state.hue % 360 * (rect.width - offsetWidth) / 360 + offsetWidth / 2;
      }
      return 0;
    };
    const getCursorStyle = computed(() => {
      const left2 = getCursorLeft();
      return {
        left: left2 + "px",
        top: 0
      };
    });
    const onClickSider = (event) => {
      const target = event.target;
      if (target !== barElement.value) {
        onMoveBar(event);
      }
    };
    const onMoveBar = (event) => {
      event.stopPropagation();
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        let left2 = event.clientX - rect.left;
        left2 = Math.min(left2, rect.width - offsetWidth / 2);
        left2 = Math.max(offsetWidth / 2, left2);
        const hue = Math.round((left2 - offsetWidth / 2) / (rect.width - offsetWidth) * 360);
        color.hue = hue;
        state.hue = hue;
        emit2("change", hue);
      }
    };
    tryOnMounted(() => {
      const dragConfig = {
        drag: (event) => {
          onMoveBar(event);
        },
        end: (event) => {
          onMoveBar(event);
        }
      };
      if (barElement.value && cursorElement.value) {
        Vn.triggerDragEvent(barElement.value, dragConfig);
      }
    });
    return { barElement, cursorElement, getCursorStyle, onClickSider };
  }
});
const _withScopeId$3$1 = (n2) => (pushScopeId("data-v-5c4cae5b"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$7$1 = /* @__PURE__ */ _withScopeId$3$1(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-hue-slider__bar-handle" }, null, -1));
const _hoisted_2$7$1 = [
  _hoisted_1$7$1
];
function _sfc_render$8$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-hue-slider", { "small-slider": _ctx.size === "small" }])
  }, [
    createElementVNode("div", {
      ref: "barElement",
      class: "vc-hue-slider__bar",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickSider && _ctx.onClickSider(...args))
    }, [
      createElementVNode("div", {
        class: normalizeClass(["vc-hue-slider__bar-pointer", { "small-bar": _ctx.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(_ctx.getCursorStyle)
      }, _hoisted_2$7$1, 6)
    ], 512)
  ], 2);
}
var Hue = /* @__PURE__ */ _export_sfc(_sfc_main$8$1, [["render", _sfc_render$8$1], ["__scopeId", "data-v-5c4cae5b"]]);
const _sfc_main$7$1 = defineComponent({
  name: "Lightness",
  props: {
    color: C$1.instanceOf(Color),
    size: C$1.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(props2, { emit: emit2 }) {
    const barElement = ref(null);
    const cursorElement = ref(null);
    let color = props2.color || new Color();
    const [h2, s2, l2] = color.HSL;
    const state = reactive({
      hue: h2,
      saturation: s2,
      lightness: l2
    });
    watch(() => props2.color, (value) => {
      if (value) {
        color = value;
        const [hue, saturation, lightness] = color.HSL;
        merge$1(state, {
          hue,
          saturation,
          lightness
        });
      }
    }, { deep: true });
    const getBackgroundStyle = computed(() => {
      const color1 = tinycolor({
        h: state.hue,
        s: state.saturation,
        l: 0.8
      }).toPercentageRgbString();
      const color2 = tinycolor({
        h: state.hue,
        s: state.saturation,
        l: 0.6
      }).toPercentageRgbString();
      const color3 = tinycolor({
        h: state.hue,
        s: state.saturation,
        l: 0.4
      }).toPercentageRgbString();
      const color4 = tinycolor({
        h: state.hue,
        s: state.saturation,
        l: 0.2
      }).toPercentageRgbString();
      return {
        background: [
          `-webkit-linear-gradient(left, rgb(255, 255, 255), ${color1}, ${color2}, ${color3}, ${color4}, rgb(0, 0, 0))`,
          `-moz-linear-gradient(left, rgb(255, 255, 255), ${color1}, ${color2}, ${color3}, ${color4}, rgb(0, 0, 0))`,
          `-ms-linear-gradient(left, rgb(255, 255, 255), ${color1}, ${color2}, ${color3}, ${color4}, rgb(0, 0, 0))`
        ]
      };
    });
    const getCursorLeft = () => {
      if (barElement.value && cursorElement.value) {
        const lightness = state.lightness;
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        return (1 - lightness) * (rect.width - offsetWidth) + offsetWidth / 2;
      }
      return 0;
    };
    const getCursorStyle = computed(() => {
      const left2 = getCursorLeft();
      return {
        left: left2 + "px",
        top: 0
      };
    });
    const onClickSider = (event) => {
      const target = event.target;
      if (target !== barElement.value) {
        onMoveBar(event);
      }
    };
    const onMoveBar = (event) => {
      event.stopPropagation();
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        let left2 = event.clientX - rect.left;
        left2 = Math.max(offsetWidth / 2, left2);
        left2 = Math.min(left2, rect.width - offsetWidth / 2);
        const light = 1 - (left2 - offsetWidth / 2) / (rect.width - offsetWidth);
        color.lightness = light;
        emit2("change", light);
      }
    };
    tryOnMounted(() => {
      const dragConfig = {
        drag: (event) => {
          onMoveBar(event);
        },
        end: (event) => {
          onMoveBar(event);
        }
      };
      if (barElement.value && cursorElement.value) {
        Vn.triggerDragEvent(barElement.value, dragConfig);
      }
    });
    return { barElement, cursorElement, getCursorStyle, getBackgroundStyle, onClickSider };
  }
});
const _withScopeId$2$1 = (n2) => (pushScopeId("data-v-6156acb7"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$6$1 = /* @__PURE__ */ _withScopeId$2$1(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-lightness-slider__bar-handle" }, null, -1));
const _hoisted_2$6$1 = [
  _hoisted_1$6$1
];
function _sfc_render$7$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-lightness-slider", { "small-slider": _ctx.size === "small" }])
  }, [
    createElementVNode("div", {
      ref: "barElement",
      class: "vc-lightness-slider__bar",
      style: normalizeStyle(_ctx.getBackgroundStyle),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickSider && _ctx.onClickSider(...args))
    }, [
      createElementVNode("div", {
        class: normalizeClass(["vc-lightness-slider__bar-pointer", { "small-bar": _ctx.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(_ctx.getCursorStyle)
      }, _hoisted_2$6$1, 6)
    ], 4)
  ], 2);
}
var Lightness = /* @__PURE__ */ _export_sfc(_sfc_main$7$1, [["render", _sfc_render$7$1], ["__scopeId", "data-v-6156acb7"]]);
const _sfc_main$6$1 = defineComponent({
  name: "History",
  props: {
    colors: C$1.arrayOf(String).def(() => []),
    round: C$1.bool.def(false)
  },
  emits: ["change"],
  setup(_props, { emit: emit2 }) {
    const onColorSelect = (v2) => {
      emit2("change", v2);
    };
    return { onColorSelect };
  }
});
const _hoisted_1$5$1 = {
  key: 0,
  class: "vc-colorPicker__record"
};
const _hoisted_2$5$1 = { class: "color-list" };
const _hoisted_3$5$1 = ["onClick"];
function _sfc_render$6$1(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.colors && _ctx.colors.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$5$1, [
    createElementVNode("div", _hoisted_2$5$1, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.colors, (v2, i2) => {
        return openBlock(), createElementBlock("div", {
          key: i2,
          class: normalizeClass(["color-item", "transparent", { "color-item__round": _ctx.round }]),
          onClick: ($event) => _ctx.onColorSelect(v2)
        }, [
          createElementVNode("div", {
            class: "color-item__display",
            style: normalizeStyle({ backgroundColor: v2 })
          }, null, 4)
        ], 10, _hoisted_3$5$1);
      }), 128))
    ])
  ])) : createCommentVNode("", true);
}
var History = /* @__PURE__ */ _export_sfc(_sfc_main$6$1, [["render", _sfc_render$6$1], ["__scopeId", "data-v-7e6b67ca"]]);
const _sfc_main$5$1 = defineComponent({
  name: "Display",
  props: {
    color: C$1.instanceOf(Color),
    disableAlpha: C$1.bool.def(false)
  },
  emits: ["update:color", "change"],
  setup(props2, { emit: emit2 }) {
    var _a, _b, _c;
    const state = reactive({
      color: props2.color,
      previewBgColor: (_a = props2.color) == null ? void 0 : _a.toRgbString(),
      alpha: ((_b = props2.color) == null ? void 0 : _b.alpha) || 100,
      hex: (_c = props2.color) == null ? void 0 : _c.hex
    });
    const getBgColorStyle = computed(() => {
      return {
        background: state.previewBgColor
      };
    });
    const onAlphaBlur = (evt) => {
      const target = evt.target;
      const opacity = parseInt(target.value.replace("%", ""));
      if (!isNaN(opacity) && state.color) {
        state.alpha = opacity;
        state.color.alpha = opacity;
      }
    };
    const onInputChange = (event) => {
      const target = event.target;
      const hex = target.value.replace("#", "");
      if (tinycolor(hex).isValid() && state.color) {
        state.color.hex = hex;
      }
    };
    whenever(() => props2.color, (value) => {
      if (value) {
        state.color = value;
      }
    }, { deep: true });
    whenever(() => state.color, () => {
      if (state.color) {
        state.previewBgColor = state.color.toRgbString();
        state.alpha = state.color.alpha;
        state.hex = state.color.hex;
        emit2("update:color", state.color);
        emit2("change", state.color);
      }
    }, { deep: true });
    return { state, getBgColorStyle, onAlphaBlur, onInputChange };
  }
});
const _hoisted_1$4$1 = { class: "vc-display" };
const _hoisted_2$4$1 = { class: "vc-current-color vc-transparent" };
const _hoisted_3$4$1 = { class: "vc-color-input" };
const _hoisted_4$4$1 = ["value"];
const _hoisted_5$4$1 = {
  key: 0,
  class: "vc-alpha-input"
};
const _hoisted_6$2$1 = ["value"];
function _sfc_render$5$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$4$1, [
    createElementVNode("div", _hoisted_2$4$1, [
      createElementVNode("div", {
        class: "color-cube",
        style: normalizeStyle(_ctx.getBgColorStyle)
      }, null, 4)
    ]),
    createElementVNode("div", _hoisted_3$4$1, [
      createElementVNode("input", {
        value: _ctx.state.hex,
        onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.onInputChange && _ctx.onInputChange(...args))
      }, null, 40, _hoisted_4$4$1)
    ]),
    !_ctx.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_5$4$1, [
      createElementVNode("input", {
        class: "vc-alpha-input__inner",
        value: _ctx.state.alpha + "%",
        onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onAlphaBlur && _ctx.onAlphaBlur(...args))
      }, null, 40, _hoisted_6$2$1)
    ])) : createCommentVNode("", true)
  ]);
}
var Display = /* @__PURE__ */ _export_sfc(_sfc_main$5$1, [["render", _sfc_render$5$1], ["__scopeId", "data-v-0067da1d"]]);
const _sfc_main$4$1 = defineComponent({
  name: "FkColorPicker",
  components: { Display, Alpha, Palette, Board, Hue, Lightness, History },
  props: {
    color: C$1.instanceOf(Color),
    disableHistory: C$1.bool.def(false),
    roundHistory: C$1.bool.def(false),
    disableAlpha: C$1.bool.def(false)
  },
  emits: ["update:color", "change", "advanceChange"],
  setup(props2, { emit: emit2 }) {
    const colorInstance = props2.color || new Color();
    const state = reactive({
      color: colorInstance,
      hex: colorInstance.toHexString(),
      rgb: colorInstance.toRgbString()
    });
    const advancePanelShow = ref(false);
    const previewStyle = computed(() => {
      return { background: state.rgb };
    });
    const onBack = () => {
      advancePanelShow.value = false;
      emit2("advanceChange", false);
    };
    const historyColors = useLocalStorage(HistoryColorKey, [], {});
    const updateColorHistoryFn = useDebounceFn(() => {
      if (props2.disableHistory) {
        return;
      }
      const rgbString = state.color.toRgbString();
      historyColors.value = historyColors.value.filter((value) => {
        return !tinycolor.equals(value, rgbString);
      });
      if (historyColors.value.includes(rgbString)) {
        return;
      }
      while (historyColors.value.length > MAX_STORAGE_LENGTH) {
        historyColors.value.pop();
      }
      historyColors.value.unshift(rgbString);
    }, 500);
    const onCompactChange = (color) => {
      if (color === "advance") {
        advancePanelShow.value = true;
        emit2("advanceChange", true);
      } else {
        state.color.hex = color;
        emit2("advanceChange", false);
      }
    };
    const onAlphaChange = (alpha) => {
      state.color.alpha = alpha;
    };
    const onHueChange = (hue) => {
      state.color.hue = hue;
    };
    const onBoardChange = (saturation, brightness) => {
      state.color.saturation = saturation;
      state.color.brightness = brightness;
    };
    const onLightChange = (light) => {
      state.color.lightness = light;
    };
    const onInputChange = (event) => {
      const target = event.target;
      const hex = target.value.replace("#", "");
      if (tinycolor(hex).isValid()) {
        state.color.hex = hex;
      }
    };
    whenever(() => props2.color, (value) => {
      if (value) {
        state.color = value;
      }
    }, { deep: true });
    whenever(() => state.color, () => {
      state.hex = state.color.hex;
      state.rgb = state.color.toRgbString();
      updateColorHistoryFn();
      emit2("update:color", state.color);
      emit2("change", state.color);
    }, { deep: true });
    return {
      state,
      advancePanelShow,
      onBack,
      onCompactChange,
      onAlphaChange,
      onHueChange,
      onBoardChange,
      onLightChange,
      onInputChange,
      previewStyle,
      historyColors
    };
  }
});
const _withScopeId$1$1 = (n2) => (pushScopeId("data-v-592a5ec3"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$3$1 = { class: "vc-fk-colorPicker" };
const _hoisted_2$3$1 = { class: "vc-fk-colorPicker__inner" };
const _hoisted_3$3$1 = { class: "vc-fk-colorPicker__header" };
const _hoisted_4$3$1 = /* @__PURE__ */ _withScopeId$1$1(() => /* @__PURE__ */ createElementVNode("div", { class: "back" }, null, -1));
const _hoisted_5$3$1 = [
  _hoisted_4$3$1
];
function _sfc_render$4$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Palette = resolveComponent("Palette");
  const _component_Board = resolveComponent("Board");
  const _component_Hue = resolveComponent("Hue");
  const _component_Lightness = resolveComponent("Lightness");
  const _component_Alpha = resolveComponent("Alpha");
  const _component_Display = resolveComponent("Display");
  const _component_History = resolveComponent("History");
  return openBlock(), createElementBlock("div", _hoisted_1$3$1, [
    createElementVNode("div", _hoisted_2$3$1, [
      createElementVNode("div", _hoisted_3$3$1, [
        _ctx.advancePanelShow ? (openBlock(), createElementBlock("span", {
          key: 0,
          style: { "cursor": "pointer" },
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onBack && _ctx.onBack(...args))
        }, _hoisted_5$3$1)) : createCommentVNode("", true)
      ]),
      !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Palette, {
        key: 0,
        onChange: _ctx.onCompactChange
      }, null, 8, ["onChange"])) : createCommentVNode("", true),
      _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Board, {
        key: 1,
        color: _ctx.state.color,
        onChange: _ctx.onBoardChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Hue, {
        key: 2,
        color: _ctx.state.color,
        onChange: _ctx.onHueChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Lightness, {
        key: 3,
        color: _ctx.state.color,
        onChange: _ctx.onLightChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      !_ctx.disableAlpha ? (openBlock(), createBlock(_component_Alpha, {
        key: 4,
        color: _ctx.state.color,
        onChange: _ctx.onAlphaChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      createVNode(_component_Display, {
        color: _ctx.state.color,
        "disable-alpha": _ctx.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      !_ctx.disableHistory ? (openBlock(), createBlock(_component_History, {
        key: 5,
        round: _ctx.roundHistory,
        colors: _ctx.historyColors,
        onChange: _ctx.onCompactChange
      }, null, 8, ["round", "colors", "onChange"])) : createCommentVNode("", true)
    ])
  ]);
}
var FkColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$4$1, [["render", _sfc_render$4$1], ["__scopeId", "data-v-592a5ec3"]]);
const _sfc_main$3$1 = defineComponent({
  name: "ChromeColorPicker",
  components: { Display, Alpha, Board, Hue, History },
  props: {
    color: C$1.instanceOf(Color),
    disableHistory: C$1.bool.def(false),
    roundHistory: C$1.bool.def(false),
    disableAlpha: C$1.bool.def(false)
  },
  emits: ["update:color", "change"],
  setup(props2, { emit: emit2 }) {
    const colorInstance = props2.color || new Color();
    const state = reactive({
      color: colorInstance,
      hex: colorInstance.toHexString(),
      rgb: colorInstance.toRgbString()
    });
    const previewStyle = computed(() => {
      return { background: state.rgb };
    });
    const historyColors = useLocalStorage(HistoryColorKey, [], {});
    const updateColorHistoryFn = useDebounceFn(() => {
      if (props2.disableHistory) {
        return;
      }
      const rgbString = state.color.toRgbString();
      historyColors.value = historyColors.value.filter((value) => {
        return !tinycolor.equals(value, rgbString);
      });
      if (historyColors.value.includes(rgbString)) {
        return;
      }
      while (historyColors.value.length > MAX_STORAGE_LENGTH) {
        historyColors.value.pop();
      }
      historyColors.value.unshift(rgbString);
    }, 500);
    const onAlphaChange = (alpha) => {
      state.color.alpha = alpha;
    };
    const onHueChange = (hue) => {
      state.color.hue = hue;
    };
    const onBoardChange = (saturation, brightness) => {
      state.color.saturation = saturation;
      state.color.brightness = brightness;
    };
    const onCompactChange = (color) => {
      if (color !== "advance") {
        state.color.hex = color;
      }
    };
    whenever(() => props2.color, (value) => {
      if (value) {
        state.color = value;
      }
    }, { deep: true });
    whenever(() => state.color, () => {
      state.hex = state.color.hex;
      state.rgb = state.color.toRgbString();
      updateColorHistoryFn();
      emit2("update:color", state.color);
      emit2("change", state.color);
    }, { deep: true });
    return {
      state,
      previewStyle,
      historyColors,
      onAlphaChange,
      onHueChange,
      onBoardChange,
      onCompactChange
    };
  }
});
const _hoisted_1$2$1 = { class: "vc-chrome-colorPicker" };
const _hoisted_2$2$1 = { class: "vc-chrome-colorPicker-body" };
const _hoisted_3$2$1 = { class: "chrome-controls" };
const _hoisted_4$2$1 = { class: "chrome-color-wrap transparent" };
const _hoisted_5$2$1 = { class: "chrome-sliders" };
function _sfc_render$3$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Board = resolveComponent("Board");
  const _component_Hue = resolveComponent("Hue");
  const _component_Alpha = resolveComponent("Alpha");
  const _component_Display = resolveComponent("Display");
  const _component_History = resolveComponent("History");
  return openBlock(), createElementBlock("div", _hoisted_1$2$1, [
    createVNode(_component_Board, {
      round: true,
      hide: false,
      color: _ctx.state.color,
      onChange: _ctx.onBoardChange
    }, null, 8, ["color", "onChange"]),
    createElementVNode("div", _hoisted_2$2$1, [
      createElementVNode("div", _hoisted_3$2$1, [
        createElementVNode("div", _hoisted_4$2$1, [
          createElementVNode("div", {
            class: "current-color",
            style: normalizeStyle(_ctx.previewStyle)
          }, null, 4)
        ]),
        createElementVNode("div", _hoisted_5$2$1, [
          createVNode(_component_Hue, {
            size: "small",
            color: _ctx.state.color,
            onChange: _ctx.onHueChange
          }, null, 8, ["color", "onChange"]),
          !_ctx.disableAlpha ? (openBlock(), createBlock(_component_Alpha, {
            key: 0,
            size: "small",
            color: _ctx.state.color,
            onChange: _ctx.onAlphaChange
          }, null, 8, ["color", "onChange"])) : createCommentVNode("", true)
        ])
      ]),
      createVNode(_component_Display, {
        color: _ctx.state.color,
        "disable-alpha": _ctx.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      !_ctx.disableHistory ? (openBlock(), createBlock(_component_History, {
        key: 0,
        round: _ctx.roundHistory,
        colors: _ctx.historyColors,
        onChange: _ctx.onCompactChange
      }, null, 8, ["round", "colors", "onChange"])) : createCommentVNode("", true)
    ])
  ]);
}
var ChromeColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$3$1, [["render", _sfc_render$3$1], ["__scopeId", "data-v-61d7303b"]]);
const ColorPickerProviderKey = "Vue3ColorPickerProvider";
const _sfc_main$2$1 = defineComponent({
  name: "GradientColorPicker",
  components: { Angle, Display, Alpha, Palette, Board, Hue, Lightness, History },
  props: {
    startColor: C$1.instanceOf(Color).isRequired,
    endColor: C$1.instanceOf(Color).isRequired,
    startColorStop: C$1.number.def(0),
    endColorStop: C$1.number.def(100),
    angle: C$1.number.def(0),
    disableHistory: C$1.bool.def(false),
    roundHistory: C$1.bool.def(false),
    disableAlpha: C$1.bool.def(false)
  },
  emits: [
    "update:startColor",
    "update:endColor",
    "update:angle",
    "update:startColorStop",
    "update:endColorStop",
    "startColorChange",
    "endColorChange",
    "advanceChange",
    "angleChange",
    "startColorStopChange",
    "endColorStopChange"
  ],
  setup(props2, { emit: emit2 }) {
    const state = reactive({
      startActive: true,
      startColor: props2.startColor,
      endColor: props2.endColor,
      startColorStop: props2.startColorStop,
      endColorStop: props2.endColorStop,
      angle: props2.angle,
      startColorRgba: props2.startColor.toRgbString(),
      endColorRgba: props2.endColor.toRgbString()
    });
    const parent = inject(ColorPickerProviderKey);
    const advancePanelShow = ref(false);
    const startGradientRef = ref();
    const stopGradientRef = ref();
    const colorRangeRef = ref();
    const currentColor = computed({
      get: () => {
        return state.startActive ? state.startColor : state.endColor;
      },
      set: (v2) => {
        if (state.startActive) {
          state.startColor = v2;
          return;
        }
        state.endColor = v2;
      }
    });
    const getStartColorLeft = computed(() => {
      if (colorRangeRef.value && startGradientRef.value) {
        const alpha = state.startColorStop / 100;
        const rect = colorRangeRef.value.getBoundingClientRect();
        const offsetWidth = startGradientRef.value.offsetWidth;
        return Math.round(alpha * (rect.width - offsetWidth) + offsetWidth / 2);
      }
      return 0;
    });
    const getEndColorLeft = computed(() => {
      if (colorRangeRef.value && stopGradientRef.value) {
        const alpha = state.endColorStop / 100;
        const rect = colorRangeRef.value.getBoundingClientRect();
        const offsetWidth = stopGradientRef.value.offsetWidth;
        return Math.round(alpha * (rect.width - offsetWidth) + offsetWidth / 2);
      }
      return 0;
    });
    const gradientBg = computed(() => {
      return {
        background: `linear-gradient(${state.angle}deg, ${state.startColorRgba} ${state.startColorStop}%, ${state.endColorRgba} ${state.endColorStop}%)`
      };
    });
    const dragStartRange = (evt) => {
      var _a;
      state.startActive = true;
      if (colorRangeRef.value && startGradientRef.value) {
        const rect = (_a = colorRangeRef.value) == null ? void 0 : _a.getBoundingClientRect();
        let left2 = evt.clientX - rect.left;
        left2 = Math.max(startGradientRef.value.offsetWidth / 2, left2);
        left2 = Math.min(left2, rect.width - startGradientRef.value.offsetWidth / 2);
        state.startColorStop = Math.round((left2 - startGradientRef.value.offsetWidth / 2) / (rect.width - startGradientRef.value.offsetWidth) * 100);
        emit2("update:startColorStop", state.startColorStop);
        emit2("startColorStopChange", state.startColorStop);
      }
    };
    const dragEndRange = (evt) => {
      var _a;
      state.startActive = false;
      if (colorRangeRef.value && stopGradientRef.value) {
        const rect = (_a = colorRangeRef.value) == null ? void 0 : _a.getBoundingClientRect();
        let left2 = evt.clientX - rect.left;
        left2 = Math.max(stopGradientRef.value.offsetWidth / 2, left2);
        left2 = Math.min(left2, rect.width - stopGradientRef.value.offsetWidth / 2);
        state.endColorStop = Math.round((left2 - stopGradientRef.value.offsetWidth / 2) / (rect.width - stopGradientRef.value.offsetWidth) * 100);
        emit2("update:endColorStop", state.endColorStop);
        emit2("endColorStopChange", state.endColorStop);
      }
    };
    const onDegreeBlur = (evt) => {
      const target = evt.target;
      const degree = parseInt(target.value.replace("\xB0", ""));
      if (!isNaN(degree)) {
        state.angle = degree % 360;
      }
      emit2("update:angle", state.angle);
      emit2("angleChange", state.angle);
    };
    const onDegreeChange = (angle) => {
      state.angle = angle;
      emit2("update:angle", state.angle);
      emit2("angleChange", state.angle);
    };
    const onCompactChange = (color) => {
      if (color === "advance") {
        advancePanelShow.value = true;
        emit2("advanceChange", true);
      } else {
        currentColor.value.hex = color;
        emit2("advanceChange", false);
      }
      doColorChange();
    };
    const onAlphaChange = (alpha) => {
      currentColor.value.alpha = alpha;
      doColorChange();
    };
    const onHueChange = (hue) => {
      currentColor.value.hue = hue;
      doColorChange();
    };
    const onBoardChange = (saturation, brightness) => {
      currentColor.value.saturation = saturation;
      currentColor.value.brightness = brightness;
      doColorChange();
    };
    const onLightChange = (light) => {
      currentColor.value.lightness = light;
      doColorChange();
    };
    const doColorChange = () => {
      if (state.startActive) {
        emit2("update:startColor", state.startColor);
        emit2("startColorChange", state.startColor);
      } else {
        emit2("update:endColor", state.endColor);
        emit2("endColorChange", state.endColor);
      }
    };
    const onBack = () => {
      advancePanelShow.value = false;
      emit2("advanceChange", false);
    };
    const historyColors = useLocalStorage(HistoryColorKey, [], {});
    const updateColorHistoryFn = useDebounceFn(() => {
      if (props2.disableHistory) {
        return;
      }
      const rgbString = currentColor.value.toRgbString();
      historyColors.value = historyColors.value.filter((value) => {
        return !tinycolor.equals(value, rgbString);
      });
      if (historyColors.value.includes(rgbString)) {
        return;
      }
      while (historyColors.value.length > MAX_STORAGE_LENGTH) {
        historyColors.value.pop();
      }
      historyColors.value.unshift(rgbString);
    }, 500);
    tryOnMounted(() => {
      if (stopGradientRef.value && startGradientRef.value) {
        Vn.triggerDragEvent(stopGradientRef.value, {
          drag: (event) => {
            dragEndRange(event);
          },
          end: (event) => {
            dragEndRange(event);
          }
        });
        Vn.triggerDragEvent(startGradientRef.value, {
          drag: (event) => {
            dragStartRange(event);
          },
          end: (event) => {
            dragStartRange(event);
          }
        });
      }
    });
    whenever(() => state.startColor, (value) => {
      state.startColorRgba = value.toRgbString();
    }, { deep: true });
    whenever(() => state.endColor, (value) => {
      state.endColorRgba = value.toRgbString();
    }, { deep: true });
    whenever(() => currentColor.value, () => {
      updateColorHistoryFn();
    }, { deep: true });
    return {
      startGradientRef,
      stopGradientRef,
      colorRangeRef,
      state,
      currentColor,
      getStartColorLeft,
      getEndColorLeft,
      gradientBg,
      advancePanelShow,
      onDegreeBlur,
      onCompactChange,
      onAlphaChange,
      onHueChange,
      onBoardChange,
      onLightChange,
      historyColors,
      onBack,
      onDegreeChange,
      lang: parent == null ? void 0 : parent.lang
    };
  }
});
const _withScopeId$9 = (n2) => (pushScopeId("data-v-f63daa7a"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1$1 = { class: "vc-gradient-picker" };
const _hoisted_2$1$1 = { class: "vc-gradient-picker__header" };
const _hoisted_3$1$1 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createElementVNode("div", { class: "back" }, null, -1));
const _hoisted_4$1$1 = [
  _hoisted_3$1$1
];
const _hoisted_5$1$1 = { class: "vc-gradient-picker__body" };
const _hoisted_6$1$1 = {
  class: "vc-color-range",
  ref: "colorRangeRef"
};
const _hoisted_7$a = { class: "vc-color-range__container" };
const _hoisted_8$7 = { class: "vc-gradient__stop__container" };
const _hoisted_9$4 = ["title"];
const _hoisted_10$4 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createElementVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
const _hoisted_11$4 = [
  _hoisted_10$4
];
const _hoisted_12$3 = ["title"];
const _hoisted_13$1 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createElementVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
const _hoisted_14$1 = [
  _hoisted_13$1
];
const _hoisted_15$1 = { class: "vc-picker-degree-input vc-degree-input" };
const _hoisted_16$1 = { class: "vc-degree-input__control" };
const _hoisted_17$1 = ["value"];
const _hoisted_18 = { class: "vc-degree-input__panel" };
const _hoisted_19 = { class: "vc-degree-input__disk" };
function _sfc_render$2$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Angle = resolveComponent("Angle");
  const _component_Palette = resolveComponent("Palette");
  const _component_Board = resolveComponent("Board");
  const _component_Hue = resolveComponent("Hue");
  const _component_Lightness = resolveComponent("Lightness");
  const _component_Alpha = resolveComponent("Alpha");
  const _component_Display = resolveComponent("Display");
  const _component_History = resolveComponent("History");
  return openBlock(), createElementBlock("div", _hoisted_1$1$1, [
    withDirectives(createElementVNode("div", _hoisted_2$1$1, [
      createElementVNode("span", {
        style: { "cursor": "pointer" },
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onBack && _ctx.onBack(...args))
      }, _hoisted_4$1$1)
    ], 512), [
      [vShow, _ctx.advancePanelShow]
    ]),
    createElementVNode("div", _hoisted_5$1$1, [
      createElementVNode("div", _hoisted_6$1$1, [
        createElementVNode("div", _hoisted_7$a, [
          createElementVNode("div", {
            class: "vc-background",
            style: normalizeStyle(_ctx.gradientBg)
          }, null, 4),
          createElementVNode("div", _hoisted_8$7, [
            createElementVNode("div", {
              class: normalizeClass([
                "vc-gradient__stop",
                {
                  "vc-gradient__stop--current": _ctx.state.startActive
                }
              ]),
              ref: "startGradientRef",
              title: _ctx.lang === "ZH-cn" ? "\u5F00\u59CB" : "Start",
              style: normalizeStyle({ left: _ctx.getStartColorLeft + "px" })
            }, _hoisted_11$4, 14, _hoisted_9$4),
            createElementVNode("div", {
              class: normalizeClass([
                "vc-gradient__stop",
                {
                  "vc-gradient__stop--current": !_ctx.state.startActive
                }
              ]),
              ref: "stopGradientRef",
              title: _ctx.lang === "ZH-cn" ? "\u7ED3\u675F" : "End",
              style: normalizeStyle({ left: _ctx.getEndColorLeft + "px" })
            }, _hoisted_14$1, 14, _hoisted_12$3)
          ])
        ])
      ], 512),
      createElementVNode("div", _hoisted_15$1, [
        createElementVNode("div", _hoisted_16$1, [
          createElementVNode("input", {
            value: _ctx.state.angle,
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onDegreeBlur && _ctx.onDegreeBlur(...args))
          }, null, 40, _hoisted_17$1)
        ]),
        createElementVNode("div", _hoisted_18, [
          createElementVNode("div", _hoisted_19, [
            createVNode(_component_Angle, {
              angle: _ctx.state.angle,
              "onUpdate:angle": _cache[2] || (_cache[2] = ($event) => _ctx.state.angle = $event),
              size: 40,
              onChange: _ctx.onDegreeChange
            }, null, 8, ["angle", "onChange"])
          ])
        ])
      ])
    ]),
    !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Palette, {
      key: 0,
      onChange: _ctx.onCompactChange
    }, null, 8, ["onChange"])) : createCommentVNode("", true),
    _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Board, {
      key: 1,
      color: _ctx.currentColor,
      onChange: _ctx.onBoardChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Hue, {
      key: 2,
      color: _ctx.currentColor,
      onChange: _ctx.onHueChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Lightness, {
      key: 3,
      color: _ctx.currentColor,
      onChange: _ctx.onLightChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    !_ctx.disableAlpha ? (openBlock(), createBlock(_component_Alpha, {
      key: 4,
      color: _ctx.currentColor,
      onChange: _ctx.onAlphaChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    createVNode(_component_Display, {
      color: _ctx.currentColor,
      "disable-alpha": _ctx.disableAlpha
    }, null, 8, ["color", "disable-alpha"]),
    !_ctx.disableHistory ? (openBlock(), createBlock(_component_History, {
      key: 5,
      round: _ctx.roundHistory,
      colors: _ctx.historyColors,
      onChange: _ctx.onCompactChange
    }, null, 8, ["round", "colors", "onChange"])) : createCommentVNode("", true)
  ]);
}
var GradientColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$2$1, [["render", _sfc_render$2$1], ["__scopeId", "data-v-f63daa7a"]]);
const _sfc_main$1$1 = defineComponent({
  name: "WrapContainer",
  props: {
    showTab: C$1.bool.def(false),
    activeKey: C$1.oneOf(["pure", "gradient"]).def("pure")
  },
  emits: ["update:activeKey", "change"],
  setup(props2, { emit: emit2 }) {
    const state = reactive({
      activeKey: props2.activeKey
    });
    const parent = inject(ColorPickerProviderKey);
    const onActiveKeyChange = (key) => {
      state.activeKey = key;
      emit2("update:activeKey", key);
      emit2("change", key);
    };
    whenever(() => props2.activeKey, (value) => {
      state.activeKey = value;
    });
    return { state, onActiveKeyChange, lang: parent == null ? void 0 : parent.lang };
  }
});
const _hoisted_1$11 = { class: "vc-colorpicker" };
const _hoisted_2$A = { class: "vc-colorpicker--container" };
const _hoisted_3$s = {
  key: 0,
  class: "vc-colorpicker--tabs"
};
const _hoisted_4$g = { class: "vc-colorpicker--tabs__inner" };
const _hoisted_5$g = { class: "vc-btn__content" };
const _hoisted_6$c = { class: "vc-btn__content" };
function _sfc_render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$11, [
    createElementVNode("div", _hoisted_2$A, [
      _ctx.showTab ? (openBlock(), createElementBlock("div", _hoisted_3$s, [
        createElementVNode("div", _hoisted_4$g, [
          createElementVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": _ctx.state.activeKey === "pure"
              }
            ]),
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.onActiveKeyChange("pure"))
          }, [
            createElementVNode("button", null, [
              createElementVNode("div", _hoisted_5$g, toDisplayString(_ctx.lang === "ZH-cn" ? "\u7EAF\u8272" : "Pure"), 1)
            ])
          ], 2),
          createElementVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": _ctx.state.activeKey === "gradient"
              }
            ]),
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.onActiveKeyChange("gradient"))
          }, [
            createElementVNode("button", null, [
              createElementVNode("div", _hoisted_6$c, toDisplayString(_ctx.lang === "ZH-cn" ? "\u6E10\u53D8\u8272" : "Gradient"), 1)
            ])
          ], 2),
          createElementVNode("div", {
            class: "vc-colorpicker--tabs__bg",
            style: normalizeStyle({
              width: `50%`,
              left: `calc(${_ctx.state.activeKey === "gradient" ? 50 : 0}%)`
            })
          }, null, 4)
        ])
      ])) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ])
  ]);
}
var WrapContainer = /* @__PURE__ */ _export_sfc(_sfc_main$1$1, [["render", _sfc_render$1$1], ["__scopeId", "data-v-4afdf3bb"]]);
const colorPickerProps = {
  isWidget: C$1.bool.def(false),
  pickerType: C$1.oneOf(["fk", "chrome"]).def("fk"),
  shape: C$1.oneOf(["circle", "square"]).def("square"),
  pureColor: {
    type: [String, Object],
    default: "#000000"
  },
  gradientColor: C$1.string.def("#000"),
  format: {
    type: String,
    default: "rgb"
  },
  disableAlpha: C$1.bool.def(false),
  disableHistory: C$1.bool.def(false),
  roundHistory: C$1.bool.def(false),
  useType: C$1.oneOf(["pure", "gradient", "both"]).def("pure"),
  activeKey: C$1.oneOf(["pure", "gradient"]).def("pure"),
  lang: {
    type: String,
    default: "ZH-cn"
  },
  zIndex: C$1.number.def(9999)
};
const _sfc_main$16 = defineComponent({
  name: "ColorPicker",
  components: { FkColorPicker, ChromeColorPicker, GradientColorPicker, WrapContainer },
  inheritAttrs: false,
  props: colorPickerProps,
  emits: [
    "update:pureColor",
    "pureColorChange",
    "update:gradientColor",
    "gradientColorChange",
    "update:activeKey",
    "activeKeyChange"
  ],
  setup(props2, { emit: emit2 }) {
    const state = reactive({
      pureColor: props2.pureColor || "",
      activeKey: props2.useType === "gradient" ? "gradient" : "pure",
      isAdvanceMode: false
    });
    provide(ColorPickerProviderKey, {
      lang: computed(() => props2.lang || "ZH-cn")
    });
    const instance2 = new Color(state.pureColor);
    const colorInstance = ref(instance2);
    const startColor = new Color("#000");
    const endColor = new Color("#000");
    const gradientState = reactive({
      startColor,
      endColor,
      startColorStop: 0,
      endColorStop: 100,
      angle: 0,
      gradientColor: props2.gradientColor
    });
    const showPicker = ref(false);
    const colorCubeRef = ref(null);
    const pickerRef = ref(null);
    const getBgColorStyle = computed(() => {
      const bgColor = state.activeKey !== "gradient" ? tinycolor(state.pureColor).toRgbString() : gradientState.gradientColor;
      return {
        background: bgColor
      };
    });
    const getComponentName = computed(() => {
      if (state.activeKey === "gradient") {
        return GradientColorPicker.name;
      }
      return props2.pickerType === "fk" ? FkColorPicker.name : ChromeColorPicker.name;
    });
    const getBindArgs = computed(() => {
      if (state.activeKey === "gradient") {
        return {
          startColor: gradientState.startColor,
          endColor: gradientState.endColor,
          onStartColorChange: (v2) => {
            gradientState.startColor = v2;
            onGradientChange();
          },
          onEndColorChange: (v2) => {
            gradientState.endColor = v2;
            onGradientChange();
          },
          angle: gradientState.angle,
          startColorStop: gradientState.startColorStop,
          endColorStop: gradientState.endColorStop,
          onStartColorStopChange: (v2) => {
            gradientState.startColorStop = v2;
            onGradientChange();
          },
          onEndColorStopChange: (v2) => {
            gradientState.endColorStop = v2;
            onGradientChange();
          },
          onAngleChange: (v2) => {
            gradientState.angle = v2;
            onGradientChange();
          },
          onAdvanceChange: (v2) => {
            state.isAdvanceMode = v2;
          }
        };
      }
      return {
        disableAlpha: props2.disableAlpha,
        disableHistory: props2.disableHistory,
        roundHistory: props2.roundHistory,
        color: colorInstance.value,
        onChange: onColorChange,
        onAdvanceChange
      };
    });
    const onAdvanceChange = (isAdvance) => {
      state.isAdvanceMode = isAdvance;
    };
    const onShowPicker = () => {
      showPicker.value = true;
    };
    const onHidePicker = () => {
      showPicker.value = false;
    };
    const parseGradientColor = () => {
      var _a, _b, _c, _d;
      try {
        const [colorNode] = parse(gradientState.gradientColor);
        if (colorNode && colorNode.type === "linear-gradient" && ((_a = colorNode.orientation) == null ? void 0 : _a.type) === "angular" && colorNode.colorStops.length >= 2) {
          const startColorVal = colorNode.colorStops[0];
          const endColorVal = colorNode.colorStops[1];
          gradientState.startColorStop = Number((_b = startColorVal.length) == null ? void 0 : _b.value) || 0;
          gradientState.endColorStop = Number((_c = endColorVal.length) == null ? void 0 : _c.value) || 0;
          gradientState.angle = Number((_d = colorNode.orientation) == null ? void 0 : _d.value) || 0;
          const [r2, g2, b2, a2] = startColorVal.value;
          const [r1, g1, b1, a1] = startColorVal.value;
          gradientState.startColor = new Color({
            r: Number(r2),
            g: Number(g2),
            b: Number(b2),
            a: Number(a2)
          });
          gradientState.startColor = new Color({
            r: Number(r1),
            g: Number(g1),
            b: Number(b1),
            a: Number(a1)
          });
        }
      } catch (e2) {
        console.log(`[Parse Color]: ${e2}`);
      }
    };
    const onGradientChange = () => {
      const nodes = color2GradientNode();
      try {
        gradientState.gradientColor = stringify(nodes);
        emit2("update:gradientColor", gradientState.gradientColor);
        emit2("gradientColorChange", gradientState.gradientColor);
      } catch (e2) {
        console.log(e2);
      }
    };
    const color2GradientNode = () => {
      const nodes = [];
      const startColorArr = gradientState.startColor.RGB.map((v2) => v2.toString());
      const endColorArr = gradientState.endColor.RGB.map((v2) => v2.toString());
      nodes.push({
        type: "linear-gradient",
        orientation: { type: "angular", value: gradientState.angle + "" },
        colorStops: [
          {
            type: "rgba",
            value: [startColorArr[0], startColorArr[1], startColorArr[2], startColorArr[3]],
            length: { value: gradientState.startColorStop + "", type: "%" }
          },
          {
            type: "rgba",
            value: [endColorArr[0], endColorArr[1], endColorArr[2], endColorArr[3]],
            length: { value: gradientState.endColorStop + "", type: "%" }
          }
        ]
      });
      return nodes;
    };
    const onInit = () => {
      if (colorCubeRef.value && pickerRef.value) {
        createPopper(colorCubeRef.value, pickerRef.value, {
          placement: "auto",
          modifiers: [
            {
              name: "flip",
              options: {
                fallbackPlacements: ["top", "left"]
              }
            }
          ]
        });
      }
    };
    const onColorChange = (v2) => {
      colorInstance.value = v2;
      state.pureColor = v2.toString(props2.format);
      emitColorChange();
    };
    const emitColorChange = () => {
      emit2("update:pureColor", state.pureColor);
      emit2("pureColorChange", state.pureColor);
    };
    onClickOutside(pickerRef, () => {
      onHidePicker();
    });
    const onActiveKeyChange = (key) => {
      state.activeKey = key;
      emit2("update:activeKey", key);
      emit2("activeKeyChange", key);
    };
    tryOnMounted(() => {
      onInit();
      emitColorChange();
      parseGradientColor();
      onGradientChange();
    });
    whenever(() => props2.gradientColor, (value) => {
      if (value != gradientState.gradientColor) {
        gradientState.gradientColor = value;
      }
    });
    whenever(() => gradientState.gradientColor, () => {
      parseGradientColor();
    });
    whenever(() => props2.activeKey, (value) => {
      state.activeKey = value;
    });
    whenever(() => props2.useType, (value) => {
      if (state.activeKey !== "gradient" && value === "gradient") {
        state.activeKey = "gradient";
      } else {
        state.activeKey = "pure";
      }
    });
    whenever(() => props2.pureColor, (value) => {
      const equal = tinycolor.equals(value, state.pureColor);
      if (!equal) {
        state.pureColor = value;
        colorInstance.value = new Color(value);
        emitColorChange();
      }
    }, { deep: true });
    return {
      colorCubeRef,
      pickerRef,
      showPicker,
      colorInstance,
      getBgColorStyle,
      onColorChange,
      onShowPicker,
      onActiveKeyChange,
      getComponentName,
      getBindArgs,
      state
    };
  }
});
function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_WrapContainer = resolveComponent("WrapContainer");
  return openBlock(), createElementBlock(Fragment, null, [
    !_ctx.isWidget ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["vc-color-wrap", "transparent", { round: _ctx.shape === "circle" }]),
      ref: "colorCubeRef"
    }, [
      createElementVNode("div", {
        class: "current-color",
        style: normalizeStyle(_ctx.getBgColorStyle),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onShowPicker && _ctx.onShowPicker(...args))
      }, null, 4)
    ], 2)) : createCommentVNode("", true),
    _ctx.isWidget ? (openBlock(), createBlock(_component_WrapContainer, {
      key: 1,
      "active-key": _ctx.state.activeKey,
      "onUpdate:active-key": _cache[1] || (_cache[1] = ($event) => _ctx.state.activeKey = $event),
      "show-tab": _ctx.useType === "both",
      onChange: _ctx.onActiveKeyChange,
      style: normalizeStyle({ zIndex: _ctx.zIndex })
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(_ctx.getComponentName), mergeProps({ key: _ctx.getComponentName }, _ctx.getBindArgs), null, 16))
      ]),
      _: 1
    }, 8, ["active-key", "show-tab", "onChange", "style"])) : createCommentVNode("", true),
    !_ctx.isWidget ? (openBlock(), createBlock(Teleport, {
      key: 2,
      to: "body"
    }, [
      withDirectives(createElementVNode("div", {
        ref: "pickerRef",
        style: normalizeStyle({ zIndex: _ctx.zIndex })
      }, [
        _ctx.showPicker ? (openBlock(), createBlock(_component_WrapContainer, {
          key: 0,
          "show-tab": _ctx.useType === "both" && !_ctx.state.isAdvanceMode,
          "active-key": _ctx.state.activeKey,
          "onUpdate:active-key": _cache[2] || (_cache[2] = ($event) => _ctx.state.activeKey = $event),
          onChange: _ctx.onActiveKeyChange
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.getComponentName), mergeProps({ key: _ctx.getComponentName }, _ctx.getBindArgs), null, 16))
          ]),
          _: 1
        }, 8, ["show-tab", "active-key", "onChange"])) : createCommentVNode("", true)
      ], 4), [
        [vShow, _ctx.showPicker]
      ])
    ])) : createCommentVNode("", true)
  ], 64);
}
var ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$16], ["__scopeId", "data-v-0aa3a75d"]]);
var DesignTheme_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$15 = {
  name: "DesignTheme",
  components: {
    ColorPicker,
    XIcon: render$d
  },
  props: {
    theme: {
      type: Object,
      default: () => ({
        questions: "#111111",
        descriptions: "#666666",
        answers: "#111111",
        buttons: "#d51920",
        button_text: "#ffffff",
        background: "#ffffff"
      })
    }
  },
  emits: ["update:theme"],
  data: function() {
    return {
      colors: ["questions", "descriptions", "answers", "buttons", "button_text", "background"],
      showPicker: null
    };
  },
  methods: {
    handleChangeColor: function(c2) {
      this.$emit("update:theme", { ...this.theme, [this.showPicker]: c2 });
    }
  }
};
const _hoisted_1$10 = { class: "px-3 py-2 relative" };
const _hoisted_2$z = { class: "capitalize" };
const _hoisted_3$r = ["onClick"];
const _hoisted_4$f = {
  key: 0,
  class: "absolute top-1 left-1 right-1 z-10 px-3 py-2 bg-white rounded shadow"
};
const _hoisted_5$f = { class: "overflow-hidden py-1" };
function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_XIcon = resolveComponent("XIcon");
  const _component_ColorPicker = resolveComponent("ColorPicker");
  return openBlock(), createElementBlock("div", _hoisted_1$10, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.colors, (setting) => {
      return openBlock(), createElementBlock("div", {
        key: `design-theme-color-${setting}`,
        class: "flex justify-between text-sm text-gray-600 py-1"
      }, [
        createElementVNode("div", _hoisted_2$z, toDisplayString(setting.replace("_", " ")), 1),
        createElementVNode("div", {
          class: "h-5 w-12 rounded border",
          style: normalizeStyle({ background: $props.theme[setting] }),
          onClick: ($event) => _ctx.showPicker = setting
        }, null, 12, _hoisted_3$r)
      ]);
    }), 128)),
    _ctx.showPicker ? (openBlock(), createElementBlock("div", _hoisted_4$f, [
      createElementVNode("div", _hoisted_5$f, [
        createVNode(_component_XIcon, {
          class: "h-6 text-gray-500 hover:text-gray-700 duration-300 float-right cursor-pointer",
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.showPicker = null)
        })
      ]),
      createVNode(_component_ColorPicker, {
        style: { "width": "100%" },
        pureColor: $props.theme[_ctx.showPicker],
        pickerType: "chrome",
        format: "hex",
        onPureColorChange: $options.handleChangeColor
      }, null, 8, ["pureColor", "onPureColorChange"])
    ])) : createCommentVNode("", true)
  ]);
}
var DesignTheme = /* @__PURE__ */ _export_sfc$1(_sfc_main$15, [["render", _sfc_render$15], ["__scopeId", "data-v-42dffaf2"]]);
var FlowChart_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$14 = {
  name: "FlowChart",
  props: {
    questions: { type: Object, required: true },
    answers: { type: Array, required: true }
  },
  data: function() {
    return {};
  },
  computed: {
    lines: function() {
      let engagedXCoordinates = [];
      let engagedYCoordinates = [];
      const lines = [];
      for (const { x: x2, y: y2, toId, toForm } of this.answers) {
        if (!this.questionCoordinatesById(toId)) {
          continue;
        }
        const [questionX1, questionX2, questionY] = this.questionCoordinatesById(toId);
        if (x2 >= questionX1 && x2 <= questionX2) {
          lines.push([x2, y2, x2, questionY]);
          continue;
        }
        if (y2 + 40 >= questionY && y2 - 40 <= questionY) {
          lines.push(
            [x2 + 10, y2 - 10, questionX1 + 10, y2 - 10]
          );
          continue;
        }
        let resX, resY;
        [resX, engagedXCoordinates] = this.getFreeXCoord(questionX1 + 10, engagedXCoordinates);
        [resY, engagedYCoordinates] = this.getFreeYCoord(y2 + 10, engagedYCoordinates);
        lines.push(
          [x2, y2, x2, resY],
          [x2, resY, resX, resY],
          [resX, resY, resX, questionY]
        );
      }
      return lines;
    }
  },
  methods: {
    questionCoordinatesByIndex: function(index2) {
      const { x1, x2, y: y2 } = Object.values(this.questions).find((q) => q.index === index2);
      return [x1, x2, y2];
    },
    questionCoordinatesById: function(id) {
      if (!this.questions[id]) {
        return null;
      }
      const { x1, x2, y: y2 } = this.questions[id];
      return [x1, x2, y2];
    },
    getFreeXCoord: function(x2, engagedXCoordinates) {
      if (engagedXCoordinates.indexOf(x2) === -1) {
        return [x2, [...engagedXCoordinates, x2]];
      }
      return this.getFreeXCoord(x2 + 20, engagedXCoordinates);
    },
    getFreeYCoord: function(y2, engagedYCoordinates) {
      if (engagedYCoordinates.indexOf(y2) === -1) {
        return [y2, [...engagedYCoordinates, y2]];
      }
      return this.getFreeXCoord(y2 + 10, engagedYCoordinates);
    }
  }
};
const _hoisted_1$$ = { class: "pointer-events-none" };
const _hoisted_2$y = { class: "w-full h-full block pointer-events-none" };
const _hoisted_3$q = ["x1", "y1", "x2", "y2"];
function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$$, [
    (openBlock(), createElementBlock("svg", _hoisted_2$y, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.lines, ([x1, y1, x2, y2], i2) => {
        return openBlock(), createElementBlock("g", {
          key: `flow-line-${i2}`
        }, [
          createElementVNode("line", {
            x1,
            y1,
            x2,
            y2
          }, null, 8, _hoisted_3$q)
        ]);
      }), 128))
    ]))
  ]);
}
var FlowChart = /* @__PURE__ */ _export_sfc$1(_sfc_main$14, [["render", _sfc_render$14], ["__scopeId", "data-v-7c3d8e40"]]);
var ArrowLeftSquareIcon_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$13 = {
  name: "ArrowLeftSquareIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _withScopeId$8 = (n2) => (pushScopeId("data-v-474510d0"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$_ = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("g", { transform: "translate(0.25 0.25)" }, [
  /* @__PURE__ */ createElementVNode("g", {
    "data-name": "arrow-left-square",
    transform: "translate(27 27) rotate(180)"
  }, [
    /* @__PURE__ */ createElementVNode("path", {
      id: "Path_515",
      "data-name": "Path 515",
      class: "cls-1",
      d: "M23.625,1.688H3.375A1.687,1.687,0,0,0,1.688,3.375v20.25a1.688,1.688,0,0,0,1.687,1.688h20.25a1.688,1.688,0,0,0,1.688-1.687V3.375A1.688,1.688,0,0,0,23.625,1.688ZM3.375,0A3.375,3.375,0,0,0,0,3.375v20.25A3.375,3.375,0,0,0,3.375,27h20.25A3.375,3.375,0,0,0,27,23.625V3.375A3.375,3.375,0,0,0,23.625,0Z"
    }),
    /* @__PURE__ */ createElementVNode("path", {
      id: "Path_516",
      "data-name": "Path 516",
      class: "cls-1",
      d: "M8.673,15.423a1.125,1.125,0,0,0,0-1.593L2.718,7.877,8.674,1.923A1.126,1.126,0,0,0,7.081.33L.331,7.08a1.125,1.125,0,0,0,0,1.593l6.75,6.75a1.125,1.125,0,0,0,1.593,0Z",
      transform: "translate(6.749 5.623)"
    }),
    /* @__PURE__ */ createElementVNode("path", {
      id: "Path_517",
      "data-name": "Path 517",
      class: "cls-1",
      d: "M13.5,1.125A1.125,1.125,0,0,0,12.375,0H1.125a1.125,1.125,0,0,0,0,2.25h11.25A1.125,1.125,0,0,0,13.5,1.125Z",
      transform: "translate(7.425 12.375)"
    })
  ])
], -1));
function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 27.5 27.5" }), {
    default: withCtx(() => [
      _hoisted_1$_
    ]),
    _: 1
  }, 16);
}
var ArrowLeftSquareIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$13, [["render", _sfc_render$13], ["__scopeId", "data-v-474510d0"]]);
const _sfc_main$12 = {
  name: "ContrastIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$Z = /* @__PURE__ */ createElementVNode("circle", {
  cx: "256",
  cy: "256",
  r: "208",
  class: "stroke-current",
  style: { "fill": "none", "stroke-linejoin": "round", "stroke-width": "32px" }
}, null, -1);
const _hoisted_2$x = /* @__PURE__ */ createElementVNode("path", {
  d: "M256,464C141.12,464,48,370.88,48,256S141.12,48,256,48Z",
  class: "fill-current"
}, null, -1);
function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 512 512" }), {
    default: withCtx(() => [
      _hoisted_1$Z,
      _hoisted_2$x
    ]),
    _: 1
  }, 16);
}
var ContrastIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$12, [["render", _sfc_render$12]]);
const _sfc_main$11 = {
  name: "TYPIcon",
  components: { IconBase },
  props: iconProps
};
const _hoisted_1$Y = /* @__PURE__ */ createElementVNode("path", {
  class: "fill-current",
  d: "M8.374,3.485a2.773,2.773,0,0,0-.719.079A2.567,2.567,0,0,0,6.9,3.91a2.615,2.615,0,0,0-.945-.387A7.788,7.788,0,0,0,4.821,3.51a3.818,3.818,0,0,0-1.305.452,5.545,5.545,0,0,1-2.09.387H1v4.1l.239.12.785.387,2.8,3.115.013.013a1.456,1.456,0,0,0,1.131.373,2.236,2.236,0,0,0,1.025-.306c.63-.38,2.343-1.571,2.343-1.571l.04-.027.027-.026a1.492,1.492,0,0,0,.373-.705L11.408,9l1.225-.412.293-.094V4.35H12.5a5.469,5.469,0,0,1-2.09-.4,3.731,3.731,0,0,0-1.3-.452C8.846,3.493,8.61,3.482,8.374,3.485Zm.013.852c.192,0,.413.009.693.013.044,0,.454.176,1.025.4a6.671,6.671,0,0,0,1.97.412V7.877l-.986.333h-.026l-.027.013-1.291.653a1.512,1.512,0,0,0-.319-.532L9.4,8.3,7.588,6.081l-.267-.333-.333.267-1.144.932a.9.9,0,0,1-1.012.04.83.83,0,0,1-.16-.106L6.615,5.269l.026-.026a2.868,2.868,0,0,1,1.238-.852,2.01,2.01,0,0,1,.506-.054ZM5.42,4.35a3.106,3.106,0,0,1,.426.013,1.871,1.871,0,0,1,.346.147c-.043.04-.075.063-.12.106l-.026.027-2.33,1.93-.36.293.319.333a2.806,2.806,0,0,0,.785.559,1.857,1.857,0,0,0,1.877-.106l.027-.027.826-.678,1.571,1.93.013.027.013.013a.7.7,0,0,1,0,1s0,.009,0,.013l-.066.041-.559-.759-.693.506.546.732c-.221.15-.321.228-.559.387l-.572-.772-.693.506.546.732c-.049.03-.148.1-.187.12a1.523,1.523,0,0,1-.626.186A.7.7,0,0,1,5.46,11.5l-.013-.013L2.6,8.331l-.054-.067-.693-.347V5.162a6.875,6.875,0,0,0,1.97-.4c.569-.218.975-.4,1.025-.4Z"
}, null, -1);
function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, normalizeProps(guardReactiveProps(_ctx.$props)), {
    default: withCtx(() => [
      _hoisted_1$Y
    ]),
    _: 1
  }, 16);
}
var TYPIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$11, [["render", _sfc_render$11]]);
var QuestionContextMenu_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$10 = {
  name: "QuestionContextMenu",
  props: {
    questionId: { type: String, default: "" },
    yCoord: { type: Number, default: 0 },
    options: { type: Array, default: () => ["duplicate", "delete"] }
  },
  emits: ["click:duplicate", "click:delete", "click:gotologicjump"]
};
const _hoisted_1$X = ["onClick"];
function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: "context-menu absolute bg-white border rounded z-40 text-xs",
    style: normalizeStyle({ top: $props.yCoord + "px" })
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.options, (option2) => {
      return openBlock(), createElementBlock("div", {
        key: `question-context-menu${option2}`,
        class: "py-2 px-3 capitalize border-b cursor-pointer hover:bg-indigo-600 hover:text-white last:border-b-0 transition-all duration-300",
        onClick: ($event) => _ctx.$emit(`click:${option2.replaceAll(" ", "")}`, $props.questionId)
      }, toDisplayString(option2), 9, _hoisted_1$X);
    }), 128))
  ], 4);
}
var QuestionContextMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$10, [["render", _sfc_render$10], ["__scopeId", "data-v-0dce78f3"]]);
var vClickOutside_umd = { exports: {} };
(function(module2, exports2) {
  !function(e2, n2) {
    module2.exports = n2();
  }(commonjsGlobal, function() {
    var e2 = "__v-click-outside", n2 = "undefined" != typeof window, t2 = "undefined" != typeof navigator, r2 = n2 && ("ontouchstart" in window || t2 && navigator.msMaxTouchPoints > 0) ? ["touchstart"] : ["click"], i2 = function(e3) {
      var n3 = e3.event, t3 = e3.handler;
      (0, e3.middleware)(n3) && t3(n3);
    }, a2 = function(n3, t3) {
      var a3 = function(e3) {
        var n4 = "function" == typeof e3;
        if (!n4 && "object" != typeof e3)
          throw new Error("v-click-outside: Binding value must be a function or an object");
        return { handler: n4 ? e3 : e3.handler, middleware: e3.middleware || function(e4) {
          return e4;
        }, events: e3.events || r2, isActive: !(false === e3.isActive), detectIframe: !(false === e3.detectIframe), capture: Boolean(e3.capture) };
      }(t3.value), o3 = a3.handler, d3 = a3.middleware, c2 = a3.detectIframe, u2 = a3.capture;
      if (a3.isActive) {
        if (n3[e2] = a3.events.map(function(e3) {
          return { event: e3, srcTarget: document.documentElement, handler: function(e4) {
            return function(e5) {
              var n4 = e5.el, t4 = e5.event, r3 = e5.handler, a4 = e5.middleware, o4 = t4.path || t4.composedPath && t4.composedPath();
              (o4 ? o4.indexOf(n4) < 0 : !n4.contains(t4.target)) && i2({ event: t4, handler: r3, middleware: a4 });
            }({ el: n3, event: e4, handler: o3, middleware: d3 });
          }, capture: u2 };
        }), c2) {
          var l2 = { event: "blur", srcTarget: window, handler: function(e3) {
            return function(e4) {
              var n4 = e4.el, t4 = e4.event, r3 = e4.handler, a4 = e4.middleware;
              setTimeout(function() {
                var e5 = document.activeElement;
                e5 && "IFRAME" === e5.tagName && !n4.contains(e5) && i2({ event: t4, handler: r3, middleware: a4 });
              }, 0);
            }({ el: n3, event: e3, handler: o3, middleware: d3 });
          }, capture: u2 };
          n3[e2] = [].concat(n3[e2], [l2]);
        }
        n3[e2].forEach(function(t4) {
          var r3 = t4.event, i3 = t4.srcTarget, a4 = t4.handler;
          return setTimeout(function() {
            n3[e2] && i3.addEventListener(r3, a4, u2);
          }, 0);
        });
      }
    }, o2 = function(n3) {
      (n3[e2] || []).forEach(function(e3) {
        return e3.srcTarget.removeEventListener(e3.event, e3.handler, e3.capture);
      }), delete n3[e2];
    }, d2 = n2 ? { beforeMount: a2, updated: function(e3, n3) {
      var t3 = n3.value, r3 = n3.oldValue;
      JSON.stringify(t3) !== JSON.stringify(r3) && (o2(e3), a2(e3, { value: t3 }));
    }, unmounted: o2 } : {};
    return { install: function(e3) {
      e3.directive("click-outside", d2);
    }, directive: d2 };
  });
})(vClickOutside_umd);
var vClickOutside = vClickOutside_umd.exports;
var QuestionCard_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$$ = {
  name: "QuestionCard",
  components: {
    QuestionContextMenu,
    DotsVerticalIcon: render$h,
    ContrastIcon,
    TYPIcon,
    ArrowLeftSquareIcon
  },
  directives: {
    clickOutside: vClickOutside.directive
  },
  props: {
    title: { type: String, default: "" },
    id: { type: [Number, String], default: void 0 },
    tooltipTitle: { type: String, default: "" },
    index: { type: Number, default: null },
    category: { type: String, required: true },
    questionType: { type: String, default: () => "" },
    firstRow: { type: Boolean, default: false }
  },
  emits: ["click", "clickOptions", "click:goToLogicJump"],
  data: function() {
    return {
      QUESTION_CATEGORY_TYP,
      showContextMenu: false
    };
  },
  computed: {
    iconLetter: function() {
      return this.category === QUESTION_CATEGORY_TYP ? "TP" : "Q";
    },
    categoryTitle: function() {
      return QUESTION_CATEGORY_NAME[this.category];
    },
    typeTitle: function() {
      return QUESTION_TYPE_NAME[this.questionType];
    }
  },
  methods: {
    handleClickOptions: function() {
      this.showContextMenu = true;
    },
    hideContextMenu: function() {
      this.showContextMenu = false;
    },
    handleClickGotologicjump: function(id) {
      this.$emit("click:goToLogicJump", id);
    }
  }
};
const _hoisted_1$W = { class: "relative group" };
const _hoisted_2$w = { class: "bg-navy text-white rounded px-2 py-1 text-xs" };
const _hoisted_3$p = { key: 1 };
const _hoisted_4$e = { key: 0 };
const _hoisted_5$e = /* @__PURE__ */ createTextVNode("\xA0");
const _hoisted_6$b = { class: "bg-white rounded-full font-bold w-7 h-7 flex items-center justify-around" };
const _hoisted_7$9 = {
  key: 1,
  class: "font-bold"
};
const _hoisted_8$6 = { class: "w-2/3 ml-2 truncate" };
function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TYPIcon = resolveComponent("TYPIcon");
  const _component_ContrastIcon = resolveComponent("ContrastIcon");
  const _component_ArrowLeftSquareIcon = resolveComponent("ArrowLeftSquareIcon");
  const _component_DotsVerticalIcon = resolveComponent("DotsVerticalIcon");
  const _component_QuestionContextMenu = resolveComponent("QuestionContextMenu");
  const _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createElementBlock("div", _hoisted_1$W, [
    createElementVNode("div", {
      class: normalizeClass(["tooltip absolute hidden group-hover:block z-40", [$props.firstRow ? "top-full tooltip-bottom" : "bottom-full"]])
    }, [
      createElementVNode("div", _hoisted_2$w, [
        createElementVNode("table", null, [
          createElementVNode("tbody", null, [
            createElementVNode("tr", null, [
              createElementVNode("td", null, [
                _ctx.QUESTION_CATEGORY_TYP === $props.category ? (openBlock(), createBlock(_component_TYPIcon, {
                  key: 0,
                  class: "h-6 pt-1"
                })) : (openBlock(), createElementBlock("strong", _hoisted_3$p, "?"))
              ]),
              createElementVNode("td", null, toDisplayString($props.tooltipTitle || $options.categoryTitle), 1)
            ]),
            $options.typeTitle ? (openBlock(), createElementBlock("tr", _hoisted_4$e, [
              createElementVNode("td", null, [
                createVNode(_component_ContrastIcon, { class: "h-3 w-3 text-white" }),
                _hoisted_5$e
              ]),
              createElementVNode("td", null, toDisplayString($options.typeTitle), 1)
            ])) : createCommentVNode("", true)
          ])
        ])
      ])
    ], 2),
    createElementVNode("div", {
      class: normalizeClass(["flex items-center question-list-item py-1 pl-2 pr-1 text-xs rounded-lg mt-1 cursor-pointer h-10", `${$props.category}`]),
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click"))
    }, [
      createElementVNode("div", _hoisted_6$b, [
        $props.category === "form-transfer" ? (openBlock(), createBlock(_component_ArrowLeftSquareIcon, {
          key: 0,
          class: "h-4 w-4"
        })) : (openBlock(), createElementBlock("small", _hoisted_7$9, toDisplayString($options.iconLetter) + toDisplayString($props.index), 1))
      ]),
      createElementVNode("div", _hoisted_8$6, toDisplayString($props.title || "No title"), 1)
    ], 2),
    createElementVNode("button", {
      id: "questionContextMenuButton",
      class: "absolute right-0.5 top-0.5 bottom-0",
      onClick: _cache[1] || (_cache[1] = (...args) => $options.handleClickOptions && $options.handleClickOptions(...args))
    }, [
      createVNode(_component_DotsVerticalIcon, { class: "text-gray-500 w-4" })
    ]),
    _ctx.showContextMenu ? withDirectives((openBlock(), createBlock(_component_QuestionContextMenu, {
      key: 0,
      "question-id": $props.id,
      class: "w-32",
      style: { "left": "110%" },
      options: ["go to logic jump", ""],
      "onClick:gotologicjump": $options.handleClickGotologicjump
    }, null, 8, ["question-id", "onClick:gotologicjump"])), [
      [_directive_click_outside, $options.hideContextMenu]
    ]) : createCommentVNode("", true)
  ]);
}
var QuestionCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$$, [["render", _sfc_render$$], ["__scopeId", "data-v-2205f6c1"]]);
const _sfc_main$_ = {
  name: "ExitSignIcon",
  components: { IconBase },
  props: iconProps
};
const _hoisted_1$V = /* @__PURE__ */ createElementVNode("path", {
  class: "fill-current",
  d: "M14.8,3.852a1.235,1.235,0,0,0-.881-.364H9.462V1H8.218V3.487H3.244A1.245,1.245,0,0,0,2,4.731V8.462A1.245,1.245,0,0,0,3.244,9.706H8.218v8.706H9.462V9.706h4.46a1.235,1.235,0,0,0,.881-.364L17.546,6.6Zm-.881,4.61H3.244V4.731H13.922L15.787,6.6Z"
}, null, -1);
function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, normalizeProps(guardReactiveProps(_ctx.$props)), {
    default: withCtx(() => [
      _hoisted_1$V
    ]),
    _: 1
  }, 16);
}
var ExitSignIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$_, [["render", _sfc_render$_]]);
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module2, exports2) {
  (function() {
    var undefined$1;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE2 = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT2 = 800, HOT_SPAN2 = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", domExcTag = "[object DOMException]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint2 = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags2 = {};
    typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
    typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
    var cloneableTags = {};
    cloneableTags[argsTag2] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag2] = cloneableTags[dataViewTag2] = cloneableTags[boolTag2] = cloneableTags[dateTag2] = cloneableTags[float32Tag2] = cloneableTags[float64Tag2] = cloneableTags[int8Tag2] = cloneableTags[int16Tag2] = cloneableTags[int32Tag2] = cloneableTags[mapTag2] = cloneableTags[numberTag2] = cloneableTags[objectTag2] = cloneableTags[regexpTag2] = cloneableTags[setTag2] = cloneableTags[stringTag2] = cloneableTags[symbolTag] = cloneableTags[uint8Tag2] = cloneableTags[uint8ClampedTag2] = cloneableTags[uint16Tag2] = cloneableTags[uint32Tag2] = true;
    cloneableTags[errorTag2] = cloneableTags[funcTag2] = cloneableTags[weakMapTag2] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
    var freeExports2 = exports2 && !exports2.nodeType && exports2;
    var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
    var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
    var freeProcess2 = moduleExports2 && freeGlobal2.process;
    var nodeUtil2 = function() {
      try {
        var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil2 && nodeUtil2.isArrayBuffer, nodeIsDate = nodeUtil2 && nodeUtil2.isDate, nodeIsMap = nodeUtil2 && nodeUtil2.isMap, nodeIsRegExp = nodeUtil2 && nodeUtil2.isRegExp, nodeIsSet = nodeUtil2 && nodeUtil2.isSet, nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
    function apply2(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        var value = array[index2];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (comparator(value, array[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset2 = array.length;
      while (++index2 < length) {
        array[offset2 + index2] = values[index2];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (comparator(array[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index2 = -1, length = array.length;
      while (++index2 < length) {
        var current = iteratee(array[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes2(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object, props2) {
      return arrayMap(props2, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary2(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props2) {
      return arrayMap(props2, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue2(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data2, result = [];
      while (!(data2 = iterator.next()).done) {
        result.push(data2.value);
      }
      return result;
    }
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg2(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index2 = -1, length = array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root2 : _2.defaults(root2.Object(), context, _2.pick(root2, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto2 = Array2.prototype, funcProto2 = Function2.prototype, objectProto2 = Object2.prototype;
      var coreJsData2 = context["__core-js_shared__"];
      var funcToString2 = funcProto2.toString;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey2 = function() {
        var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString2 = objectProto2.toString;
      var objectCtorString2 = funcToString2.call(Object2);
      var oldDash = root2._;
      var reIsNative2 = RegExp2(
        "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports2 ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype2 = overArg2(Object2.getPrototypeOf, Object2), objectCreate2 = Object2.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty2 = function() {
        try {
          var func = getNative2(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys = overArg2(Object2.keys, Object2), nativeMax2 = Math2.max, nativeMin = Math2.min, nativeNow2 = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
      var DataView = getNative2(context, "DataView"), Map2 = getNative2(context, "Map"), Promise2 = getNative2(context, "Promise"), Set2 = getNative2(context, "Set"), WeakMap = getNative2(context, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
      var metaMap = WeakMap && new WeakMap();
      var realNames = {};
      var dataViewCtorString = toSource2(DataView), mapCtorString = toSource2(Map2), promiseCtorString = toSource2(Promise2), setCtorString = toSource2(Set2), weakMapCtorString = toSource2(WeakMap);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate2 = function() {
        function object() {
        }
        return function(proto2) {
          if (!isObject2(proto2)) {
            return {};
          }
          if (objectCreate2) {
            return objectCreate2(proto2);
          }
          object.prototype = proto2;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": {
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate2(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray2(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray2(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray2(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end2 = view.end, length = end2 - start2, index2 = isRight ? end2 : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array[index2];
            while (++iterIndex < iterLength) {
              var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed2 = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed2;
              } else if (!computed2) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate2(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash2(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear2() {
        this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
        this.size = 0;
      }
      function hashDelete2(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet2(key) {
        var data2 = this.__data__;
        if (nativeCreate2) {
          var result2 = data2[key];
          return result2 === HASH_UNDEFINED2 ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data2, key) ? data2[key] : undefined$1;
      }
      function hashHas2(key) {
        var data2 = this.__data__;
        return nativeCreate2 ? data2[key] !== undefined$1 : hasOwnProperty2.call(data2, key);
      }
      function hashSet2(key, value) {
        var data2 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data2[key] = nativeCreate2 && value === undefined$1 ? HASH_UNDEFINED2 : value;
        return this;
      }
      Hash2.prototype.clear = hashClear2;
      Hash2.prototype["delete"] = hashDelete2;
      Hash2.prototype.get = hashGet2;
      Hash2.prototype.has = hashHas2;
      Hash2.prototype.set = hashSet2;
      function ListCache2(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear2() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete2(key) {
        var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index2 == lastIndex) {
          data2.pop();
        } else {
          splice2.call(data2, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet2(key) {
        var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
        return index2 < 0 ? undefined$1 : data2[index2][1];
      }
      function listCacheHas2(key) {
        return assocIndexOf2(this.__data__, key) > -1;
      }
      function listCacheSet2(key, value) {
        var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
        if (index2 < 0) {
          ++this.size;
          data2.push([key, value]);
        } else {
          data2[index2][1] = value;
        }
        return this;
      }
      ListCache2.prototype.clear = listCacheClear2;
      ListCache2.prototype["delete"] = listCacheDelete2;
      ListCache2.prototype.get = listCacheGet2;
      ListCache2.prototype.has = listCacheHas2;
      ListCache2.prototype.set = listCacheSet2;
      function MapCache2(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear2() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map2 || ListCache2)(),
          "string": new Hash2()
        };
      }
      function mapCacheDelete2(key) {
        var result2 = getMapData2(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet2(key) {
        return getMapData2(this, key).get(key);
      }
      function mapCacheHas2(key) {
        return getMapData2(this, key).has(key);
      }
      function mapCacheSet2(key, value) {
        var data2 = getMapData2(this, key), size2 = data2.size;
        data2.set(key, value);
        this.size += data2.size == size2 ? 0 : 1;
        return this;
      }
      MapCache2.prototype.clear = mapCacheClear2;
      MapCache2.prototype["delete"] = mapCacheDelete2;
      MapCache2.prototype.get = mapCacheGet2;
      MapCache2.prototype.has = mapCacheHas2;
      MapCache2.prototype.set = mapCacheSet2;
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache2();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED2);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack2(entries) {
        var data2 = this.__data__ = new ListCache2(entries);
        this.size = data2.size;
      }
      function stackClear2() {
        this.__data__ = new ListCache2();
        this.size = 0;
      }
      function stackDelete2(key) {
        var data2 = this.__data__, result2 = data2["delete"](key);
        this.size = data2.size;
        return result2;
      }
      function stackGet2(key) {
        return this.__data__.get(key);
      }
      function stackHas2(key) {
        return this.__data__.has(key);
      }
      function stackSet2(key, value) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache2) {
          var pairs = data2.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
            pairs.push([key, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache2(pairs);
        }
        data2.set(key, value);
        this.size = data2.size;
        return this;
      }
      Stack2.prototype.clear = stackClear2;
      Stack2.prototype["delete"] = stackDelete2;
      Stack2.prototype.get = stackGet2;
      Stack2.prototype.has = stackHas2;
      Stack2.prototype.set = stackSet2;
      function arrayLikeKeys2(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes2(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex2(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n2) {
        return shuffleSelf(copyArray2(array), baseClamp(n2, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray2(array));
      }
      function assignMergeValue2(object, key, value) {
        if (value !== undefined$1 && !eq2(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue2(object, key, value);
        }
      }
      function assignValue2(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue2(object, key, value);
        }
      }
      function assocIndexOf2(array, key) {
        var length = array.length;
        while (length--) {
          if (eq2(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source2) {
        return object && copyObject2(source2, keys2(source2), object);
      }
      function baseAssignIn(object, source2) {
        return object && copyObject2(source2, keysIn2(source2), object);
      }
      function baseAssignValue2(object, key, value) {
        if (key == "__proto__" && defineProperty2) {
          defineProperty2(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$1 : get2(object, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$1) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray2(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag2 || tag == genTag2;
          if (isBuffer2(value)) {
            return cloneBuffer2(value, isDeep);
          }
          if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject2(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack2());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn2 : keys2;
        var props2 = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props2 || value, function(subValue, key2) {
          if (props2) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue2(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source2) {
        var props2 = keys2(source2);
        return function(object) {
          return baseConformsTo(object, source2, props2);
        };
      }
      function baseConformsTo(object, source2, props2) {
        var length = props2.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props2[length], predicate = source2[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary2(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE2) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed2 = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed2, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index2, collection2) {
          result2 = !!predicate(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          var value = array[index2], current = iteratee2(value);
          if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed2))) {
            var computed2 = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start2, end2) {
        var length = array.length;
        start2 = toInteger(start2);
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end2 = end2 === undefined$1 || end2 > length ? length : toInteger(end2);
        if (end2 < 0) {
          end2 += length;
        }
        end2 = start2 > end2 ? 0 : toLength(end2);
        while (start2 < end2) {
          array[start2++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor2 = createBaseFor2();
      var baseForRight = createBaseFor2(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor2(object, iteratee2, keys2);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys2);
      }
      function baseFunctions(object, props2) {
        return arrayFilter(props2, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag2(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag2 : nullTag2;
        }
        return symToStringTag2 && symToStringTag2 in Object2(value) ? getRawTag2(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start2, end2) {
        return number >= nativeMin(start2, end2) && number < nativeMax2(start2, end2);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary2(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed2) : includes2(result2, computed2, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed2) : includes2(arrays[othIndex], computed2, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply2(func, object, args);
      }
      function baseIsArguments2(value) {
        return isObjectLike2(value) && baseGetTag2(value) == argsTag2;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag2;
      }
      function baseIsDate(value) {
        return isObjectLike2(value) && baseGetTag2(value) == dateTag2;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag2 : getTag(object), othTag = othIsArr ? arrayTag2 : getTag(other);
        objTag = objTag == argsTag2 ? objectTag2 : objTag;
        othTag = othTag == argsTag2 ? objectTag2 : othTag;
        var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike2(value) && getTag(value) == mapTag2;
      }
      function baseIsMatch(object, source2, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index2--) {
          var data2 = matchData[index2];
          if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data2 = matchData[index2];
          var key = data2[0], objValue = object[key], srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack2();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source2, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative2(value) {
        if (!isObject2(value) || isMasked2(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
        return pattern.test(toSource2(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike2(value) && baseGetTag2(value) == regexpTag2;
      }
      function baseIsSet(value) {
        return isObjectLike2(value) && getTag(value) == setTag2;
      }
      function baseIsTypedArray2(value) {
        return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype2(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn2(object) {
        if (!isObject2(object)) {
          return nativeKeysIn2(object);
        }
        var isProto = isPrototype2(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index2] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source2) {
        var matchData = getMatchData(source2);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source2 || baseIsMatch(object, source2, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge2(object, source2, srcIndex, customizer, stack) {
        if (object === source2) {
          return;
        }
        baseFor2(source2, function(srcValue, key) {
          stack || (stack = new Stack2());
          if (isObject2(srcValue)) {
            baseMergeDeep2(object, source2, key, srcIndex, baseMerge2, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet2(object, key), srcValue, key + "", object, source2, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue2(object, key, newValue);
          }
        }, keysIn2);
      }
      function baseMergeDeep2(object, source2, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet2(object, key), srcValue = safeGet2(source2, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue2(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source2, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject2(objValue)) {
              newValue = copyArray2(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer2(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray2(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
            newValue = objValue;
            if (isArguments2(objValue)) {
              newValue = toPlainObject2(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject2(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue2(object, key, newValue);
      }
      function baseNth(array, n2) {
        var length = array.length;
        if (!length) {
          return;
        }
        n2 += n2 < 0 ? length : 0;
        return isIndex2(n2, length) ? array[n2] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity2];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary2(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path = paths[index2], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf3 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray2(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary2(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf3(seen, computed2, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice2.call(seen, fromIndex, 1);
            }
            splice2.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex2(index2)) {
              splice2.call(array, index2, 1);
            } else {
              baseUnset(array, index2);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start2, end2, step, fromRight) {
        var index2 = -1, length = nativeMax2(nativeCeil((end2 - start2) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start2;
          start2 += step;
        }
        return result2;
      }
      function baseRepeat(string, n2) {
        var result2 = "";
        if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER2) {
          return result2;
        }
        do {
          if (n2 % 2) {
            result2 += string;
          }
          n2 = nativeFloor(n2 / 2);
          if (n2) {
            string += string;
          }
        } while (n2);
        return result2;
      }
      function baseRest2(func, start2) {
        return setToString2(overRest2(func, start2, identity2), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n2) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n2, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key = toKey(path[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex2(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue2(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity2 : function(func, data2) {
        metaMap.set(func, data2);
        return func;
      };
      var baseSetToString2 = !defineProperty2 ? identity2 : function(func, string) {
        return defineProperty2(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant2(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start2, end2) {
        var index2 = -1, length = array.length;
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end2 = end2 > length ? length : end2;
        if (end2 < 0) {
          end2 += length;
        }
        length = start2 > end2 ? 0 : end2 - start2 >>> 0;
        start2 >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array[index2 + start2];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index2, collection2) {
          result2 = predicate(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array[mid];
            if (computed2 !== null && !isSymbol(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity2, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array[mid]), othIsDefined = computed2 !== undefined$1, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value : computed2 < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq2(computed2, seen)) {
            var seen = computed2;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE2) {
          var set3 = iteratee2 ? null : createSet(array);
          if (set3) {
            return setToArray(set3);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed2);
              }
              result2.push(value);
            } else if (!includes2(seen, computed2, comparator)) {
              if (seen !== result2) {
                seen.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props2, values2, assignFunc) {
        var index2 = -1, length = props2.length, valsLength = values2.length, result2 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : undefined$1;
          assignFunc(result2, props2[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject2(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity2;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString3(value));
      }
      var castRest = baseRest2;
      function castSlice(array, start2, end2) {
        var length = array.length;
        end2 = end2 === undefined$1 ? length : end2;
        return !start2 && end2 >= length ? array : baseSlice(array, start2, end2);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root2.clearTimeout(id);
      };
      function cloneBuffer2(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer2(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray2(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order2 = orders[index2];
            return result2 * (order2 == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset2 = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset2 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray2(source2, array) {
        var index2 = -1, length = source2.length;
        array || (array = Array2(length));
        while (++index2 < length) {
          array[index2] = source2[index2];
        }
        return array;
      }
      function copyObject2(source2, props2, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props2.length;
        while (++index2 < length) {
          var key = props2[index2];
          var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source2[key];
          }
          if (isNew) {
            baseAssignValue2(object, key, newValue);
          } else {
            assignValue2(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source2, object) {
        return copyObject2(source2, getSymbols(source2), object);
      }
      function copySymbolsIn(source2, object) {
        return copyObject2(source2, getSymbolsIn(source2), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner2(assigner) {
        return baseRest2(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index2 < length) {
            var source2 = sources[index2];
            if (source2) {
              assigner(object, source2, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike2(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor2(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props2 = keysFunc(object), length = props2.length;
          while (length--) {
            var key = props2[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn3 = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return fn3.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString3(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate2(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length
            );
          }
          var fn3 = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return apply2(fn3, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike2(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys2(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
              wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn3 = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root2 && this instanceof wrapper) {
            fn3 = Ctor || createCtor(fn3);
          }
          return fn3.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary2(getIteratee()));
          return baseRest2(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply2(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn3 = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply2(fn3, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start2, end2, step) {
          if (step && typeof step != "number" && isIterateeCall2(start2, end2, step)) {
            end2 = step = undefined$1;
          }
          start2 = toFinite(start2);
          if (end2 === undefined$1) {
            end2 = start2;
            start2 = 0;
          } else {
            end2 = toFinite(end2);
          }
          step = step === undefined$1 ? start2 < end2 ? 1 : -1 : toFinite(step);
          return baseRange(start2, end2, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString3(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString3(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag2) {
            return mapToArray(object);
          }
          if (tag == setTag2) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax2(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data2 = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data2) {
          mergeData(newData, data2);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax2(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data2 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq2(objValue, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source2, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge2(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag2:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag2:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag2:
          case dateTag2:
          case numberTag2:
            return eq2(+object, +other);
          case errorTag2:
            return object.name == other.name && object.message == other.message;
          case regexpTag2:
          case stringTag2:
            return object == other + "";
          case mapTag2:
            var convert = mapToArray;
          case setTag2:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString2(overRest2(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys2, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn2, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data2 = array[length], otherFunc = data2.func;
          if (otherFunc == null || otherFunc == func) {
            return data2.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData2(map3, key) {
        var data2 = map3.__data__;
        return isKeyable2(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      function getMatchData(object) {
        var result2 = keys2(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative2(object, key) {
        var value = getValue2(object, key);
        return baseIsNative2(value) ? value : undefined$1;
      }
      function getRawTag2(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag = value[symToStringTag2];
        try {
          value[symToStringTag2] = undefined$1;
          var unmasked = true;
        } catch (e2) {
        }
        var result2 = nativeObjectToString2.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag2] = tag;
          } else {
            delete value[symToStringTag2];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable2.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype2(object);
        }
        return result2;
      };
      var getTag = baseGetTag2;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag(new Map2()) != mapTag2 || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag2 || WeakMap && getTag(new WeakMap()) != weakMapTag2) {
        getTag = function(value) {
          var result2 = baseGetTag2(value), Ctor = result2 == objectTag2 ? value.constructor : undefined$1, ctorString = Ctor ? toSource2(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag2;
              case mapCtorString:
                return mapTag2;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag2;
              case weakMapCtorString:
                return weakMapTag2;
            }
          }
          return result2;
        };
      }
      function getView(start2, end2, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data2 = transforms[index2], size2 = data2.size;
          switch (data2.type) {
            case "drop":
              start2 += size2;
              break;
            case "dropRight":
              end2 -= size2;
              break;
            case "take":
              end2 = nativeMin(end2, start2 + size2);
              break;
            case "takeRight":
              start2 = nativeMax2(start2, end2 - size2);
              break;
          }
        }
        return { "start": start2, "end": end2 };
      }
      function getWrapDetails(source2) {
        var match = source2.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length = path.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength2(length) && isIndex2(key, length) && (isArray2(object) || isArguments2(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject2(object) {
        return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag2:
            return cloneArrayBuffer2(object);
          case boolTag2:
          case dateTag2:
            return new Ctor(+object);
          case dataViewTag2:
            return cloneDataView(object, isDeep);
          case float32Tag2:
          case float64Tag2:
          case int8Tag2:
          case int16Tag2:
          case int32Tag2:
          case uint8Tag2:
          case uint8ClampedTag2:
          case uint16Tag2:
          case uint32Tag2:
            return cloneTypedArray2(object, isDeep);
          case mapTag2:
            return new Ctor();
          case numberTag2:
          case stringTag2:
            return new Ctor(object);
          case regexpTag2:
            return cloneRegExp(object);
          case setTag2:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source2, details) {
        var length = details.length;
        if (!length) {
          return source2;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source2.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex2(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER2 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall2(value, index2, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike2(object) && isIndex2(index2, object.length) : type == "string" && index2 in object) {
          return eq2(object[index2], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable2(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data2 = getData(other);
        return !!data2 && func === data2[0];
      }
      function isMasked2(func) {
        return !!maskSrcKey2 && maskSrcKey2 in func;
      }
      var isMaskable = coreJsData2 ? isFunction2 : stubFalse2;
      function isPrototype2(value) {
        var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
        return value === proto2;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data2, source2) {
        var bitmask = data2[1], srcBitmask = source2[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source2[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source2[7].length <= source2[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data2;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data2[2] = source2[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source2[3];
        if (value) {
          var partials = data2[3];
          data2[3] = partials ? composeArgs(partials, value, source2[4]) : value;
          data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source2[4];
        }
        value = source2[5];
        if (value) {
          partials = data2[5];
          data2[5] = partials ? composeArgsRight(partials, value, source2[6]) : value;
          data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source2[6];
        }
        value = source2[7];
        if (value) {
          data2[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data2[8] = data2[8] == null ? source2[8] : nativeMin(data2[8], source2[8]);
        }
        if (data2[9] == null) {
          data2[9] = source2[9];
        }
        data2[0] = source2[0];
        data2[1] = newBitmask;
        return data2;
      }
      function nativeKeysIn2(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString2.call(value);
      }
      function overRest2(func, start2, transform2) {
        start2 = nativeMax2(start2 === undefined$1 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax2(args.length - start2, 0), array = Array2(length);
          while (++index2 < length) {
            array[index2] = args[start2 + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start2 + 1);
          while (++index2 < start2) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start2] = transform2(array);
          return apply2(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray2(array);
        while (length--) {
          var index2 = indexes[length];
          array[length] = isIndex2(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array;
      }
      function safeGet2(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut2(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root2.setTimeout(func, wait);
      };
      var setToString2 = shortOut2(baseSetToString2);
      function setWrapToString(wrapper, reference2, bitmask) {
        var source2 = reference2 + "";
        return setToString2(wrapper, insertWrapDetails(source2, updateWrapDetails(getWrapDetails(source2), bitmask)));
      }
      function shortOut2(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT2) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index2 = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined$1 ? length : size2;
        while (++index2 < size2) {
          var rand = baseRandom(index2, lastIndex), value = array[rand];
          array[rand] = array[index2];
          array[index2] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource2(func) {
        if (func != null) {
          try {
            return funcToString2.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray2(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall2(array, size2, guard) : size2 === undefined$1) {
          size2 = 1;
        } else {
          size2 = nativeMax2(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array, index2, index2 += size2);
        }
        return result2;
      }
      function compact(array) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray2(array) ? copyArray2(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest2(function(array, values2) {
        return isArrayLikeObject2(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject2, true)) : [];
      });
      var differenceBy = baseRest2(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject2(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest2(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject2(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject2(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject2, true), undefined$1, comparator) : [];
      });
      function drop3(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function dropRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start2, end2) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start2 && typeof start2 != "number" && isIterateeCall2(array, value, start2)) {
          start2 = 0;
          end2 = length;
        }
        return baseFill(array, value, start2, end2);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax2(length + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax2(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf2(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax2(length + index2, 0);
        }
        return baseIndexOf(array, value, index2);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest2(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest2(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest2(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax2(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      function nth(array, n2) {
        return array && array.length ? baseNth(array, toInteger(n2)) : undefined$1;
      }
      var pull = baseRest2(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index2) {
          return isIndex2(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start2, end2) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end2 && typeof end2 != "number" && isIterateeCall2(array, start2, end2)) {
          start2 = 0;
          end2 = length;
        } else {
          start2 = start2 == null ? 0 : toInteger(start2);
          end2 = end2 === undefined$1 ? length : toInteger(end2);
        }
        return baseSlice(array, start2, end2);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value);
          if (index2 < length && eq2(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value, true) - 1;
          if (eq2(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n2, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function takeRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest2(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject2, true));
      });
      var unionBy = baseRest2(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest2(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject2, true), undefined$1, comparator);
      });
      function uniq2(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy2(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject2(group)) {
            length = nativeMax2(group.length, length);
            return true;
          }
        });
        return baseTimes2(length, function(index2) {
          return arrayMap(array, baseProperty(index2));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply2(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest2(function(array, values2) {
        return isArrayLikeObject2(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest2(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject2));
      });
      var xorBy = baseRest2(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject2(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject2), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest2(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject2), undefined$1, comparator);
      });
      var zip = baseRest2(unzip);
      function zipObject(props2, values2) {
        return baseZipObject(props2 || [], values2 || [], assignValue2);
      }
      function zipObjectDeep(props2, values2) {
        return baseZipObject(props2 || [], values2 || [], baseSet);
      }
      var zipWith = baseRest2(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start2)) {
          return this.thru(interceptor);
        }
        value = value.slice(start2, +start2 + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray3(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue2(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall2(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find2 = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      function forEach3(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue2(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike2(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax2(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest2(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply2(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue2(result2, key, value);
      });
      function map2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n2, guard) {
        if (guard ? isIterateeCall2(collection, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      function shuffle2(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike2(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag2 || tag == setTag2) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some2(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall2(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest2(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall2(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall2(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now2 = ctxNow || function() {
        return root2.Date.now();
      };
      function after(n2, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n2, guard) {
        n2 = guard ? undefined$1 : n2;
        n2 = func && n2 == null ? func.length : n2;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
      }
      function before(n2, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n2 <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind3 = baseRest2(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind3));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest2(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax2(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now2();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush2() {
          return timerId === undefined$1 ? result2 : trailingEdge(now2());
        }
        function debounced() {
          var time = now2(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush2;
        return debounced;
      }
      var defer = baseRest2(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay2 = baseRest2(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache2)();
        return memoized;
      }
      memoize.Cache = MapCache2;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary2(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary2(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest2(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply2(func, this, args);
        });
      });
      var partial = baseRest2(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest2(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 === undefined$1 ? start2 : toInteger(start2);
        return baseRest2(func, start2);
      }
      function spread3(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 == null ? 0 : nativeMax2(toInteger(start2), 0);
        return baseRest2(function(args) {
          var array = args[start2], otherArgs = castSlice(args, 0, start2);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply2(func, this, otherArgs);
        });
      }
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source2) {
        return source2 == null || baseConformsTo(object, source2, keys2(source2));
      }
      function eq2(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt2 = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments2 = baseIsArguments2(function() {
        return arguments;
      }()) ? baseIsArguments2 : function(value) {
        return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary2(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike2(value) {
        return value != null && isLength2(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject2(value) {
        return isObjectLike2(value) && isArrayLike2(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag2;
      }
      var isBuffer2 = nativeIsBuffer2 || stubFalse2;
      var isDate2 = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
      function isElement2(value) {
        return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty2(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments2(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag2 || tag == setTag2) {
          return !value.size;
        }
        if (isPrototype2(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag2(value);
        return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength2(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary2(nodeIsMap) : baseIsMap;
      function isMatch(object, source2) {
        return object === source2 || baseIsMatch(object, source2, getMatchData(source2));
      }
      function isMatchWith(object, source2, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source2, getMatchData(source2), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative2(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag2;
      }
      function isPlainObject2(value) {
        if (!isObjectLike2(value) || baseGetTag2(value) != objectTag2) {
          return false;
        }
        var proto2 = getPrototype2(value);
        if (proto2 === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto2, "constructor") && proto2.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString2;
      }
      var isRegExp = nodeIsRegExp ? baseUnary2(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
      }
      var isSet = nodeIsSet ? baseUnary2(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag2;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag;
      }
      var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
      function isUndefined2(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike2(value) && getTag(value) == weakMapTag2;
      }
      function isWeakSet(value) {
        return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
      }
      var lt2 = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray3(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike2(value)) {
          return isString2(value) ? stringToArray(value) : copyArray2(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag2 ? mapToArray : tag == setTag2 ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign2 = value < 0 ? -1 : 1;
          return sign2 * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject2(value) {
        return copyObject2(value, keysIn2(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
      }
      function toString3(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner2(function(object, source2) {
        if (isPrototype2(source2) || isArrayLike2(source2)) {
          copyObject2(source2, keys2(source2), object);
          return;
        }
        for (var key in source2) {
          if (hasOwnProperty2.call(source2, key)) {
            assignValue2(object, key, source2[key]);
          }
        }
      });
      var assignIn = createAssigner2(function(object, source2) {
        copyObject2(source2, keysIn2(source2), object);
      });
      var assignInWith = createAssigner2(function(object, source2, srcIndex, customizer) {
        copyObject2(source2, keysIn2(source2), object, customizer);
      });
      var assignWith = createAssigner2(function(object, source2, srcIndex, customizer) {
        copyObject2(source2, keys2(source2), object, customizer);
      });
      var at2 = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate2(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults2 = baseRest2(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source2 = sources[index2];
          var props2 = keysIn2(source2);
          var propsIndex = -1;
          var propsLength = props2.length;
          while (++propsIndex < propsLength) {
            var key = props2[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source2[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest2(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply2(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor2(object, getIteratee(iteratee2, 3), keysIn2);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn2);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions2(object) {
        return object == null ? [] : baseFunctions(object, keys2(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn2(object));
      }
      function get2(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        result2[value] = key;
      }, constant2(identity2));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString2.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest2(baseInvoke);
      function keys2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys(object);
      }
      function keysIn2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn2(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue2(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue2(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge2 = createAssigner2(function(object, source2, srcIndex) {
        baseMerge2(object, source2, srcIndex);
      });
      var mergeWith = createAssigner2(function(object, source2, srcIndex, customizer) {
        baseMerge2(object, source2, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject2(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy2(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy2(object, predicate) {
        if (object == null) {
          return {};
        }
        var props2 = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props2, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index2 < length) {
          var value = object == null ? undefined$1 : object[toKey(path[index2])];
          if (value === undefined$1) {
            index2 = length;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set2(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys2);
      var toPairsIn = createToPairs(keysIn2);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate2(getPrototype2(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
          return iteratee2(accumulator, value, index2, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update2(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys2(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn2(object));
      }
      function clamp2(number, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start2, end2) {
        start2 = toFinite(start2);
        if (end2 === undefined$1) {
          end2 = start2;
          start2 = 0;
        } else {
          end2 = toFinite(end2);
        }
        number = toNumber(number);
        return baseInRange(number, start2, end2);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall2(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString3(string).toLowerCase());
      }
      function deburr(string) {
        string = toString3(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString3(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
        var end2 = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end2) == target;
      }
      function escape(string) {
        string = toString3(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString3(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString3(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString3(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString3(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString3(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n2, guard) {
        if (guard ? isIterateeCall2(string, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        return baseRepeat(toString3(string), n2);
      }
      function replace() {
        var args = arguments, string = toString3(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall2(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString3(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString3(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall2(string, options, guard)) {
          options = undefined$1;
        }
        string = toString3(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source2 = "__p += '";
        var reDelimiters = RegExp2(
          (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source2 += string.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source2 += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source2 += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source2 += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset2 + match.length;
          return match;
        });
        source2 += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source2 = "with (obj) {\n" + source2 + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source2 = (isEvaluating ? source2.replace(reEmptyStringLeading, "") : source2).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source2 = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source2 + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source2).apply(undefined$1, importsValues);
        });
        result2.source = source2;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString3(value).toLowerCase();
      }
      function toUpper(value) {
        return toString3(value).toUpperCase();
      }
      function trim2(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start2, end2).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end2).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start2).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString3(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end2 = length - stringSize(omission);
        if (end2 < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string.slice(0, end2);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end2 += result2.length - end2;
        }
        if (isRegExp(separator)) {
          if (string.slice(end2).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end2 : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end2) != end2) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString3(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString3(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest2(function(func, args) {
        try {
          return apply2(func, undefined$1, args);
        } catch (e2) {
          return isError(e2) ? e2 : new Error2(e2);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue2(object, key, bind3(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest2(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply2(pair[0], this, args)) {
              return apply2(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source2) {
        return baseConforms(baseClone(source2, CLONE_DEEP_FLAG));
      }
      function constant2(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity2(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches2(source2) {
        return baseMatches(baseClone(source2, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest2(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest2(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source2, options) {
        var props2 = keys2(source2), methodNames = baseFunctions(source2, props2);
        if (options == null && !(isObject2(source2) && (methodNames.length || !props2.length))) {
          options = source2;
          source2 = object;
          object = this;
          methodNames = baseFunctions(source2, keys2(source2));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source2[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray2(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root2._ === this) {
          root2._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n2) {
        n2 = toInteger(n2);
        return baseRest2(function(args) {
          return baseNth(args, n2);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse2() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n2, iteratee2) {
        n2 = toInteger(n2);
        if (n2 < 1 || n2 > MAX_SAFE_INTEGER2) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n2 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes2(length, iteratee2);
        while (++index2 < n2) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray2(stringToPath(toString3(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString3(prefix) + id;
      }
      var add2 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max2(array) {
        return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity2);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min2(array) {
        return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$1;
      }
      function minBy2(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract2 = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity2) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at2;
      lodash2.before = before;
      lodash2.bind = bind3;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant2;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay2;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop3;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip2;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions2;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys2;
      lodash2.keysIn = keysIn2;
      lodash2.map = map2;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches2;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy2;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle2;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread3;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray3;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject2;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq2;
      lodash2.uniqBy = uniqBy2;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update2;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add2;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq2;
      lodash2.escape = escape;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find2;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach3;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt2;
      lodash2.gte = gte;
      lodash2.has = has;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity2;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf2;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments2;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer2;
      lodash2.isArrayLike = isArrayLike2;
      lodash2.isArrayLikeObject = isArrayLikeObject2;
      lodash2.isBoolean = isBoolean;
      lodash2.isBuffer = isBuffer2;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty2;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength2;
      lodash2.isMap = isMap;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike2;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol;
      lodash2.isTypedArray = isTypedArray2;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt2;
      lodash2.lte = lte;
      lodash2.max = max2;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min2;
      lodash2.minBy = minBy2;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse2;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now2;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some2;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract2;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString3;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach3;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source2 = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source2[methodName] = func;
          }
        });
        return source2;
      }(), { "chain": false });
      lodash2.VERSION = VERSION2;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined$1 ? 1 : nativeMax2(toInteger(n2), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n2, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity2);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest2(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start2, end2) {
        start2 = toInteger(start2);
        var result2 = this;
        if (result2.__filtered__ && (start2 > 0 || end2 < 0)) {
          return new LazyWrapper(result2);
        }
        if (start2 < 0) {
          result2 = result2.takeRight(-start2);
        } else if (start2) {
          result2 = result2.drop(start2);
        }
        if (end2 !== undefined$1) {
          end2 = toInteger(end2);
          result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start2);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule2) {
      (freeModule2.exports = _2)._ = _2;
      freeExports2._ = _2;
    } else {
      root2._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var _ = lodash.exports;
const _sfc_main$Z = {
  components: { ExitSignIcon, QuestionCard },
  props: {
    question: { type: Object, required: true },
    logic: { type: Array, required: true },
    questions: { type: Array, required: true },
    firstRow: { type: Boolean, default: false }
  },
  emits: ["update:answersCoordinates", "click:goToLogicJump", "click"],
  data: function() {
    return {
      curRefs: this.$refs,
      curQuestion: this.question,
      QUESTION_CATEGORY_TYP,
      QUESTION_CATEGORY_KICK_OFF
    };
  },
  computed: {
    possibleAnswers: function() {
      var _a, _b;
      if (this.question.category === QUESTION_CATEGORY_TYP) {
        return [];
      }
      const answers = [];
      let restOfChoices = ((_a = this.question.properties) == null ? void 0 : _a.choices) || [];
      let otherwise = this.questionIdByIndex(this.question.index + 1);
      for (const l2 of this.logic) {
        if (!l2.goto || l2.conditions.find((c2) => {
          var _a2;
          return ((_a2 = c2.compare_with) == null ? void 0 : _a2.id) ? !this.answerById(c2.compare_with.id) : false;
        })) {
          continue;
        }
        answers.push({
          label: l2.conditions.map((c2) => {
            var _a2, _b2, _c;
            let conditionLabel = (_a2 = c2.compare_with) == null ? void 0 : _a2.val;
            if ((_b2 = c2.compare_with) == null ? void 0 : _b2.id) {
              const choice = this.answerById((_c = c2.compare_with) == null ? void 0 : _c.id);
              conditionLabel = choice.label;
              restOfChoices = restOfChoices.filter((c3) => c3.op === "=== " ? c3.id === choice.id : c3.id !== choice.id);
            }
            return (c2.logic_op ? `${c2.logic_op} ` : "") + (c2.op !== "==" ? ` ${c2.op} ` : "") + conditionLabel;
          }).join(" "),
          goto: l2.type === "form" ? `form-${this.question.id}-${l2.goto}` : l2.goto,
          toForm: l2.type === "form"
        });
        otherwise = l2.otherwise || otherwise;
      }
      if (restOfChoices.length > 0) {
        answers.unshift(...restOfChoices.map((c2) => ({ label: c2.label, goto: otherwise })));
      }
      return answers.length === 0 ? [{
        label: (_b = this.question.properties.choices) == null ? void 0 : _b.map((c2) => c2.label).join("/"),
        goto: this.questionIdByIndex(this.question.index + 1)
      }] : answers;
    },
    answersToForms: function() {
      return this.possibleAnswers.filter((a2) => a2.toForm);
    },
    answersToQuestions: function() {
      return this.possibleAnswers.filter((a2) => !a2.toForm);
    }
  },
  updated() {
    if (this.question.category === QUESTION_CATEGORY_TYP) {
      return;
    }
    if (_.isEqual(this.$refs, this.curRefs) && _.isEqual(this.question, this.curQuestion)) {
      return;
    }
    this.curRefs = this.$refs;
    this.curQuestion = this.question;
    this.$emit(
      "update:answersCoordinates",
      this.question.id,
      Object.keys(this.$refs).map((refname) => {
        const isAnswerToForm = refname.indexOf("af") !== -1;
        const answerIndex = isAnswerToForm ? refname.replace("af", "") : refname.replace("a", "");
        const c2 = this.$refs[refname][0];
        return [
          c2.offsetLeft + (c2.offsetWidth || 10) / 2,
          c2.offsetTop + c2.offsetHeight,
          (isAnswerToForm ? this.answersToForms[answerIndex] : this.answersToQuestions[answerIndex]).goto,
          isAnswerToForm
        ];
      })
    );
  },
  methods: {
    calculateNextQuestionId: function(answerId, answerValue) {
      var _a, _b;
      for (const l2 of this.logic) {
        if (l2.conditions.length > 1 || l2.type === "form") {
          continue;
        }
        for (const condition of l2.conditions) {
          if (compare(
            ((_a = condition.compare_with) == null ? void 0 : _a.id) || condition.compare_with.val,
            condition.op,
            ((_b = condition.compare_with) == null ? void 0 : _b.id) ? answerId : answerValue
          )) {
            return l2.goto;
          }
        }
      }
      return null;
    },
    answerById: function(id) {
      var _a;
      return (_a = this.question.properties.choices) == null ? void 0 : _a.find((c2) => c2.id === id);
    },
    questionIdByIndex: function(i2) {
      var _a;
      return (_a = this.questions[i2 - 1]) == null ? void 0 : _a.id;
    },
    questionIndexById: function(id) {
      var _a;
      return (_a = this.questions.find((q) => q.id === id)) == null ? void 0 : _a.index;
    }
  }
};
const _hoisted_1$U = { class: "pb-20" };
const _hoisted_2$v = { class: "flex gap-2 items-center" };
const _hoisted_3$o = {
  key: 0,
  class: "text-xxs text-gray-500 font-bold"
};
const _hoisted_4$d = { key: 0 };
const _hoisted_5$d = /* @__PURE__ */ createElementVNode("div", { class: "w-1/2 h-20 -mt-1 border-r border-[#BFBFBF]" }, null, -1);
const _hoisted_6$a = { class: "flex justify-center pt-2" };
const _hoisted_7$8 = { class: "text-[#BFBFBF] text-xs flex gap-1 items-end" };
const _hoisted_8$5 = /* @__PURE__ */ createElementVNode("div", null, " Exit ", -1);
function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_QuestionCard = resolveComponent("QuestionCard");
  const _component_ExitSignIcon = resolveComponent("ExitSignIcon");
  return openBlock(), createElementBlock("div", _hoisted_1$U, [
    createElementVNode("div", _hoisted_2$v, [
      createVNode(_component_QuestionCard, {
        id: $props.question.id,
        class: "w-40",
        title: $props.question.title,
        category: $props.question.category,
        type: $props.question.type,
        index: $props.question.index,
        "question-type": $props.question.type,
        "first-row": $props.firstRow,
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click")),
        "onClick:goToLogicJump": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click:goToLogicJump", $event))
      }, null, 8, ["id", "title", "category", "type", "index", "question-type", "first-row"]),
      $options.answersToForms.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$o, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.answersToForms, (c2, index2) => {
          return openBlock(), createElementBlock("div", {
            key: `canvas-question-answer-to-form-${c2.label}`,
            ref_for: true,
            ref: `af${index2}`
          }, toDisplayString(c2.label), 1);
        }), 128))
      ])) : createCommentVNode("", true)
    ]),
    createElementVNode("div", {
      class: normalizeClass(["flex justify-between text-xxs text-gray-500 font-bold w-40 px-2 pt-0.5", { "pl-16": $options.answersToQuestions.length < 3 }])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.answersToQuestions, (c2, index2) => {
        return openBlock(), createElementBlock("div", {
          key: `canvas-question-answer-${c2.label}`,
          ref_for: true,
          ref: `a${index2}`,
          class: normalizeClass(["h-4", { "border-l border-[#BFBFBF]": !c2.label }])
        }, toDisplayString(c2.label), 3);
      }), 128))
    ], 2),
    $props.question.category === _ctx.QUESTION_CATEGORY_TYP ? (openBlock(), createElementBlock("div", _hoisted_4$d, [
      _hoisted_5$d,
      createElementVNode("div", _hoisted_6$a, [
        createElementVNode("div", _hoisted_7$8, [
          createVNode(_component_ExitSignIcon, { class: "h-6 w-6 text-gray-400 fill-current" }),
          _hoisted_8$5
        ])
      ])
    ])) : createCommentVNode("", true)
  ]);
}
var Question$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$Z, [["render", _sfc_render$Z]]);
const _sfc_main$Y = {
  name: "FormTransfer",
  components: {
    QuestionCard
  },
  props: {
    formId: { type: Number, required: true },
    firstRow: { type: Boolean, default: false },
    questionId: { type: String, required: true }
  },
  emits: ["update:goToFormTransfer"]
};
const _hoisted_1$T = { class: "relative" };
function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_QuestionCard = resolveComponent("QuestionCard");
  return openBlock(), createElementBlock("div", _hoisted_1$T, [
    createVNode(_component_QuestionCard, {
      id: $props.questionId,
      class: "w-40",
      title: `Move to form #${$props.formId}`,
      category: "form-transfer",
      "first-row": $props.firstRow,
      "tooltip-title": "From transfer",
      "onClick:goToLogicJump": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:goToFormTransfer", $event))
    }, null, 8, ["id", "title", "first-row"])
  ]);
}
var FormTransfer = /* @__PURE__ */ _export_sfc$1(_sfc_main$Y, [["render", _sfc_render$Y]]);
const _sfc_main$X = {
  name: "Canvas",
  components: { FormTransfer, FlowChart, Question: Question$1 },
  props: {
    questions: { type: Array, required: true },
    logic: { type: Array, required: true }
  },
  emits: ["click:goToLogicJump", "update:goToFormTransfer", "update:currentQuestion"],
  data: function() {
    return {
      answersCoordinates: [],
      questionsCoordinates: {},
      questionsToForm: {},
      showFlowChart: false
    };
  },
  computed: {
    kickOffs: function() {
      return this.questions.filter((q) => q.category === QUESTION_CATEGORY_KICK_OFF);
    },
    followUps: function() {
      const questionRows = [];
      let row = 0;
      this.questions.filter((q) => q.category === QUESTION_CATEGORY_FOLLOW_UP).forEach((q) => {
        if (this.questionsToForm[q.id]) {
          row++;
        }
        questionRows[row] = [...questionRows[row] || [], q];
      });
      return questionRows;
    },
    typs: function() {
      return this.questions.filter((q) => q.category === QUESTION_CATEGORY_TYP);
    }
  },
  mounted() {
    this.questionsCoordinates = this.calculateQuestionsCoordinates();
    setTimeout(() => {
      this.questionsCoordinates = this.calculateQuestionsCoordinates();
      this.showFlowChart = true;
    }, 500);
  },
  methods: {
    logicByQuestionId: function(id) {
      return this.logic.filter((l2) => l2.question_id === id) || [];
    },
    handleUpdateAnswersCoordinates: function(qId, coords) {
      const qRef = this.$refs[qId][0];
      this.answersCoordinates = this.answersCoordinates.filter((c2) => c2.qId !== qId);
      coords.forEach(([x2, y2, toId, toForm]) => {
        if (toForm) {
          this.questionsToForm[qId] = toId;
        }
        this.answersCoordinates.push({ x: qRef.offsetLeft + x2, y: qRef.offsetTop + y2, toId, toForm, qId });
      });
    },
    calculateQuestionsCoordinates: function() {
      return Object.fromEntries(
        Object.keys(this.$refs).map((r2) => {
          var _a;
          return [
            r2,
            {
              x1: this.$refs[r2][0].offsetLeft + (r2.indexOf("form") === 0 ? this.$refs[r2][0].parentNode.offsetLeft : 0),
              x2: this.$refs[r2][0].offsetLeft + this.$refs[r2][0].offsetWidth + (r2.indexOf("form") === 0 ? this.$refs[r2][0].parentNode.offsetLeft : 0),
              y: this.$refs[r2][0].offsetTop + 10 + (r2.indexOf("form") === 0 ? this.$refs[r2][0].parentNode.offsetTop : 0),
              index: ((_a = this.questions.find((q) => q.id === r2)) == null ? void 0 : _a.index) || r2
            }
          ];
        })
      );
    },
    getFormId: function(idSting, qId) {
      return parseInt(idSting.replace("form-", "").replace(`${qId}-`, ""));
    }
  }
};
const _hoisted_1$S = { class: "h-full bg-white bg-[#F8F8F8] overflow-y-auto" };
const _hoisted_2$u = { class: "relative z-10 pt-6 pb-8 px-4" };
const _hoisted_3$n = { class: "flex" };
function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FlowChart = resolveComponent("FlowChart");
  const _component_Question = resolveComponent("Question");
  const _component_FormTransfer = resolveComponent("FormTransfer");
  return openBlock(), createElementBlock("div", _hoisted_1$S, [
    createElementVNode("div", _hoisted_2$u, [
      withDirectives(createVNode(_component_FlowChart, {
        class: "absolute z-0 left-0 top-0 bottom-0 right-0",
        questions: _ctx.questionsCoordinates,
        answers: _ctx.answersCoordinates
      }, null, 8, ["questions", "answers"]), [
        [vShow, _ctx.showFlowChart]
      ]),
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.kickOffs, (question) => {
        return openBlock(), createElementBlock("div", {
          key: `canvas-question-${question.id}`,
          ref_for: true,
          ref: question.id,
          class: "relative z-10 pr-10 grid grid-cols-2"
        }, [
          createVNode(_component_Question, {
            question,
            logic: $options.logicByQuestionId(question.id),
            questions: $props.questions,
            "first-row": true,
            "onUpdate:answersCoordinates": $options.handleUpdateAnswersCoordinates,
            "onClick:goToLogicJump": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click:goToLogicJump", $event)),
            onClick: ($event) => _ctx.$emit("update:currentQuestion", question)
          }, null, 8, ["question", "logic", "questions", "onUpdate:answersCoordinates", "onClick"]),
          _ctx.questionsToForm[question.id] ? (openBlock(), createElementBlock("div", {
            key: 0,
            ref_for: true,
            ref: _ctx.questionsToForm[question.id]
          }, [
            createVNode(_component_FormTransfer, {
              "question-id": question.id,
              "form-id": $options.getFormId(_ctx.questionsToForm[question.id], question.id),
              "first-row": true,
              "onUpdate:goToFormTransfer": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:goToFormTransfer", $event))
            }, null, 8, ["question-id", "form-id"])
          ], 512)) : createCommentVNode("", true)
        ]);
      }), 128)),
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.followUps, (followUpsQ, i2) => {
        return openBlock(), createElementBlock("div", {
          key: `follow-ups-row-${i2}`
        }, [
          createElementVNode("div", {
            class: normalizeClass({
              grid: followUpsQ.length > 2,
              "grid-cols-2": followUpsQ.length === 4,
              "grid-cols-3": followUpsQ.length > 2 && followUpsQ.length !== 4
            })
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(followUpsQ, (question) => {
              return openBlock(), createElementBlock("div", {
                key: `canvas-question-${question.id}`,
                ref_for: true,
                ref: question.id,
                class: "relative z-10 pr-10 grid grid-cols-2"
              }, [
                createVNode(_component_Question, {
                  question,
                  logic: $options.logicByQuestionId(question.id),
                  questions: $props.questions,
                  "onUpdate:answersCoordinates": $options.handleUpdateAnswersCoordinates,
                  "onClick:goToLogicJump": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:goToLogicJump", $event)),
                  onClick: ($event) => _ctx.$emit("update:currentQuestion", question)
                }, null, 8, ["question", "logic", "questions", "onUpdate:answersCoordinates", "onClick"]),
                _ctx.questionsToForm[question.id] ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref_for: true,
                  ref: _ctx.questionsToForm[question.id]
                }, [
                  createVNode(_component_FormTransfer, {
                    "question-id": question.id,
                    "form-id": $options.getFormId(_ctx.questionsToForm[question.id], question.id),
                    "onUpdate:goToFormTransfer": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("update:goToFormTransfer", $event))
                  }, null, 8, ["question-id", "form-id"])
                ], 512)) : createCommentVNode("", true)
              ]);
            }), 128))
          ], 2)
        ]);
      }), 128)),
      createElementVNode("div", _hoisted_3$n, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.typs, (question) => {
          return openBlock(), createElementBlock("div", {
            key: `canvas-question-${question.id}`,
            ref_for: true,
            ref: question.id,
            class: "relative z-10 pr-10"
          }, [
            createVNode(_component_Question, {
              question,
              logic: $options.logicByQuestionId(question.id),
              questions: $props.questions,
              "onUpdate:answersCoordinates": $options.handleUpdateAnswersCoordinates,
              "onClick:goToLogicJump": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click:goToLogicJump", $event)),
              onClick: ($event) => _ctx.$emit("update:currentQuestion", question)
            }, null, 8, ["question", "logic", "questions", "onUpdate:answersCoordinates", "onClick"])
          ]);
        }), 128))
      ])
    ])
  ]);
}
var Canvas$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$X, [["render", _sfc_render$X]]);
const QUESTION_SETTINGS = "question_settings";
const LOGIC_JUMP = "logic_jump";
const FORM_TRANSFER = "form_transfer";
const ADD_EMOJI = "add_emoji";
const HYPERLINK = "hyperlink";
const RECALL_INFO = "recall_info";
const MERGE_TAGS = "merge_tags";
const STORE_ANSWER = "store_answer";
const DESIGN_THEME = "design_theme";
const CANVAS = "canvas";
const CENTRAL_PART_COMPONENTS = [
  QUESTION_SETTINGS,
  LOGIC_JUMP,
  FORM_TRANSFER,
  ADD_EMOJI,
  HYPERLINK,
  RECALL_INFO,
  MERGE_TAGS,
  STORE_ANSWER,
  CANVAS
];
const componentByName = {
  QuestionSettings: markRaw(QuestionSettings),
  LogicJump: markRaw(LogicJump),
  FormTransfer: markRaw(FormTransfer$1),
  AddEmoji: markRaw(AddEmoji),
  Hyperlink: markRaw(Hyperlink),
  RecallInfo: markRaw(RecallInfo),
  MergeTags: markRaw(MergeTags),
  StoreAnswer: markRaw(StoreAnswer),
  DesignTheme: markRaw(DesignTheme),
  Canvas: markRaw(Canvas$1)
};
const componentMap = {
  [QUESTION_SETTINGS]: () => componentByName.QuestionSettings,
  [LOGIC_JUMP]: () => componentByName.LogicJump,
  [FORM_TRANSFER]: () => componentByName.FormTransfer,
  [ADD_EMOJI]: () => componentByName.AddEmoji,
  [HYPERLINK]: () => componentByName.Hyperlink,
  [RECALL_INFO]: () => componentByName.RecallInfo,
  [MERGE_TAGS]: () => componentByName.MergeTags,
  [STORE_ANSWER]: () => componentByName.StoreAnswer,
  [DESIGN_THEME]: () => componentByName.DesignTheme,
  [CANVAS]: () => componentByName.Canvas
};
var centralPartViews = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  QUESTION_SETTINGS,
  LOGIC_JUMP,
  FORM_TRANSFER,
  ADD_EMOJI,
  HYPERLINK,
  RECALL_INFO,
  MERGE_TAGS,
  STORE_ANSWER,
  DESIGN_THEME,
  CANVAS,
  CENTRAL_PART_COMPONENTS,
  componentByName,
  componentMap
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$W = {
  name: "CentralPartHeader",
  components: {
    ArrowLeftIcon: render$c,
    ArrowRightIcon: render$b
  },
  props: {
    view: { type: String, default: null }
  },
  emits: ["update:centralPartView"],
  computed: {
    title: function() {
      return {
        [QUESTION_SETTINGS]: "Question settings",
        [LOGIC_JUMP]: "Logic jump",
        [FORM_TRANSFER]: "Form transfer",
        [ADD_EMOJI]: "Add emoji",
        [HYPERLINK]: "Hyperlink",
        [RECALL_INFO]: "Recall info",
        [MERGE_TAGS]: "Merge tags",
        [STORE_ANSWER]: "Store Answer",
        [DESIGN_THEME]: "Design Theme"
      }[this.view] || "Question Settings";
    }
  },
  methods: {
    changeView: function(offset2) {
      let newViewPos = CENTRAL_PART_COMPONENTS.indexOf(this.view) + offset2;
      if (newViewPos < 0) {
        newViewPos = CENTRAL_PART_COMPONENTS.length - 1;
      }
      if (newViewPos > CENTRAL_PART_COMPONENTS.length - 1) {
        newViewPos = 0;
      }
      this.$emit("update:centralPartView", CENTRAL_PART_COMPONENTS[newViewPos]);
    }
  }
};
const _hoisted_1$R = { class: "flex justify-between border-b px-3 pt-4 pb-2" };
const _hoisted_2$t = { class: "text-navy font-bold text-sm" };
const _hoisted_3$m = { class: "flex gap-1" };
function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ArrowLeftIcon = resolveComponent("ArrowLeftIcon");
  const _component_ArrowRightIcon = resolveComponent("ArrowRightIcon");
  return openBlock(), createElementBlock("div", _hoisted_1$R, [
    createElementVNode("div", _hoisted_2$t, toDisplayString($options.title), 1),
    createElementVNode("div", _hoisted_3$m, [
      createElementVNode("span", {
        class: "inline-block w-5 h-5 bg-gray-500 rounded-full text-white flex items-center justify-center mt-1 cursor-pointer select-none hover:bg-blue-600",
        onClick: _cache[0] || (_cache[0] = ($event) => $options.changeView(-1))
      }, [
        createVNode(_component_ArrowLeftIcon, { class: "h-3 w-3 mx-auto" })
      ]),
      createElementVNode("span", {
        class: "inline-block w-5 h-5 bg-gray-500 rounded-full text-white flex items-center justify-center mt-1 cursor-pointer select-none hover:bg-blue-600",
        onClick: _cache[1] || (_cache[1] = ($event) => $options.changeView(1))
      }, [
        createVNode(_component_ArrowRightIcon, { class: "h-3 w-3 mx-auto" })
      ])
    ])
  ]);
}
var CentralPartHeader = /* @__PURE__ */ _export_sfc$1(_sfc_main$W, [["render", _sfc_render$W]]);
const _sfc_main$V = {
  name: "CentralPartView",
  components: { CentralPartHeader, XIcon: render, ChevronDoubleLeftIcon: render$8 },
  props: {
    view: { type: String, default: null },
    questions: { type: Array, default: () => [] },
    question: { type: Object, default: null },
    logic: { type: Array, default: () => [] },
    forms: { type: Array, default: () => [] },
    questionCategory: { type: String, default: "" },
    formCategory: { type: String, default: "" },
    theme: { type: Object, default: void 0 }
  },
  emits: ["update:question", "update:questionCategory", "update:logic", "update:currentQuestion", "click:addMedia", "click:emoji", "update:addMark", "update:centralPartView", "update:theme", "click:close", "update:goToLogicJump", "update:goToFormTransfer"],
  computed: {
    centralPartComponent: function() {
      return componentMap[this.view] && componentMap[this.view]() || null;
    },
    isCanvas: function() {
      return this.view === CANVAS;
    }
  }
};
const _hoisted_1$Q = { class: "overflow-hidden" };
const _hoisted_2$s = { class: "bg-white overflow-hidden" };
const _hoisted_3$l = { class: "overflow-y-auto h-full" };
function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ChevronDoubleLeftIcon = resolveComponent("ChevronDoubleLeftIcon");
  const _component_XIcon = resolveComponent("XIcon");
  const _component_CentralPartHeader = resolveComponent("CentralPartHeader");
  return openBlock(), createElementBlock("div", _hoisted_1$Q, [
    createElementVNode("div", _hoisted_2$s, [
      $options.isCanvas ? (openBlock(), createBlock(_component_ChevronDoubleLeftIcon, {
        key: 0,
        class: "h-5 text-gray-500 hover:text-gray-700 duration-300 float-right cursor-pointer my-2 pr-1",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click:close"))
      })) : (openBlock(), createBlock(_component_XIcon, {
        key: 1,
        class: "h-6 text-gray-500 hover:text-gray-700 duration-300 float-right cursor-pointer",
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("click:close"))
      }))
    ]),
    createElementVNode("div", _hoisted_3$l, [
      !$options.isCanvas ? (openBlock(), createBlock(_component_CentralPartHeader, {
        key: 0,
        view: $props.view,
        "onUpdate:centralPartView": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("update:centralPartView", $event))
      }, null, 8, ["view"])) : createCommentVNode("", true),
      (openBlock(), createBlock(resolveDynamicComponent($options.centralPartComponent), {
        class: "pb-20",
        question: $props.question,
        "question-category": $props.questionCategory,
        questions: $props.questions,
        logic: $props.logic,
        "form-category": $props.formCategory,
        forms: $props.forms,
        theme: $props.theme,
        "onUpdate:question": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("update:question", $event)),
        "onUpdate:questionCategory": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("update:questionCategory", $event)),
        "onUpdate:logic": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("update:logic", $event)),
        "onUpdate:currentQuestion": _cache[6] || (_cache[6] = ($event) => _ctx.$emit("update:currentQuestion", $event)),
        "onClick:addMedia": _cache[7] || (_cache[7] = ($event) => _ctx.$emit("click:addMedia")),
        "onClick:emoji": _cache[8] || (_cache[8] = ($event) => _ctx.$emit("click:emoji", $event)),
        "onUpdate:addMark": _cache[9] || (_cache[9] = ($event) => _ctx.$emit("update:addMark", $event)),
        "onUpdate:theme": _cache[10] || (_cache[10] = ($event) => _ctx.$emit("update:theme", $event)),
        "onClick:goToLogicJump": _cache[11] || (_cache[11] = ($event) => _ctx.$emit("update:goToLogicJump", $event)),
        "onUpdate:goToFormTransfer": _cache[12] || (_cache[12] = ($event) => _ctx.$emit("update:goToFormTransfer", $event))
      }, null, 40, ["question", "question-category", "questions", "logic", "form-category", "forms", "theme"]))
    ])
  ]);
}
var CentralPartView = /* @__PURE__ */ _export_sfc$1(_sfc_main$V, [["render", _sfc_render$V]]);
const _sfc_main$U = {
  name: "Error",
  components: {
    ExclamationIcon: render$4
  }
};
const _hoisted_1$P = { class: "text-red-500 flex gap-2 items-center" };
const _hoisted_2$r = { class: "font-italic text-xs" };
function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ExclamationIcon = resolveComponent("ExclamationIcon");
  return openBlock(), createElementBlock("div", _hoisted_1$P, [
    createVNode(_component_ExclamationIcon, { class: "h-8" }),
    createElementVNode("div", _hoisted_2$r, [
      renderSlot(_ctx.$slots, "default")
    ])
  ]);
}
var Error$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$U, [["render", _sfc_render$U]]);
const CHANGE_FORM_WARNING_MESSAGE = "Are you sure? Rating score and Review block specials questions will be erased";
const TRY_TO_DELETE_PRE_REVIEW_KICK_OFF_MESSAGE = "You can't delete kick-off question of pre-review form";
const PRE_REVIEW_FORM_TRANSFER_ERROR_MESSAGE = "Kick off question missing form transfer";
const NO_TYPS_ERROR_MESSAGE = "You must create at least one thank you page";
var messages = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CHANGE_FORM_WARNING_MESSAGE,
  TRY_TO_DELETE_PRE_REVIEW_KICK_OFF_MESSAGE,
  PRE_REVIEW_FORM_TRANSFER_ERROR_MESSAGE,
  NO_TYPS_ERROR_MESSAGE
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$T = {
  name: "FormEdit",
  components: { Checkbox, SelectBox, Input, ActionButtons },
  props: {
    id: { type: Number, default: null },
    header: { type: String, default: () => "Edit form" },
    stores: { type: Array, required: true },
    formTypes: { type: Array, required: true },
    formCategories: { type: Array, required: true },
    storeId: { type: Number, default: null },
    name: { type: String, default: "" },
    type: { type: String, default: (props2) => props2.formTypes[0] },
    category: { type: String, default: (props2) => props2.formCategories[0] },
    errors: { type: Object, default: () => ({}) },
    data: {
      type: Object,
      default: () => ({
        follow_ups: [],
        kick_offs: [],
        typs: [],
        logic: [],
        allow_users_files: false
      })
    },
    snapshot: {
      type: Object,
      default: () => ({
        follow_ups: [],
        kick_offs: [],
        typs: [],
        logic: [],
        allow_users_files: false
      })
    }
  },
  emits: ["submit", "click:cancel"],
  data: function() {
    return {
      newName: this.name,
      newStoreId: this.storeId,
      submitting: false,
      newType: this.type,
      newCategory: this.category,
      allowUsersFiles: this.data.allow_users_files
    };
  },
  computed: {
    shopsSelectBoxItems: function() {
      return this.stores.map((s2) => ({ value: s2.id, title: s2.domain }));
    },
    categoriesSelectBoxItems: function() {
      return this.formCategories.map((c2) => ({ value: c2, title: FORM_CATEGORY_TITLE[c2] || c2 }));
    },
    isProductsReviewForm: function() {
      return this.newType === FORM_TYPE_PRODUCT && this.newCategory === FORM_CATEGORY_REVIEW;
    }
  },
  watch: {
    errors: {
      deep: true,
      handler: function() {
        this.submitting = false;
      }
    }
  },
  mounted: function() {
    if (this.shopsSelectBoxItems.length > 0 && !this.newStoreId) {
      this.newStoreId = this.shopsSelectBoxItems[0].value;
    }
  },
  methods: {
    handleFormCategoryChange: function(v2) {
      if (v2 === this.formCategory) {
        return;
      }
      const questionsToOmit = UNAVAILABLE_QUESTIONS_BY_FORM_CATEGORY[v2];
      if (v2 === FORM_CATEGORY_PRE_REVIEW && [...this.data.kick_offs, ...this.data.follow_ups].find((q) => questionsToOmit.indexOf(q.type) !== -1)) {
        if (!confirm(CHANGE_FORM_WARNING_MESSAGE)) {
          this.newCategory = this.formCategory;
        }
      }
    },
    handleSubmit: function() {
      if (this.submitting) {
        return;
      }
      this.submitting = true;
      let formData = filterFormQuestions(this.data, UNAVAILABLE_QUESTIONS_BY_FORM_CATEGORY[this.newCategory]);
      formData.allow_users_files = this.isProductsReviewForm && this.allowUsersFiles;
      let snapshot = this.snapshot;
      if (this.newCategory === FORM_CATEGORY_PRE_REVIEW && (!this.data.kick_offs[0] || this.data.kick_offs[0].type !== QUESTION_TYPE_YES_NO)) {
        formData = injectDefaultPreReviewYesNo(formData);
        snapshot = formData;
      }
      this.$emit("submit", {
        ...this.id ? { id: this.id } : {},
        name: this.newName,
        type: this.newType,
        category: this.newCategory,
        data: formData,
        storeId: this.newStoreId,
        snapshot
      });
    },
    createSelectBoxItems: function(arrayOfStrings) {
      return [...arrayOfStrings].map((s2) => ({ title: s2.replace("_", " "), value: s2 }));
    }
  }
};
const _hoisted_1$O = { class: "overflow-y-auto pb-24 px-6 h-full" };
const _hoisted_2$q = { class: "py-4 text-xl font-bold" };
const _hoisted_3$k = { class: "flex flex-col gap-1" };
const _hoisted_4$c = /* @__PURE__ */ createElementVNode("span", { class: "text-gray-500 text-xxs" }, "Name", -1);
const _hoisted_5$c = { class: "py-2" };
const _hoisted_6$9 = { class: "py-2" };
const _hoisted_7$7 = { class: "py-2" };
const _hoisted_8$4 = { class: "py-2" };
const _hoisted_9$3 = { class: "flex gap-4" };
const _hoisted_10$3 = /* @__PURE__ */ createElementVNode("div", { class: "text-xxs text-gray-500" }, "Add customers files upload form", -1);
const _hoisted_11$3 = { class: "px-6" };
const _hoisted_12$2 = { class: "flex gap-2 py-4" };
function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Input = resolveComponent("Input");
  const _component_SelectBox = resolveComponent("SelectBox");
  const _component_Checkbox = resolveComponent("Checkbox");
  const _component_ActionButtons = resolveComponent("ActionButtons");
  return openBlock(), createElementBlock("form", {
    class: "py-2 w-full h-full bg-white flex flex-col justify-between overflow-hidden",
    onSubmit: _cache[6] || (_cache[6] = withModifiers((...args) => $options.handleSubmit && $options.handleSubmit(...args), ["prevent"]))
  }, [
    createElementVNode("div", _hoisted_1$O, [
      createElementVNode("div", _hoisted_2$q, toDisplayString($props.header), 1),
      createElementVNode("label", _hoisted_3$k, [
        _hoisted_4$c,
        createVNode(_component_Input, {
          modelValue: _ctx.newName,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.newName = $event),
          requred: "",
          class: normalizeClass(["py-2 px-2 border", $props.errors.name && "border-red-600"]),
          placeholder: "Enter the form name"
        }, null, 8, ["modelValue", "class"])
      ]),
      createElementVNode("div", _hoisted_5$c, [
        createVNode(_component_SelectBox, {
          modelValue: _ctx.newStoreId,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.newStoreId = $event),
          label: "Shop",
          placeholder: "Choose the shop",
          items: $options.shopsSelectBoxItems,
          classes: "py-2.5"
        }, null, 8, ["modelValue", "items"])
      ]),
      createElementVNode("div", _hoisted_6$9, [
        createVNode(_component_SelectBox, {
          modelValue: _ctx.newType,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.newType = $event),
          label: "Type",
          placeholder: "Choose the type",
          items: $options.createSelectBoxItems($props.formTypes),
          classes: "py-2.5 capitalize"
        }, null, 8, ["modelValue", "items"])
      ]),
      createElementVNode("div", _hoisted_7$7, [
        createVNode(_component_SelectBox, {
          modelValue: _ctx.newCategory,
          "onUpdate:modelValue": [
            _cache[3] || (_cache[3] = ($event) => _ctx.newCategory = $event),
            $options.handleFormCategoryChange
          ],
          label: "Category",
          placeholder: "Choose the type",
          items: $options.categoriesSelectBoxItems,
          classes: "py-2.5 capitalize"
        }, null, 8, ["modelValue", "items", "onUpdate:modelValue"])
      ]),
      withDirectives(createElementVNode("div", _hoisted_8$4, [
        createElementVNode("label", _hoisted_9$3, [
          _hoisted_10$3,
          createVNode(_component_Checkbox, {
            modelValue: _ctx.allowUsersFiles,
            "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.allowUsersFiles = $event),
            checked: $props.data.allow_users_files
          }, null, 8, ["modelValue", "checked"])
        ])
      ], 512), [
        [vShow, $options.isProductsReviewForm]
      ])
    ]),
    createElementVNode("div", _hoisted_11$3, [
      withDirectives(createElementVNode("div", { class: "text-red-700" }, toDisplayString($props.errors.name), 513), [
        [vShow, $props.errors.name]
      ]),
      createElementVNode("div", _hoisted_12$2, [
        createVNode(_component_ActionButtons, {
          "onClick:ok": $options.handleSubmit,
          "onClick:cancel": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("click:cancel"))
        }, null, 8, ["onClick:ok"])
      ])
    ])
  ], 32);
}
var FormEdit = /* @__PURE__ */ _export_sfc$1(_sfc_main$T, [["render", _sfc_render$T]]);
/*!
  * vue-draggable-next v2.1.0
  * (c) 2021 Anish George
  * @license MIT
  */
/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source2 = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source2), true).forEach(function(key) {
        _defineProperty(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source2 = arguments[i2];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source2[key];
  }
  return target;
}
function _objectWithoutProperties(source2, excluded) {
  if (source2 == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source2, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source2, key))
        continue;
      target[key] = source2[key];
    }
  }
  return target;
}
var version = "1.14.0";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn3) {
  el.addEventListener(event, fn3, !IE11OrLess && captureMode);
}
function off(el, event, fn3) {
  el.removeEventListener(event, fn3, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_2) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style2 = el && el.style;
  if (style2) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style2) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style2[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i2 = 0, n2 = list.length;
    if (iterator) {
      for (; i2 < n2; i2++) {
        iterator(list[i2], i2);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top2, left2, bottom2, right2, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top2 = elRect.top;
    left2 = elRect.left;
    bottom2 = elRect.bottom;
    right2 = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top2 = 0;
    left2 = 0;
    bottom2 = window.innerHeight;
    right2 = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top2 -= containerRect.top + parseInt(css(container, "border-top-width"));
          left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom2 = top2 + elRect.height;
          right2 = left2 + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top2 /= scaleY;
      left2 /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom2 = top2 + height;
      right2 = left2 + width;
    }
  }
  return {
    top: top2,
    left: left2,
    bottom: bottom2,
    right: right2,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i2 = 0, children = el.children;
  while (i2 < children.length) {
    if (children[i2].style.display !== "none" && children[i2] !== Sortable.ghost && (includeDragEl || children[i2] !== Sortable.dragged) && closest(children[i2], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i2];
      }
      currentChild++;
    }
    i2++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index$1(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i2 in arr) {
    if (!arr.hasOwnProperty(i2))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i2][key])
        return Number(i2);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend$1(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x2, y2) {
  el.scrollLeft += x2;
  el.scrollTop += y2;
}
function clone$2(el) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($2) {
    return $2(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults$1 = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults$1) {
      if (defaults$1.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults$1[option2];
      }
    }
    plugins.forEach(function(p2) {
      if (p2.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault)
        return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data2 = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data2));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}(), _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
}, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
}, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x2, y2) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x2 >= rect.left - threshold && x2 <= rect.right + threshold, insideVertically = y2 >= rect.top - threshold && y2 <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
}, _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to2, from2, dragEl2, evt) {
      var sameGroup = to2.options.group.name && from2.options.group.name && to2.options.group.name === from2.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to2, from2, dragEl2, evt), pull)(to2, from2, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to2 : from2).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
}, _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
}, _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i2 in evt) {
        if (evt.hasOwnProperty(i2)) {
          event[i2] = evt[i2];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: false,
    invertedSwapThreshold: null,
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn3 in this) {
    if (fn3.charAt(0) === "_" && typeof this[fn3] === "function") {
      this[fn3] = this[fn3].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el, "pointerdown", this._onTapStart);
  } else {
    on(el, "mousedown", this._onTapStart);
    on(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, "dragover", this);
    on(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = {
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index$1(target);
    oldDraggableIndex = index$1(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mouseup", _this._onDrop);
      on(ownerDocument, "touchend", _this._onDrop);
      on(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on(ownerDocument, "touchend", _this._disableDelayedDrag);
        on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e2) {
    var touch = e2.touches ? e2.touches[0] : e2;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent)
          break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone$2(dragEl);
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index$1(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  toArray: function toArray() {
    var order2 = [], el, children = this.el.children, i2 = 0, n2 = children.length, options = this.options;
    for (; i2 < n2; i2++) {
      el = children[i2];
      if (closest(el, options.draggable, this.el, false)) {
        order2.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order2;
  },
  sort: function sort(order2, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i2) {
      var el = rootEl2.children[i2];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order2.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index$1(dragEl) < index$1(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i2 = str.length, sum = 0;
  while (i2--) {
    sum += str.charCodeAt(i2);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root2) {
  savedInputChecked.length = 0;
  var inputs = root2.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn3) {
  return setTimeout(fn3, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend$1,
  throttle,
  closest,
  toggleClass,
  clone: clone$2,
  index: index$1,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element2) {
  return element2[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn3 in this) {
      if (fn3.charAt(0) === "_" && typeof this[fn3] === "function") {
        this[fn3] = this[fn3].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x2, y2);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x2 !== lastAutoScrollX || y2 !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x2, y2), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x2;
          lastAutoScrollY = y2;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top2 = rect.top, bottom2 = rect.bottom, left2 = rect.left, right2 = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right2 - x2) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left2 - x2) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom2 - y2) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top2 - y2) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i2 = 0; i2 <= layersOut; i2++) {
        if (!autoScrolls[i2]) {
          autoScrolls[i2] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
function getConsole() {
  if (typeof window !== "undefined") {
    return window.console;
  }
  return global.console;
}
const console$1 = getConsole();
function cached(fn3) {
  const cache = /* @__PURE__ */ Object.create(null);
  return function cachedFn(str) {
    const hit = cache[str];
    return hit || (cache[str] = fn3(str));
  };
}
const regex = /-(\w)/g;
const camelize = cached((str) => str.replace(regex, (_2, c2) => c2 ? c2.toUpperCase() : ""));
function removeNode(node) {
  if (node.parentElement !== null) {
    node.parentElement.removeChild(node);
  }
}
function insertNodeAt(fatherNode, node, position) {
  const refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
  fatherNode.insertBefore(node, refNode);
}
function computeVmIndex(vnodes, element2) {
  return Object.values(vnodes).indexOf(element2);
}
function computeIndexes(slots, children, isTransition2, footerOffset) {
  if (!slots) {
    return [];
  }
  const elmFromNodes = Object.values(slots);
  const footerIndex = children.length - footerOffset;
  const rawIndexes = [...children].map((elt, idx) => idx >= footerIndex ? elmFromNodes.length : elmFromNodes.indexOf(elt));
  return rawIndexes;
}
function emit(evtName, evtData) {
  this.$nextTick(() => this.$emit(evtName.toLowerCase(), evtData));
}
function delegateAndEmit(evtName) {
  return (evtData) => {
    if (this.realList !== null) {
      this["onDrag" + evtName](evtData);
    }
    emit.call(this, evtName, evtData);
  };
}
function isTransitionName(name) {
  return ["transition-group", "TransitionGroup"].includes(name);
}
function isTransition(slots) {
  if (!slots || slots.length !== 1) {
    return false;
  }
  const [{ type }] = slots;
  if (!type) {
    return false;
  }
  return isTransitionName(type.name);
}
function getComponentAttributes($attrs, componentData) {
  if (!componentData) {
    return $attrs;
  }
  return { ...componentData.props, ...componentData.attrs };
}
const eventsListened = ["Start", "Add", "Remove", "Update", "End"];
const eventsToEmit = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
const readonlyProperties = ["Move", ...eventsListened, ...eventsToEmit].map((evt) => "on" + evt);
let draggingElement = null;
const props = {
  options: Object,
  list: {
    type: Array,
    required: false,
    default: null
  },
  noTransitionOnDrag: {
    type: Boolean,
    default: false
  },
  clone: {
    type: Function,
    default: (original) => {
      return original;
    }
  },
  tag: {
    type: String,
    default: "div"
  },
  move: {
    type: Function,
    default: null
  },
  componentData: {
    type: Object,
    required: false,
    default: null
  },
  component: {
    type: String,
    default: null
  },
  modelValue: {
    type: Array,
    required: false,
    default: null
  }
};
const VueDraggableNext = defineComponent({
  name: "VueDraggableNext",
  inheritAttrs: false,
  emits: [
    "update:modelValue",
    "move",
    "change",
    ...eventsListened.map((s2) => s2.toLowerCase()),
    ...eventsToEmit.map((s2) => s2.toLowerCase())
  ],
  props,
  data() {
    return {
      transitionMode: false,
      noneFunctionalComponentMode: false,
      headerOffset: 0,
      footerOffset: 0,
      _sortable: {},
      visibleIndexes: [],
      context: {}
    };
  },
  render() {
    const slots = this.$slots.default ? this.$slots.default() : null;
    const attrs = getComponentAttributes(this.$attrs, this.componentData);
    if (!slots)
      return h$4(this.getTag(), attrs, []);
    this.transitionMode = isTransition(slots);
    return h$4(this.getTag(), attrs, slots);
  },
  created() {
    if (this.list !== null && this.modelValue !== null) {
      console$1.error("list props are mutually exclusive! Please set one.");
    }
  },
  mounted() {
    const optionsAdded = {};
    eventsListened.forEach((elt) => {
      optionsAdded["on" + elt] = delegateAndEmit.call(this, elt);
    });
    eventsToEmit.forEach((elt) => {
      optionsAdded["on" + elt] = emit.bind(this, elt);
    });
    const attributes = Object.keys(this.$attrs).reduce((res, key) => {
      res[camelize(key)] = this.$attrs[key];
      return res;
    }, {});
    const options = Object.assign({}, attributes, optionsAdded, {
      onMove: (evt, originalEvent) => {
        return this.onDragMove(evt, originalEvent);
      }
    });
    !("draggable" in options) && (options.draggable = ">*");
    const targetDomElement = this.$el.nodeType === 1 ? this.$el : this.$el.parentElement;
    this._sortable = new Sortable(targetDomElement, options);
    targetDomElement.__draggable_component__ = this;
    this.computeIndexes();
  },
  beforeUnmount() {
    try {
      if (this._sortable !== void 0)
        this._sortable.destroy();
    } catch (error) {
    }
  },
  computed: {
    realList() {
      return this.list ? this.list : this.modelValue;
    }
  },
  watch: {
    $attrs: {
      handler(newOptionValue) {
        this.updateOptions(newOptionValue);
      },
      deep: true
    },
    realList() {
      this.computeIndexes();
    }
  },
  methods: {
    getTag() {
      return this.component ? resolveComponent(this.component) : this.tag;
    },
    updateOptions(newOptionValue) {
      for (var property in newOptionValue) {
        const value = camelize(property);
        if (readonlyProperties.indexOf(value) === -1) {
          this._sortable.option(value, newOptionValue[property]);
        }
      }
    },
    getChildrenNodes() {
      return this.$el.children;
    },
    computeIndexes() {
      this.$nextTick(() => {
        this.visibleIndexes = computeIndexes(this.getChildrenNodes(), this.$el.children, this.transitionMode, this.footerOffset);
      });
    },
    getUnderlyingVm(htmlElt) {
      const index2 = computeVmIndex(this.getChildrenNodes() || [], htmlElt);
      if (index2 === -1) {
        return null;
      }
      const element2 = this.realList[index2];
      return { index: index2, element: element2 };
    },
    emitChanges(evt) {
      this.$nextTick(() => {
        this.$emit("change", evt);
      });
    },
    alterList(onList) {
      if (this.list) {
        onList(this.list);
        return;
      }
      const newList = [...this.modelValue];
      onList(newList);
      this.$emit("update:modelValue", newList);
    },
    spliceList() {
      const spliceList = (list) => list.splice(...arguments);
      this.alterList(spliceList);
    },
    updatePosition(oldIndex2, newIndex2) {
      const updatePosition = (list) => list.splice(newIndex2, 0, list.splice(oldIndex2, 1)[0]);
      this.alterList(updatePosition);
    },
    getVmIndex(domIndex) {
      const indexes = this.visibleIndexes;
      const numberIndexes = indexes.length;
      return domIndex > numberIndexes - 1 ? numberIndexes : indexes[domIndex];
    },
    getComponent() {
      return this.$slots.default ? this.$slots.default()[0].componentInstance : null;
    },
    resetTransitionData(index2) {
      if (!this.noTransitionOnDrag || !this.transitionMode) {
        return;
      }
      var nodes = this.getChildrenNodes();
      nodes[index2].data = null;
      const transitionContainer = this.getComponent();
      transitionContainer.children = [];
      transitionContainer.kept = void 0;
    },
    onDragStart(evt) {
      this.context = this.getUnderlyingVm(evt.item);
      if (!this.context)
        return;
      evt.item._underlying_vm_ = this.clone(this.context.element);
      draggingElement = evt.item;
    },
    onDragAdd(evt) {
      const element2 = evt.item._underlying_vm_;
      if (element2 === void 0) {
        return;
      }
      removeNode(evt.item);
      const newIndex2 = this.getVmIndex(evt.newIndex);
      this.spliceList(newIndex2, 0, element2);
      this.computeIndexes();
      const added = { element: element2, newIndex: newIndex2 };
      this.emitChanges({ added });
    },
    onDragRemove(evt) {
      insertNodeAt(this.$el, evt.item, evt.oldIndex);
      if (evt.pullMode === "clone") {
        removeNode(evt.clone);
        return;
      }
      if (!this.context)
        return;
      const oldIndex2 = this.context.index;
      this.spliceList(oldIndex2, 1);
      const removed = { element: this.context.element, oldIndex: oldIndex2 };
      this.resetTransitionData(oldIndex2);
      this.emitChanges({ removed });
    },
    onDragUpdate(evt) {
      removeNode(evt.item);
      insertNodeAt(evt.from, evt.item, evt.oldIndex);
      const oldIndex2 = this.context.index;
      const newIndex2 = this.getVmIndex(evt.newIndex);
      this.updatePosition(oldIndex2, newIndex2);
      const moved2 = { element: this.context.element, oldIndex: oldIndex2, newIndex: newIndex2 };
      this.emitChanges({ moved: moved2 });
    },
    updateProperty(evt, propertyName) {
      evt.hasOwnProperty(propertyName) && (evt[propertyName] += this.headerOffset);
    },
    onDragMove(evt, originalEvent) {
      const onMove = this.move;
      if (!onMove || !this.realList) {
        return true;
      }
      const relatedContext = this.getRelatedContextFromMoveEvent(evt);
      const draggedContext = this.context;
      const futureIndex = this.computeFutureIndex(relatedContext, evt);
      Object.assign(draggedContext, { futureIndex });
      const sendEvt = Object.assign({}, evt, {
        relatedContext,
        draggedContext
      });
      return onMove(sendEvt, originalEvent);
    },
    onDragEnd() {
      this.computeIndexes();
      draggingElement = null;
    },
    getTrargetedComponent(htmElement) {
      return htmElement.__draggable_component__;
    },
    getRelatedContextFromMoveEvent({ to: to2, related }) {
      const component = this.getTrargetedComponent(to2);
      if (!component) {
        return { component };
      }
      const list = component.realList;
      const context = { list, component };
      if (to2 !== related && list && component.getUnderlyingVm) {
        const destination = component.getUnderlyingVm(related);
        if (destination) {
          return Object.assign(destination, context);
        }
      }
      return context;
    },
    computeFutureIndex(relatedContext, evt) {
      const domChildren = [...evt.to.children].filter((el) => el.style["display"] !== "none");
      if (domChildren.length === 0)
        return 0;
      const currentDOMIndex = domChildren.indexOf(evt.related);
      const currentIndex = relatedContext.component.getVmIndex(currentDOMIndex);
      const draggedInList = domChildren.indexOf(draggingElement) !== -1;
      return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
    }
  }
});
var ListOfQuestionsItem_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$S = {
  name: "ListOfQuestionsItem",
  components: {
    QuestionLabel,
    DotsVerticalIcon: render$h
  },
  props: {
    title: String,
    type: String,
    index: Number,
    category: String,
    is: { type: String, default: "div" }
  },
  emits: ["click", "clickOptions"],
  computed: {
    iconLetter: function() {
      return this.category === QUESTION_CATEGORY_TYP ? "TYP" : "Q";
    }
  },
  methods: {
    handleClickOptions: function(event) {
      this.$emit(
        "clickOptions",
        event.path[0].getBoundingClientRect().top - event.path.find((e2) => e2.id === "workspace").offsetTop + window.scrollY - 20
      );
    }
  }
};
const _withScopeId$7 = (n2) => (pushScopeId("data-v-7b82158e"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$N = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode("strong", null, "?", -1));
const _hoisted_2$p = /* @__PURE__ */ createTextVNode();
const _hoisted_3$j = { class: "w-2/3 ml-3 truncate" };
function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_QuestionLabel = resolveComponent("QuestionLabel");
  const _component_DotsVerticalIcon = resolveComponent("DotsVerticalIcon");
  return openBlock(), createBlock(resolveDynamicComponent($props.is), { class: "relative" }, {
    default: withCtx(() => [
      createElementVNode("div", {
        class: normalizeClass(["flex items-center question-list-item bg-gray-400 py-1 px-1 text-xs border border-gray-600 rounded mt-1 cursor-pointer h-8", `bg-${$props.category}`]),
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click"))
      }, [
        createVNode(_component_QuestionLabel, null, {
          default: withCtx(() => [
            _hoisted_1$N,
            _hoisted_2$p,
            createElementVNode("small", null, toDisplayString($options.iconLetter) + toDisplayString($props.index), 1)
          ]),
          _: 1
        }),
        createElementVNode("div", _hoisted_3$j, toDisplayString($props.title || "No title"), 1)
      ], 2),
      createElementVNode("button", {
        id: "questionContextMenuButton",
        class: "absolute right-0.5 top-0 bottom-0",
        onClick: _cache[1] || (_cache[1] = (...args) => $options.handleClickOptions && $options.handleClickOptions(...args))
      }, [
        createVNode(_component_DotsVerticalIcon, { class: "text-gray-500 w-4" })
      ])
    ]),
    _: 1
  });
}
var ListOfQuestionsItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$S, [["render", _sfc_render$S], ["__scopeId", "data-v-7b82158e"]]);
const _sfc_main$R = {
  name: "ListOfQuestions",
  components: { ListOfQuestionsItem, draggable: VueDraggableNext },
  props: {
    items: { type: Array, default: () => [] }
  },
  emits: ["onClickItem", "onChangeSorting", "onClickOptions"],
  computed: {
    kickOffs: function() {
      return this.items.filter((i2) => i2.category === QUESTION_CATEGORY_KICK_OFF);
    },
    sortableItems: function() {
      return {
        [QUESTION_CATEGORY_FOLLOW_UP + "s"]: this.followUps,
        [QUESTION_CATEGORY_TYP + "s"]: this.typs
      };
    },
    followUps: function() {
      return this.items.filter((i2) => i2.category === QUESTION_CATEGORY_FOLLOW_UP);
    },
    typs: function() {
      return this.items.filter((i2) => i2.category === QUESTION_CATEGORY_TYP);
    }
  },
  methods: {
    handleChangeSorting: function(questionCategory, { oldIndex: oldIndex2, newIndex: newIndex2 }) {
      oldIndex2 !== newIndex2 && this.$emit("onChangeSorting", questionCategory, oldIndex2, newIndex2);
    },
    handleClickOptions: function(id, y2) {
      this.$emit("onClickOptions", id, y2);
    }
  }
};
const _hoisted_1$M = { class: "my-3" };
function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ListOfQuestionsItem = resolveComponent("ListOfQuestionsItem");
  const _component_draggable = resolveComponent("draggable");
  return openBlock(), createElementBlock("div", _hoisted_1$M, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.kickOffs, (item, i2) => {
      return openBlock(), createBlock(_component_ListOfQuestionsItem, {
        is: "div",
        key: `question${i2}`,
        title: item.title,
        category: item.category,
        type: item.type,
        index: item.index,
        onClick: ($event) => _ctx.$emit("onClickItem", item),
        onClickOptions: ($event) => $options.handleClickOptions(item.id, $event)
      }, null, 8, ["title", "category", "type", "index", "onClick", "onClickOptions"]);
    }), 128)),
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.sortableItems, (list, listName) => {
      return openBlock(), createBlock(_component_draggable, {
        key: `question-list${listName}`,
        tag: "ul",
        animation: 200,
        onEnd: ($event) => $options.handleChangeSorting(listName, $event)
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(list, (item, i2) => {
            return openBlock(), createBlock(_component_ListOfQuestionsItem, {
              is: "li",
              key: `question${listName}${i2}${item.id}`,
              title: item.title,
              category: item.category,
              type: item.type,
              index: item.index,
              onClick: ($event) => _ctx.$emit("onClickItem", item),
              onClickOptions: ($event) => $options.handleClickOptions(item.id, $event)
            }, null, 8, ["title", "category", "type", "index", "onClick", "onClickOptions"]);
          }), 128))
        ]),
        _: 2
      }, 1032, ["onEnd"]);
    }), 128))
  ]);
}
var ListOfQuestions = /* @__PURE__ */ _export_sfc$1(_sfc_main$R, [["render", _sfc_render$R]]);
var MediaManager_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$Q = {
  name: "MediaManager",
  components: { Error: Error$1, ActionButtons, AddMediaIcon, CheckIcon: render$k },
  props: {
    files: { type: Array, default: () => [] }
  },
  emits: ["click:ok", "click:cancel", "upload"],
  data() {
    return {
      checked: null,
      error: null,
      userFiles: this.files
    };
  },
  methods: {
    handleUploadFile: function(e2) {
      this.error = null;
      const file = e2.target.files[0];
      if (!file) {
        return;
      }
      if (file.size > 35 * 1024 * 1024) {
        this.error = "File size must be less than 35MB";
        return;
      }
      this.$emit(
        "upload",
        file,
        function(uploadedImage, err) {
          if (err) {
            this.error = err;
            return;
          }
          this.userFiles = [uploadedImage, ...this.userFiles];
          this.checked = uploadedImage;
        }.bind(this)
      );
    },
    handleClickFile: function(file) {
      this.checked = this.checked === file ? null : file;
    }
  }
};
const _withScopeId$6 = (n2) => (pushScopeId("data-v-2bccb833"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$L = { class: "absolute left-0 top-0 bottom-0 right-0 z-50 overflow-hidden" };
const _hoisted_2$o = { class: "bg-white px-5 rounded h-full flex flex-col" };
const _hoisted_3$i = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createElementVNode("div", { class: "text-xl font-bold py-4 text-center" }, " Add something nice ", -1));
const _hoisted_4$b = { class: "py-3" };
const _hoisted_5$b = { class: "rounded-lg overflow-hidden" };
const _hoisted_6$8 = { class: "md:flex" };
const _hoisted_7$6 = { class: "w-full" };
const _hoisted_8$3 = { class: "relative h-32 rounded-lg border-dashed border border-gray-400 bg-gray-100 flex justify-center items-center" };
const _hoisted_9$2 = { class: "absolute" };
const _hoisted_10$2 = { class: "flex flex-col gap-1 items-center text-gray-500" };
const _hoisted_11$2 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createElementVNode("span", { class: "block font-normal" }, [
  /* @__PURE__ */ createElementVNode("strong", { class: "underline" }, "Upload"),
  /* @__PURE__ */ createTextVNode(" or drop image right here")
], -1));
const _hoisted_12$1 = {
  key: 1,
  class: "py-4 overflow-y-auto"
};
const _hoisted_13 = { class: "flex flex-wrap items-start" };
const _hoisted_14 = ["onClick"];
const _hoisted_15 = {
  key: 0,
  class: "check-icon-container absolute top-0 right-0 p-3"
};
const _hoisted_16 = ["src"];
const _hoisted_17 = { class: "flex gap-2 justify-around py-4" };
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Error = resolveComponent("Error");
  const _component_AddMediaIcon = resolveComponent("AddMediaIcon");
  const _component_CheckIcon = resolveComponent("CheckIcon");
  const _component_ActionButtons = resolveComponent("ActionButtons");
  return openBlock(), createElementBlock("div", _hoisted_1$L, [
    createElementVNode("div", _hoisted_2$o, [
      _hoisted_3$i,
      $data.error ? (openBlock(), createBlock(_component_Error, {
        key: 0,
        class: "justify-center"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString($data.error), 1)
        ]),
        _: 1
      })) : createCommentVNode("", true),
      createElementVNode("div", _hoisted_4$b, [
        createElementVNode("div", _hoisted_5$b, [
          createElementVNode("div", _hoisted_6$8, [
            createElementVNode("div", _hoisted_7$6, [
              createElementVNode("div", _hoisted_8$3, [
                createElementVNode("div", _hoisted_9$2, [
                  createElementVNode("div", _hoisted_10$2, [
                    createVNode(_component_AddMediaIcon, {
                      "icon-color": "currentColor",
                      height: "32",
                      width: "50"
                    }),
                    _hoisted_11$2
                  ])
                ]),
                createElementVNode("input", {
                  type: "file",
                  class: "h-full w-full opacity-0",
                  name: "mediamanager",
                  accept: "image/*",
                  onChange: _cache[0] || (_cache[0] = (...args) => $options.handleUploadFile && $options.handleUploadFile(...args))
                }, null, 32)
              ])
            ])
          ])
        ])
      ]),
      $data.userFiles.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_12$1, [
        createElementVNode("div", _hoisted_13, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.userFiles, (f2) => {
            return openBlock(), createElementBlock("div", {
              key: "media-manager-file-" + f2,
              class: normalizeClass(["lg:w-1/4 cursor-pointer rounded border-2 overflow-hidden relative", $data.checked === f2 ? ["border-blue-600"] : ["border-transparent"]]),
              onClick: ($event) => $options.handleClickFile(f2)
            }, [
              $data.checked === f2 ? (openBlock(), createElementBlock("div", _hoisted_15, [
                createVNode(_component_CheckIcon, { class: "check-icon text-white h-6" })
              ])) : createCommentVNode("", true),
              createElementVNode("img", {
                src: `/storage/${f2}`,
                class: "w-full",
                alt: ""
              }, null, 8, _hoisted_16)
            ], 10, _hoisted_14);
          }), 128))
        ])
      ])) : createCommentVNode("", true),
      createElementVNode("div", _hoisted_17, [
        createVNode(_component_ActionButtons, {
          "onClick:ok": _cache[1] || (_cache[1] = ($event) => {
            _ctx.$emit("click:ok", $data.checked);
            $data.checked = null;
          }),
          "onClick:cancel": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:cancel"))
        })
      ])
    ])
  ]);
}
var MediaManager = /* @__PURE__ */ _export_sfc$1(_sfc_main$Q, [["render", _sfc_render$Q], ["__scopeId", "data-v-2bccb833"]]);
const _sfc_main$P = {
  name: "GearIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$K = /* @__PURE__ */ createElementVNode("g", { transform: "translate(1.185 1.125)" }, [
  /* @__PURE__ */ createElementVNode("path", {
    fill: "none",
    stroke: "#050038",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2.25px",
    d: "M16.893,12.435a4.037,4.037,0,1,0,3.621,3.621,4.037,4.037,0,0,0-3.621-3.621Zm9.721,4.018a9.737,9.737,0,0,1-.1,1.312L29.369,20a.682.682,0,0,1,.154.868l-2.7,4.668a.682.682,0,0,1-.829.29l-2.832-1.14a1.017,1.017,0,0,0-.957.11,10.376,10.376,0,0,1-1.357.79,1.006,1.006,0,0,0-.556.766l-.424,3.021a.7.7,0,0,1-.674.579H13.8a.7.7,0,0,1-.675-.56L12.7,26.377a1.014,1.014,0,0,0-.568-.771,9.8,9.8,0,0,1-1.354-.793,1.009,1.009,0,0,0-.953-.108l-2.832,1.14a.682.682,0,0,1-.829-.289l-2.7-4.668a.681.681,0,0,1,.154-.868l2.411-1.892a1.013,1.013,0,0,0,.379-.888c-.022-.263-.037-.526-.037-.789s.013-.521.037-.779a1.009,1.009,0,0,0-.383-.879L3.619,12.9a.682.682,0,0,1-.151-.865l2.7-4.668A.682.682,0,0,1,7,7.079l2.832,1.14a1.017,1.017,0,0,0,.957-.11,10.376,10.376,0,0,1,1.358-.79,1.006,1.006,0,0,0,.556-.766l.424-3.021a.7.7,0,0,1,.675-.579h5.4a.7.7,0,0,1,.675.56l.423,3.016a1.014,1.014,0,0,0,.568.771,9.8,9.8,0,0,1,1.354.793,1.009,1.009,0,0,0,.953.108L26,7.06a.682.682,0,0,1,.829.289l2.7,4.668a.681.681,0,0,1-.154.868l-2.411,1.892a1.013,1.013,0,0,0-.381.888c.021.261.035.524.035.787Z",
    transform: "translate(-3.375 -2.953)"
  })
], -1);
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 28.614 29.25" }), {
    default: withCtx(() => [
      _hoisted_1$K
    ]),
    _: 1
  }, 16);
}
var GearIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$P, [["render", _sfc_render$P]]);
var CollectionIcon_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$O = {
  name: "CollectionIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _withScopeId$5 = (n2) => (pushScopeId("data-v-5b6fd6c0"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$J = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode("g", { transform: "translate(0.25 0.25)" }, [
  /* @__PURE__ */ createElementVNode("path", {
    class: "cls-1",
    d: "M27.964,26.2H2.893a.964.964,0,0,1-.964-.964v-13.5a.964.964,0,0,1,.964-.964H27.964a.964.964,0,0,1,.964.964v13.5A.964.964,0,0,1,27.964,26.2ZM2.893,28.125A2.893,2.893,0,0,1,0,25.232v-13.5A2.893,2.893,0,0,1,2.893,8.839H27.964a2.893,2.893,0,0,1,2.893,2.893v13.5a2.893,2.893,0,0,1-2.893,2.893ZM3.857,5.946a.964.964,0,0,0,.964.964H26.036a.964.964,0,0,0,0-1.929H4.821A.964.964,0,0,0,3.857,5.946ZM7.714,2.089a.964.964,0,0,0,.964.964h13.5a.964.964,0,0,0,0-1.929H8.679a.964.964,0,0,0-.964.964Z",
    transform: "translate(0 -1.125)"
  })
], -1));
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 31.357 27.5" }), {
    default: withCtx(() => [
      _hoisted_1$J
    ]),
    _: 1
  }, 16);
}
var CollectionIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$O, [["render", _sfc_render$O], ["__scopeId", "data-v-5b6fd6c0"]]);
const _sfc_main$N = {
  name: "TagIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$I = /* @__PURE__ */ createElementVNode("path", {
  d: "M8.862,26.411a3.473,3.473,0,0,0,2.292.818,3.366,3.366,0,0,0,2.783-1.309l8.895-10.586a7.113,7.113,0,0,0,1.582-4.093l.6-7.8A2.364,2.364,0,0,0,24.2,1.474l-.927-.71A2.229,2.229,0,0,0,21.2.328L13.5,2.292A6.153,6.153,0,0,0,9.79,4.638L.949,15.224A3.284,3.284,0,0,0,.131,17.9a3.593,3.593,0,0,0,1.255,2.455ZM2.7,16.589,11.536,6A5.4,5.4,0,0,1,14.1,4.365L21.74,2.4l.927.818-.545,7.8a4.94,4.94,0,0,1-1.2,2.783l-8.84,10.586a1.09,1.09,0,0,1-.846.464,1.234,1.234,0,0,1-.9-.3L2.914,18.226a1.341,1.341,0,0,1-.491-.818,1.56,1.56,0,0,1,.273-.818ZM19.667,6.6a1.067,1.067,0,0,1-.354.818,1.143,1.143,0,0,1-.791.328,1.2,1.2,0,0,1-.846-.328,1.122,1.122,0,0,1,0-1.636,1.2,1.2,0,0,1,.846-.328,1.14,1.14,0,0,1,.791.328A1.065,1.065,0,0,1,19.667,6.6Z",
  transform: "translate(-0.093 -0.229)"
}, null, -1);
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 24.921 27" }), {
    default: withCtx(() => [
      _hoisted_1$I
    ]),
    _: 1
  }, 16);
}
var TagIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$N, [["render", _sfc_render$N]]);
var SaveAllIcon_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$M = {
  name: "SaveAllIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _withScopeId$4 = (n2) => (pushScopeId("data-v-14919f9a"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$H = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("g", { transform: "translate(0.25 0.25)" }, [
  /* @__PURE__ */ createElementVNode("path", {
    class: "cls-1",
    d: "M28.961,5.432,26.068,2.539l-.675-.289H8.961L8,3.214V8.036H3.214L2.25,9V28.286l.964.964H22.5l.964-.964V23.464h4.821l.964-.964V6.107l-.289-.675Zm-7.425,21.89H4.179V9.964H6.107v5.92H17.679V9.964H19.2L21.536,12.3Zm-9.643-13.5V9.964H15.75v3.857Zm15.429,7.714H23.464V11.893l-.289-.675L20.283,8.325l-.675-.29H9.964V4.179H25.026L27.36,6.513Z",
    transform: "translate(-2.25 -2.25)"
  })
], -1));
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 27.5 27.5" }), {
    default: withCtx(() => [
      _hoisted_1$H
    ]),
    _: 1
  }, 16);
}
var SaveAllIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$M, [["render", _sfc_render$M], ["__scopeId", "data-v-14919f9a"]]);
var AddEmojyIcon_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$L = {
  name: "AddEmojyIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _withScopeId$3 = (n2) => (pushScopeId("data-v-4ccba994"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$G = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("g", { transform: "translate(0.25 0.25)" }, [
  /* @__PURE__ */ createElementVNode("g", { transform: "translate(0 4.48)" }, [
    /* @__PURE__ */ createElementVNode("path", {
      class: "cls-1",
      d: "M12.763,23.93A11.167,11.167,0,1,0,1.6,12.763,11.167,11.167,0,0,0,12.763,23.93Zm0,1.6A12.763,12.763,0,1,0,0,12.763,12.763,12.763,0,0,0,12.763,25.525Z"
    }),
    /* @__PURE__ */ createElementVNode("path", {
      class: "cls-1",
      d: "M9.477,21.482a.8.8,0,0,1,1.09.292,5.586,5.586,0,0,0,9.674,0,.8.8,0,1,1,1.381.8,7.181,7.181,0,0,1-12.437,0,.8.8,0,0,1,.292-1.09Z",
      transform: "translate(-2.641 -6.219)"
    }),
    /* @__PURE__ */ createElementVNode("path", {
      class: "cls-2",
      d: "M14.441,13.643c0,1.321-.715,2.393-1.6,2.393s-1.6-1.072-1.6-2.393.715-2.393,1.6-2.393S14.441,12.322,14.441,13.643Zm6.381,0c0,1.321-.715,2.393-1.6,2.393s-1.6-1.072-1.6-2.393.715-2.393,1.6-2.393S20.822,12.322,20.822,13.643Z",
      transform: "translate(-3.273 -3.273)"
    })
  ]),
  /* @__PURE__ */ createElementVNode("g", {
    id: "plus",
    transform: "translate(21.046)"
  }, [
    /* @__PURE__ */ createElementVNode("path", {
      class: "cls-1",
      d: "M12.355,7.875a.5.5,0,0,1,.5.5v3.982a.5.5,0,0,1-.5.5H8.373a.5.5,0,0,1,0-1h3.484V8.373A.5.5,0,0,1,12.355,7.875Z",
      transform: "translate(-7.875 -7.875)"
    }),
    /* @__PURE__ */ createElementVNode("path", {
      class: "cls-1",
      d: "M16.875,17.373a.5.5,0,0,1,.5-.5h3.982a.5.5,0,1,1,0,1H17.871v3.484a.5.5,0,1,1-1,0Z",
      transform: "translate(-12.893 -12.893)"
    })
  ])
], -1));
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 30.506 30.506" }), {
    default: withCtx(() => [
      _hoisted_1$G
    ]),
    _: 1
  }, 16);
}
var AddEmojyIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["render", _sfc_render$L], ["__scopeId", "data-v-4ccba994"]]);
const _sfc_main$K = {
  name: "LinkIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$F = ["fill"];
const _hoisted_2$n = ["fill"];
const _hoisted_3$h = ["fill"];
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 24.729 24.72" }), {
    default: withCtx(() => [
      createElementVNode("path", {
        fill: _ctx.iconColor,
        d: "M22.242,18l2.123,2.121,4.242-4.242a6,6,0,0,0-8.486-8.486l-4.242,4.242L18,13.758l4.242-4.244a3,3,0,0,1,4.244,4.244Z",
        transform: "translate(-5.635 -5.635)"
      }, null, 8, _hoisted_1$F),
      createElementVNode("path", {
        fill: _ctx.iconColor,
        d: "M18,22.244l2.121,2.121-4.242,4.242a6,6,0,0,1-8.486-8.486l4.242-4.242L13.758,18,9.514,22.244a3,3,0,1,0,4.244,4.242L18,22.242Z",
        transform: "translate(-5.635 -5.635)"
      }, null, 8, _hoisted_2$n),
      createElementVNode("path", {
        fill: _ctx.iconColor,
        d: "M22.244,15.879a1.5,1.5,0,1,0-2.123-2.123l-6.363,6.365a1.5,1.5,0,1,0,2.121,2.121l6.363-6.363Z",
        transform: "translate(-5.635 -5.635)"
      }, null, 8, _hoisted_3$h)
    ]),
    _: 1
  }, 16);
}
var LinkIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["render", _sfc_render$K]]);
const _sfc_main$J = {
  name: "DuplicateIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$E = { transform: "translate(1 1)" };
const _hoisted_2$m = ["stroke"];
function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 26 26" }), {
    default: withCtx(() => [
      createElementVNode("g", _hoisted_1$E, [
        createElementVNode("path", {
          fill: "none",
          stroke: _ctx.iconColor,
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          "stroke-width": "2px",
          d: "M12,24H9a3,3,0,0,1-3-3V9A3,3,0,0,1,9,6H21a3,3,0,0,1,3,3v3M15,30H27a3,3,0,0,0,3-3V15a3,3,0,0,0-3-3H15a3,3,0,0,0-3,3V27a3,3,0,0,0,3,3Z",
          transform: "translate(-6 -6)"
        }, null, 8, _hoisted_2$m)
      ])
    ]),
    _: 1
  }, 16);
}
var DuplicateIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["render", _sfc_render$J]]);
var MenuBar_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$I = {
  name: "MenuBar",
  components: {
    TrashIcon,
    ArrowLeftSquareIcon,
    JumpIcon,
    GearIcon,
    CollectionIcon,
    TagIcon,
    SaveAllIcon,
    AddEmojyIcon,
    LinkIcon,
    DuplicateIcon
  },
  props: {
    tight: { type: Boolean, default: false }
  },
  emits: ["update:centralPartView", "update:deleteCurrentQuestion", "update:duplicateCurrentQuestion"],
  data: () => ({
    QUESTION_SETTINGS,
    LOGIC_JUMP,
    FORM_TRANSFER,
    ADD_EMOJI,
    HYPERLINK,
    RECALL_INFO,
    MERGE_TAGS,
    STORE_ANSWER
  })
};
const _hoisted_1$D = { class: "flex justify-center" };
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TrashIcon = resolveComponent("TrashIcon");
  const _component_GearIcon = resolveComponent("GearIcon");
  const _component_JumpIcon = resolveComponent("JumpIcon");
  const _component_ArrowLeftSquareIcon = resolveComponent("ArrowLeftSquareIcon");
  const _component_CollectionIcon = resolveComponent("CollectionIcon");
  const _component_SaveAllIcon = resolveComponent("SaveAllIcon");
  const _component_TagIcon = resolveComponent("TagIcon");
  const _component_AddEmojyIcon = resolveComponent("AddEmojyIcon");
  const _component_DuplicateIcon = resolveComponent("DuplicateIcon");
  return openBlock(), createElementBlock("div", _hoisted_1$D, [
    createElementVNode("nav", {
      class: normalizeClass(["bg-white p-3 flex menu-bar justify-between rounded max-w-full", [$props.tight ? "" : "gap-2"]])
    }, [
      createElementVNode("div", {
        class: "px-2 cursor-pointer",
        "data-title": "Delete",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:deleteCurrentQuestion"))
      }, [
        createVNode(_component_TrashIcon, {
          width: "21",
          height: "27"
        })
      ]),
      createElementVNode("div", {
        class: "px-2 cursor-pointer",
        "data-title": "Settings",
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:centralPartView", _ctx.QUESTION_SETTINGS))
      }, [
        createVNode(_component_GearIcon, {
          width: "27",
          height: "27"
        })
      ]),
      createElementVNode("div", {
        class: "px-2 cursor-pointer",
        "data-title": "Logic jump",
        onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("update:centralPartView", _ctx.LOGIC_JUMP))
      }, [
        createVNode(_component_JumpIcon, {
          width: "32",
          height: "18"
        })
      ]),
      createElementVNode("div", {
        class: "px-2 cursor-pointer",
        "data-title": "Transfer",
        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("update:centralPartView", _ctx.FORM_TRANSFER))
      }, [
        createVNode(_component_ArrowLeftSquareIcon, {
          width: "27",
          height: "27"
        })
      ]),
      createElementVNode("div", {
        class: "px-2 cursor-pointer",
        "data-title": "Recall info",
        onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("update:centralPartView", _ctx.RECALL_INFO))
      }, [
        createVNode(_component_CollectionIcon, {
          width: "31",
          height: "27"
        })
      ]),
      createElementVNode("div", {
        class: "px-2 cursor-pointer",
        "data-title": "Store Answer",
        onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("update:centralPartView", _ctx.STORE_ANSWER))
      }, [
        createVNode(_component_SaveAllIcon, {
          width: "27",
          height: "27"
        })
      ]),
      createElementVNode("div", {
        class: "px-2 cursor-pointer",
        "data-title": "Merge Tags",
        onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("update:centralPartView", _ctx.MERGE_TAGS))
      }, [
        createVNode(_component_TagIcon, {
          width: "25",
          height: "27"
        })
      ]),
      createElementVNode("div", {
        class: "px-2 cursor-pointer",
        "data-title": "Add Emoji",
        onClick: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("update:centralPartView", _ctx.ADD_EMOJI))
      }, [
        createVNode(_component_AddEmojyIcon, {
          width: "26",
          height: "26"
        })
      ]),
      createElementVNode("div", {
        class: "px-2 cursor-pointer",
        "data-title": "Duplicate",
        onClick: _cache[8] || (_cache[8] = ($event) => _ctx.$emit("update:duplicateCurrentQuestion"))
      }, [
        createVNode(_component_DuplicateIcon, {
          width: "25",
          height: "25"
        })
      ])
    ], 2)
  ]);
}
var MenuBar = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["render", _sfc_render$I], ["__scopeId", "data-v-224a9838"]]);
const _sfc_main$H = {
  name: "QuestionAddingButton",
  components: {
    PlusIcon: render$2
  },
  props: {
    active: { type: Boolean, default: false }
  }
};
const _hoisted_1$C = { class: "group flex gap-4 mt-3 text-gray-600 items-center cursor-pointer" };
const _hoisted_2$l = /* @__PURE__ */ createElementVNode("div", { class: "text-xs" }, " Add Question ", -1);
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PlusIcon = resolveComponent("PlusIcon");
  return openBlock(), createElementBlock("div", _hoisted_1$C, [
    createElementVNode("div", {
      class: normalizeClass(["w-8 h-8 p-1 bg-gray-200 rounded text-gray-400 group-hover:bg-blue-600 group-hover:text-white duration-300", $props.active ? ["bg-blue-600", "text-white"] : []])
    }, [
      createVNode(_component_PlusIcon, {
        class: normalizeClass($props.active ? ["text-white"] : [])
      }, null, 8, ["class"])
    ], 2),
    _hoisted_2$l
  ]);
}
var QuestionAddingButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$H, [["render", _sfc_render$H]]);
var QuestionAddingPopup_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$G = {
  name: "QuestionAddingPopup",
  components: { QuestionCategoryAndType },
  props: {
    formCategory: { type: String, required: true }
  },
  emits: ["add-question", "add-kick-off", "add-typ"],
  data: () => ({
    questionCategory: null,
    type: null,
    workspaceEl: null
  }),
  computed: {
    y: function() {
      var _a;
      return 64 - (((_a = document.getElementById("leftside")) == null ? void 0 : _a.scrollTop) || 0);
    }
  },
  watch: {
    questionCategory: function(c2) {
      if (c2 === null) {
        return;
      }
      if (c2 === QUESTION_CATEGORY_TYP) {
        this.$emit("add-typ", { id: v4(), properties: {} });
        this.reset();
      }
    },
    type: function(t2) {
      if (t2 === null) {
        return;
      }
      this.$emit(
        this.questionCategory === QUESTION_CATEGORY_FOLLOW_UP ? "add-question" : "add-kick-off",
        { type: t2, id: v4(), properties: {} }
      );
      this.reset();
    }
  },
  methods: {
    reset: function() {
      this.questionCategory = null;
      this.type = null;
    }
  }
};
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_QuestionCategoryAndType = resolveComponent("QuestionCategoryAndType");
  return openBlock(), createElementBlock("div", {
    class: "adding-popup z-40",
    style: normalizeStyle({ top: $options.y + "px" })
  }, [
    createVNode(_component_QuestionCategoryAndType, {
      category: _ctx.questionCategory,
      "onUpdate:category": _cache[0] || (_cache[0] = ($event) => _ctx.questionCategory = $event),
      type: _ctx.type,
      "onUpdate:type": _cache[1] || (_cache[1] = ($event) => _ctx.type = $event),
      "form-category": $props.formCategory
    }, null, 8, ["category", "type", "form-category"])
  ], 4);
}
var QuestionAddingPopup = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["render", _sfc_render$G], ["__scopeId", "data-v-0f4bffee"]]);
const _sfc_main$F = {
  name: "QuestionError",
  components: { Error: Error$1 },
  props: { errors: { type: String, default: void 0 } }
};
const _hoisted_1$B = {
  key: 0,
  class: "flex justify-end"
};
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Error = resolveComponent("Error");
  return $props.errors ? (openBlock(), createElementBlock("div", _hoisted_1$B, [
    createVNode(_component_Error, { class: "w-3/4 pr-4" }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString($props.errors), 1)
      ]),
      _: 1
    })
  ])) : createCommentVNode("", true);
}
var QuestionErrors = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["render", _sfc_render$F]]);
const _sfc_main$E = {
  name: "QuestionMultipleChoice",
  components: { QuestionLabel, StopIcon },
  props: {
    properties: { type: Object, default: () => ({ choices: [] }) }
  },
  emits: ["update:properties", "spyCaret"],
  updated: function() {
    var _a;
    if (!((_a = this.properties.choices) == null ? void 0 : _a.length)) {
      this.addChoice();
    }
  },
  methods: {
    uuid: v4,
    addChoice: function() {
      this.$emit("update:properties", { ...this.properties, choices: [...this.properties.choices || [], { id: v4() }] });
    },
    removeChoice: function(index2) {
      this.$emit(
        "update:properties",
        {
          ...this.properties,
          choices: [...this.properties.choices.slice(0, index2), ...this.properties.choices.slice(index2 + 1)]
        }
      );
    },
    addEmojiAndFocus: function(e2, property, pos) {
      const path = property.split(".");
      this.$emit(
        "update:properties",
        {
          ...this.properties,
          ...merge$2({ ...this.properties }, path.reduceRight((all2, item) => ({ [item]: all2 }), injectIntoString(recursivelyGetProp(this.properties, path), pos, e2)))
        }
      );
      const el = this.$refs[property];
      el.focus();
      setTimeout(() => {
        el.selectionEnd = pos + 1;
      }, 1);
    }
  }
};
const _hoisted_1$A = { class: "mt-1 relative rounded-md shadow-sm" };
const _hoisted_2$k = { class: "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none" };
const _hoisted_3$g = ["value", "onInput", "onKeyup", "onMouseup"];
const _hoisted_4$a = ["onClick"];
const _hoisted_5$a = { class: "my-3 py-2 text-navy underline" };
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_QuestionLabel = resolveComponent("QuestionLabel");
  const _component_StopIcon = resolveComponent("StopIcon");
  return openBlock(), createElementBlock(Fragment, null, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.properties.choices, (choice, i2) => {
      return openBlock(), createElementBlock("div", {
        key: `multiple-choice${i2}${choice.id}`
      }, [
        createElementVNode("div", _hoisted_1$A, [
          createElementVNode("div", _hoisted_2$k, [
            createVNode(_component_QuestionLabel, { centered: "" }, {
              default: withCtx(() => [
                createElementVNode("small", null, toDisplayString(i2 + 1), 1)
              ]),
              _: 2
            }, 1024)
          ]),
          createElementVNode("input", {
            ref_for: true,
            ref: `choices.${i2}.label`,
            type: "text",
            class: "focus:ring-indigo-500 focus:border-indigo-500 block w-full pl-16 sm:text-sm border-gray-300 rounded-md bg-gray-200 pr-10",
            placeholder: "Enter the choice",
            value: choice.label,
            onInput: ($event) => _ctx.$emit("update:properties", { ...$props.properties, choices: $props.properties.choices.map((c2) => c2.id === choice.id ? { ...c2, label: $event.target.value } : c2) }),
            onKeyup: ($event) => _ctx.$emit("spyCaret", `choices.${i2}.label`, $event.target.selectionEnd),
            onMouseup: ($event) => _ctx.$emit("spyCaret", `choices.${i2}.label`, $event.target.selectionEnd)
          }, null, 40, _hoisted_3$g),
          $props.properties.choices && $props.properties.choices.length > 1 ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "absolute inset-y-0 right-0 pr-3 flex items-center cursor-pointer",
            onClick: ($event) => $options.removeChoice(i2)
          }, [
            createVNode(_component_StopIcon, {
              class: "h-5 w-5 text-gray-400",
              "aria-hidden": "true"
            })
          ], 8, _hoisted_4$a)) : createCommentVNode("", true)
        ])
      ]);
    }), 128)),
    createElementVNode("div", _hoisted_5$a, [
      createElementVNode("span", {
        class: "cursor-pointer",
        onClick: _cache[0] || (_cache[0] = (...args) => $options.addChoice && $options.addChoice(...args))
      }, " Add choice ")
    ])
  ], 64);
}
var QuestionMultipleChoice = /* @__PURE__ */ _export_sfc$1(_sfc_main$E, [["render", _sfc_render$E]]);
const _sfc_main$D = {
  name: "QuestionNav",
  emits: ["update:offsetQuestion", "update:duplicateCurrentQuestion", "click:previewCurrentQuestion"]
};
const _hoisted_1$z = { class: "flex text-gray-500 px-3 py-5 text-xs border-b" };
const _hoisted_2$j = { class: "w-1/3 text-right" };
const _hoisted_3$f = { class: "w-1/3 text-center" };
const _hoisted_4$9 = { class: "mb-2" };
const _hoisted_5$9 = { class: "w-1/3" };
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$z, [
    createElementVNode("div", _hoisted_2$j, [
      createElementVNode("div", {
        class: "cursor-pointer select-none",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:offsetQuestion", -1))
      }, " \u25C4 See previous question ")
    ]),
    createElementVNode("div", _hoisted_3$f, [
      createElementVNode("div", _hoisted_4$9, [
        createElementVNode("button", {
          class: "rounded border py-1 px-2 w-40",
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:duplicateCurrentQuestion"))
        }, " Duplicate question ")
      ]),
      createElementVNode("div", null, [
        createElementVNode("button", {
          class: "rounded border py-1 px-2 w-40 select-none",
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:previewCurrentQuestion"))
        }, " Preview this question ")
      ])
    ]),
    createElementVNode("div", _hoisted_5$9, [
      createElementVNode("div", {
        class: "cursor-pointer",
        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("update:offsetQuestion", 1))
      }, " See next question \u25BA ")
    ])
  ]);
}
var QuestionNav = /* @__PURE__ */ _export_sfc$1(_sfc_main$D, [["render", _sfc_render$D]]);
const _sfc_main$C = {
  name: "QuestionOpen",
  props: {
    properties: { type: Object, default: () => ({}) }
  },
  emits: ["update:properties"]
};
const _hoisted_1$y = ["value"];
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  var _a;
  return openBlock(), createElementBlock("div", null, [
    createElementVNode("input", {
      type: "text",
      class: "shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full sm:text-sm border-gray-300 rounded-md text-gray-500 italic",
      placeholder: "Enter the placeholder",
      value: ((_a = $props.properties) == null ? void 0 : _a.placeholder) || "",
      onInput: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:properties", { ...$props.properties, placeholder: $event.target.value }))
    }, null, 40, _hoisted_1$y)
  ]);
}
var QuestionOpen = /* @__PURE__ */ _export_sfc$1(_sfc_main$C, [["render", _sfc_render$C]]);
var QuestionRatingScore_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$B = {
  name: "QuestionRatingScore",
  props: {
    properties: {
      type: Object,
      default: () => ({
        from: { type: [String, Number], default: 1 },
        to: { type: [String, Number], default: 5 },
        label_left: { type: String, default: "" },
        label_middle: { type: String, default: "" },
        label_right: { type: String, default: "" }
      })
    }
  },
  emits: ["update:properties", "spyCaret"],
  setup: function(props2, ctx) {
    if (!props2.properties.from || !props2.properties.to) {
      ctx.emit(
        "update:properties",
        { ...props2.properties.properties, from: props2.properties.from || 1, to: props2.properties.to || 5 }
      );
    }
  },
  computed: {
    ratingBlocks: function() {
      return Array((this.properties.to || 5) - (this.properties.from || 1) + 1).fill(0, 0).map((_2, index2) => +(this.properties.from || 1) + index2);
    }
  },
  updated: function() {
    if (!this.properties.from || !this.properties.to) {
      this.$emit(
        "update:properties",
        { ...this.properties, from: this.properties.from || 1, to: this.properties.to || 5 }
      );
    }
  }
};
const _hoisted_1$x = { class: "flex gap-2 justify-between items-start pt-2" };
const _hoisted_2$i = { class: "absolute top-0 left-0 right-0 bottom-0 flex items-center justify-center rounded pointer-events-none" };
const _hoisted_3$e = { class: "flex gap-2 py-2" };
const _hoisted_4$8 = { class: "text-xs text-gray-500 w-1/3" };
const _hoisted_5$8 = { class: "text-xs text-gray-500 w-1/3 text-center" };
const _hoisted_6$7 = { class: "text-xs text-gray-500 w-1/3 text-right" };
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    createElementVNode("div", _hoisted_1$x, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.ratingBlocks, (r2) => {
        return openBlock(), createElementBlock("div", {
          key: `ratingBlocks${r2}`,
          class: "border border-gray-500 text-gray-600 rounded w-full text-center rating-block relative bg-gray-300 bg-opacity-60 hover:bg-opacity-90 transition-all cursor-pointer"
        }, [
          createElementVNode("div", _hoisted_2$i, toDisplayString(r2), 1)
        ]);
      }), 128))
    ]),
    createElementVNode("div", _hoisted_3$e, [
      createElementVNode("div", _hoisted_4$8, toDisplayString($props.properties.label_left), 1),
      createElementVNode("div", _hoisted_5$8, toDisplayString($props.properties.label_middle), 1),
      createElementVNode("div", _hoisted_6$7, toDisplayString($props.properties.label_right), 1)
    ])
  ], 64);
}
var QuestionRatingScore = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["render", _sfc_render$B], ["__scopeId", "data-v-a95b2ab2"]]);
const _sfc_main$A = {
  name: "QuestionTimeDelay",
  components: { SelectBox, Input },
  props: {
    properties: {
      type: Object,
      default: () => ({
        period: ["days"],
        restrict_delay: false,
        max_delay: 1
      })
    }
  },
  data: function() {
    return {
      selectedPeriod: this.properties.period ? this.properties.period[0] : "days"
    };
  },
  computed: {
    selectBoxItems: function() {
      return (this.properties.period || []).map((i2) => ({ value: i2, title: i2 }));
    }
  }
};
const _hoisted_1$w = { class: "py-4 flex gap-2" };
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SelectBox = resolveComponent("SelectBox");
  const _component_Input = resolveComponent("Input");
  return openBlock(), createElementBlock("div", _hoisted_1$w, [
    withDirectives(createVNode(_component_SelectBox, {
      modelValue: _ctx.selectedPeriod,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.selectedPeriod = $event),
      items: $options.selectBoxItems,
      classes: "py-1.5 border-blue-500 border capitalize text-blue-500"
    }, null, 8, ["modelValue", "items"]), [
      [vShow, $options.selectBoxItems.length > 1]
    ]),
    createVNode(_component_Input, {
      class: "border-gray-500 border text-xxs px-4 py-0",
      placeholder: `Enter number of ${_ctx.selectedPeriod}`,
      disabled: ""
    }, null, 8, ["placeholder"])
  ]);
}
var QuestionTimeDelay = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["render", _sfc_render$A]]);
const _sfc_main$z = {
  name: "QuestionYesNo",
  components: {
    QuestionLabel
  },
  props: {
    properties: { type: Object, default: () => ({ choices: [] }) }
  },
  emits: ["update:properties", "spyCaret"],
  setup: function(props2, context) {
    var _a;
    if (!((_a = props2.properties.choices) == null ? void 0 : _a.length)) {
      context.emit("update:properties", {
        ...props2.properties,
        choices: [
          { id: v4(), label: "Yes" },
          { id: v4(), label: "No" }
        ]
      });
    }
  },
  methods: {
    addEmojiAndFocus: function(e2, property, pos) {
      const path = property.split(".");
      this.$emit(
        "update:properties",
        {
          ...this.properties,
          ...merge$2({ ...this.properties }, path.reduceRight((all2, item) => ({ [item]: all2 }), injectIntoString(recursivelyGetProp(this.properties, path), pos, e2)))
        }
      );
      const el = this.$refs[property];
      el.focus();
      setTimeout(() => {
        el.selectionEnd = pos + 1;
      }, 1);
    }
  }
};
const _hoisted_1$v = { class: "mt-1 relative rounded-md shadow-sm" };
const _hoisted_2$h = { class: "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none" };
const _hoisted_3$d = ["placeholder", "value", "onInput", "onKeyup", "onMouseup"];
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_QuestionLabel = resolveComponent("QuestionLabel");
  return openBlock(true), createElementBlock(Fragment, null, renderList($props.properties.choices, (choice, i2) => {
    return openBlock(), createElementBlock("div", {
      key: `multiple-choice${i2}${choice.id}`
    }, [
      createElementVNode("div", _hoisted_1$v, [
        createElementVNode("div", _hoisted_2$h, [
          createVNode(_component_QuestionLabel, { centered: "" }, {
            default: withCtx(() => [
              createElementVNode("small", null, toDisplayString(i2 + 1), 1)
            ]),
            _: 2
          }, 1024)
        ]),
        createElementVNode("input", {
          ref_for: true,
          ref: `choices.${i2}.label`,
          type: "text",
          class: "focus:ring-indigo-500 focus:border-indigo-500 block w-full pl-16 sm:text-sm border-gray-300 rounded-md bg-gray-200",
          placeholder: i2 ? "No" : "Yes",
          value: choice.label,
          onInput: ($event) => _ctx.$emit("update:properties", { ...$props.properties, choices: $props.properties.choices.map((c2) => c2.id === choice.id ? { ...c2, label: $event.target.value } : c2) }),
          onKeyup: ($event) => _ctx.$emit("spyCaret", `choices.${i2}.label`, $event.target.selectionEnd),
          onMouseup: ($event) => _ctx.$emit("spyCaret", `choices.${i2}.label`, $event.target.selectionEnd)
        }, null, 40, _hoisted_3$d)
      ])
    ]);
  }), 128);
}
var QuestionYesNo = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["render", _sfc_render$z]]);
class Cursor {
  static getCurrentCursorPosition(parentElement) {
    const selection = window.getSelection();
    let charCount = -1;
    let node;
    if (selection.focusNode) {
      if (Cursor._isChildOf(selection.focusNode, parentElement)) {
        node = selection.focusNode;
        charCount = selection.focusOffset;
        while (node) {
          if (node === parentElement) {
            break;
          }
          if (node.previousSibling) {
            node = node.previousSibling;
            charCount += node.textContent.length;
          } else {
            node = node.parentNode;
            if (node === null) {
              break;
            }
          }
        }
      }
    }
    return charCount;
  }
  static getCurrentSelection(parentElement) {
    const selection = window.getSelection();
    let charCount = -1;
    let node;
    let startCount;
    if (selection.focusNode) {
      if (Cursor._isChildOf(selection.focusNode, parentElement)) {
        node = selection.focusNode;
        charCount = selection.focusOffset;
        startCount = selection.baseOffset;
        while (node) {
          if (node === parentElement) {
            break;
          }
          if (node.previousSibling) {
            node = node.previousSibling;
            startCount += node.textContent.length;
            charCount += node.textContent.length;
          } else {
            node = node.parentNode;
            if (node === null) {
              break;
            }
          }
        }
      }
    }
    return [startCount, charCount];
  }
  static setCurrentCursorPosition(chars, element2) {
    if (chars >= 0) {
      const selection = window.getSelection();
      const range = Cursor._createRange(element2, { count: chars });
      if (range) {
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }
  }
  static _createRange(node, chars, range) {
    if (!range) {
      range = document.createRange();
      range.selectNode(node);
      range.setStart(node, 0);
    }
    if (chars.count === 0) {
      range.setEnd(node, chars.count);
    } else if (node && chars.count > 0) {
      if (node.nodeType === Node.TEXT_NODE) {
        if (node.textContent.length < chars.count) {
          chars.count -= node.textContent.length;
        } else {
          range.setEnd(node, chars.count);
          chars.count = 0;
        }
      } else {
        for (let lp = 0; lp < node.childNodes.length; lp++) {
          range = Cursor._createRange(node.childNodes[lp], chars, range);
          if (chars.count === 0) {
            break;
          }
        }
      }
    }
    return range;
  }
  static _isChildOf(node, parentElement) {
    while (node !== null) {
      if (node === parentElement) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  }
}
var cursor = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Cursor
}, Symbol.toStringTag, { value: "Module" }));
var TextFieldMark_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$y = {
  name: "TextFieldMark",
  components: {
    StopIcon
  },
  emits: ["clickDelete"]
};
const _hoisted_1$u = { class: "mark pointer-events-auto text-red-600 relative" };
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_StopIcon = resolveComponent("StopIcon");
  return openBlock(), createElementBlock("span", _hoisted_1$u, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true),
    createElementVNode("button", {
      class: "mark-delete absolute hidden left-full top-0",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("clickDelete"))
    }, [
      createVNode(_component_StopIcon)
    ])
  ]);
}
var TextFieldMark = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["render", _sfc_render$y], ["__scopeId", "data-v-051b2727"]]);
const _sfc_main$x = {
  name: "TextFieldWithMarks",
  components: { TextFieldMark },
  props: {
    text: { type: String, default: "" },
    marks: { type: Array, default: () => [] }
  },
  emits: ["removeMark"],
  computed: {
    renderArray: function() {
      const textArray = this.text.split("");
      const newTextArray = [];
      let cursor2 = 0;
      for (const index2 in this.marks) {
        const [start2, end2] = this.marks[index2];
        newTextArray.push(textArray.slice(cursor2, start2).join(""));
        newTextArray.push({ c: TextFieldMark, d: textArray.slice(start2, end2).join(""), index: index2 });
        cursor2 = end2;
      }
      newTextArray.push(textArray.slice(cursor2).join(""));
      return newTextArray;
    }
  }
};
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(true), createElementBlock(Fragment, null, renderList($options.renderArray, (chunk) => {
    return openBlock(), createElementBlock(Fragment, { key: chunk }, [
      !chunk.c ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createTextVNode(toDisplayString(chunk), 1)
      ], 64)) : createCommentVNode("", true),
      chunk.c ? (openBlock(), createBlock(resolveDynamicComponent(chunk.c), {
        key: 1,
        onClickDelete: ($event) => _ctx.$emit("removeMark", chunk.index)
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(chunk.d), 1)
        ]),
        _: 2
      }, 1064, ["onClickDelete"])) : createCommentVNode("", true)
    ], 64);
  }), 128);
}
var TextFieldWithMarks = /* @__PURE__ */ _export_sfc$1(_sfc_main$x, [["render", _sfc_render$x]]);
var TextField_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$w = {
  name: "TextField",
  components: {
    TextFieldWithMarks
  },
  props: {
    placeholder: { type: String, default: "" },
    modelValue: { type: String, default: "" },
    required: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "spyCaret"],
  data: function() {
    return {
      value: this.modelValue
    };
  },
  computed: {
    marks: function() {
      const currentText = this.modelValue;
      const re2 = /\[Recall info = answer to [K|F]OQ-(\d+)\]|{{.+?}}/g;
      let match;
      const marks = [];
      while ((match = re2.exec(currentText)) != null) {
        marks.push([match.index, match.index + match[0].length]);
      }
      return marks;
    }
  },
  methods: {
    handleChange: function(text2) {
      this.$emit("update:modelValue", text2);
    },
    spyCaret: function(event) {
      this.$emit(
        "spyCaret",
        {
          pos: Cursor.getCurrentCursorPosition(event.target),
          selection: Cursor.getCurrentSelection(event.target)
        }
      );
    },
    focus: function(pos, selection) {
      this.$refs.textField.focus();
      setTimeout(() => {
        this.setCaretPos(pos);
      }, 100);
    },
    setCaretPos: function(pos) {
      Cursor.setCurrentCursorPosition(pos, this.$refs.textField);
      this.spyCaret({ target: this.$refs.textField });
    },
    inject: function(subject, pos, selection) {
      this.value = injectIntoString(
        this.$refs.textField.innerText.replace(/(\r\n|\r|\n){2,}/g, "\n"),
        pos,
        subject
      );
      this.handleChange(this.value);
      this.focus(pos + subject.length, selection);
    },
    handleRemoveMark: function(markIndex) {
      const [start2, end2] = this.marks[markIndex];
      const currentText = this.$refs.textField.innerText;
      const newText = currentText.substring(0, start2) + currentText.substring(end2);
      this.$refs.textField.innerText = newText;
      this.setCaretPos(start2);
      this.handleChange(newText);
    }
  }
};
const _hoisted_1$t = { class: "relative" };
const _hoisted_2$g = ["placeholder"];
const _hoisted_3$c = {
  key: 0,
  class: "absolute left-0 top-0 bottom-0 right-0 pointer-events-none whitespace-pre-wrap"
};
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TextFieldWithMarks = resolveComponent("TextFieldWithMarks");
  return openBlock(), createElementBlock("div", _hoisted_1$t, [
    createElementVNode("div", {
      ref: "textField",
      class: normalizeClass({ required: $props.required }),
      contenteditable: "true",
      placeholder: $props.placeholder,
      onInput: _cache[0] || (_cache[0] = ($event) => $options.handleChange($event.target.innerText)),
      onKeyup: _cache[1] || (_cache[1] = (...args) => $options.spyCaret && $options.spyCaret(...args)),
      onMouseup: _cache[2] || (_cache[2] = (...args) => $options.spyCaret && $options.spyCaret(...args))
    }, toDisplayString(_ctx.value), 43, _hoisted_2$g),
    $options.marks.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$c, [
      createVNode(_component_TextFieldWithMarks, {
        text: $props.modelValue,
        marks: $options.marks,
        onRemoveMark: $options.handleRemoveMark
      }, null, 8, ["text", "marks", "onRemoveMark"])
    ])) : createCommentVNode("", true)
  ]);
}
var TextField = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["render", _sfc_render$w], ["__scopeId", "data-v-42307cda"]]);
const _sfc_main$v = {
  name: "ControlsIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$s = /* @__PURE__ */ createElementVNode("g", null, [
  /* @__PURE__ */ createElementVNode("path", { d: "M10,762.5h619.8c13.5-30.9,44.4-52.5,80.2-52.5s66.6,21.6,80.2,52.5H990v70H790.2C776.6,863.4,745.8,885,710,885s-66.6-21.6-80.2-52.5H10" }),
  /* @__PURE__ */ createElementVNode("path", { d: "M10,465h199.8c13.5-30.9,44.4-52.5,80.2-52.5c35.8,0,66.6,21.6,80.2,52.5H990v70H370.2c-13.5,30.9-44.4,52.5-80.2,52.5c-35.8,0-66.6-21.6-80.2-52.5H10" }),
  /* @__PURE__ */ createElementVNode("path", { d: "M10,167.5h619.8c13.5-30.9,44.4-52.5,80.2-52.5s66.6,21.6,80.2,52.5H990v70H790.2C776.6,268.4,745.8,290,710,290s-66.6-21.6-80.2-52.5H10" })
], -1);
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 1000 1000" }), {
    default: withCtx(() => [
      _hoisted_1$s
    ]),
    _: 1
  }, 16);
}
var ControlsIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["render", _sfc_render$v]]);
const _sfc_main$u = {
  name: "QuestionView",
  components: {
    ArrowRightIcon: render$l,
    QuestionOpen,
    TextField,
    ControlsIcon
  },
  props: {
    question: {
      type: Object,
      props: {
        title: { type: String, default: "" },
        type: { type: String },
        properties: { type: Object, default: {} }
      },
      required: true
    },
    index: { type: Number, required: true },
    questionType: { type: String, required: true },
    theme: { type: Object, default: void 0 }
  },
  emits: ["update:question", "spyCaret", "click:settings"],
  data: function() {
    return {
      caret: { property: null, pos: 0 }
    };
  },
  computed: {
    iconLetter: function() {
      return this.questionType === QUESTION_CATEGORY_TYP ? "TYP" : "Q";
    },
    questionComponent: function() {
      return {
        [QUESTION_TYPE_OPEN]: QuestionOpen,
        [QUESTION_TYPE_MULTIPLE_CHOICE]: QuestionMultipleChoice,
        [QUESTION_TYPE_YES_NO]: QuestionYesNo,
        [QUESTION_TYPE_DELAY]: QuestionTimeDelay,
        [QUESTION_TYPE_RATING_SCORE]: QuestionRatingScore
      }[this.question.type] || null;
    }
  },
  watch: {
    question: function(v2, p2) {
      var _a, _b;
      if ((v2 == null ? void 0 : v2.id) !== (p2 == null ? void 0 : p2.id)) {
        this.description = (_a = this.question) == null ? void 0 : _a.description;
        this.title = (_b = this.question) == null ? void 0 : _b.title;
        this.caret = { property: null, pos: 0 };
      }
    }
  },
  methods: {
    setCaret: function(property, pos, selection) {
      this.caret = { property, pos, selection };
    },
    spyCaret: function(property, { pos, selection }) {
      this.caret = {
        property,
        pos,
        selection
      };
    },
    addEmojiAndFocus: function(e2) {
      if (!this.caret.property) {
        return;
      }
      const el = this.$refs[this.caret.property];
      if (!el) {
        this.$refs.QuestionComponent.addEmojiAndFocus && this.$refs.QuestionComponent.addEmojiAndFocus(e2, this.caret.property, this.caret.pos);
        return;
      }
      el.inject(e2, this.caret.pos, this.caret.selection);
    },
    inject: function(value) {
      if (!this.caret.property) {
        return;
      }
      const el = this.$refs[this.caret.property];
      if (!el || !el.inject) {
        return;
      }
      el.inject(value, this.caret.pos, this.caret.selection);
    }
  }
};
const _hoisted_1$r = { class: "flex py-4 px-2 gap-4" };
const _hoisted_2$f = { class: "w-1/4 font-bold flex items-start justify-between pt-1" };
const _hoisted_3$b = { class: "flex gap-2" };
const _hoisted_4$7 = { class: "w-3/4 pr-4" };
const _hoisted_5$7 = {
  key: 0,
  class: "flex gap-2 py-4"
};
const _hoisted_6$6 = ["src"];
const _hoisted_7$5 = {
  key: 1,
  class: "py-3 lg:w-8/12"
};
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c, _d;
  const _component_ControlsIcon = resolveComponent("ControlsIcon");
  const _component_ArrowRightIcon = resolveComponent("ArrowRightIcon");
  const _component_TextField = resolveComponent("TextField");
  return openBlock(), createElementBlock("div", _hoisted_1$r, [
    createElementVNode("div", _hoisted_2$f, [
      createElementVNode("div", null, [
        createVNode(_component_ControlsIcon, {
          class: "cursor-pointer text-gray-600 hover:text-black",
          width: "22",
          height: "22",
          "icon-color": "currentColor",
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click:settings"))
        })
      ]),
      createElementVNode("div", _hoisted_3$b, [
        createElementVNode("span", {
          class: "text-lg",
          style: normalizeStyle({ color: (_a = $props.theme) == null ? void 0 : _a.questions })
        }, toDisplayString($options.iconLetter) + toDisplayString($props.index), 5),
        createElementVNode("span", {
          class: "inline-block w-5 h-5 bg-black rounded-full text-white flex items-center justify-center mt-1",
          style: normalizeStyle({ backgroundColor: (_b = $props.theme) == null ? void 0 : _b.questions })
        }, [
          createVNode(_component_ArrowRightIcon, { class: "h-4 w-4" })
        ], 4)
      ])
    ]),
    createElementVNode("div", _hoisted_4$7, [
      (openBlock(), createBlock(_component_TextField, {
        key: `title${$props.question.id}`,
        ref: "title",
        class: "text-2xl",
        style: normalizeStyle({ color: (_c = $props.theme) == null ? void 0 : _c.questions }),
        placeholder: "Add title",
        "model-value": $props.question.title,
        required: $props.question.properties.required,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:question", { ...$props.question, title: $event })),
        onSpyCaret: _cache[2] || (_cache[2] = ($event) => $options.spyCaret("title", $event))
      }, null, 8, ["style", "model-value", "required"])),
      (openBlock(), createBlock(_component_TextField, {
        key: `description${$props.question.id}`,
        ref: "description",
        class: "text-xl text-gray-600",
        style: normalizeStyle({ color: (_d = $props.theme) == null ? void 0 : _d.descriptions }),
        placeholder: "Description (optional)",
        "model-value": $props.question.description,
        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("update:question", { ...$props.question, description: $event })),
        onSpyCaret: _cache[4] || (_cache[4] = ($event) => $options.spyCaret("description", $event))
      }, null, 8, ["style", "model-value"])),
      $props.question.attachments && $props.question.attachments.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_5$7, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.question.attachments, (file) => {
          return openBlock(), createElementBlock("div", {
            key: `question-view-file-${file.src}`,
            class: "max-w-xs"
          }, [
            createElementVNode("img", {
              class: "w-full",
              src: `/storage/${file.src}`,
              alt: ""
            }, null, 8, _hoisted_6$6)
          ]);
        }), 128))
      ])) : createCommentVNode("", true),
      $options.questionComponent ? (openBlock(), createElementBlock("div", _hoisted_7$5, [
        (openBlock(), createBlock(resolveDynamicComponent($options.questionComponent), {
          key: $props.question.id,
          ref: "QuestionComponent",
          properties: $props.question.properties,
          "onUpdate:properties": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("update:question", { ...$props.question, properties: $event })),
          onSpyCaret: $options.setCaret
        }, null, 40, ["properties", "onSpyCaret"]))
      ])) : createCommentVNode("", true)
    ])
  ]);
}
var QuestionView = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["render", _sfc_render$u]]);
const _sfc_main$t = {
  name: "SettingSelectBox",
  components: { SelectBox },
  props: {
    modelValue: { type: [String, Number], default: "" },
    items: { type: Array, required: true }
  },
  emits: ["update:modelValue"],
  setup: function(props2, ctx) {
    var _a;
    if (!props2.modelValue) {
      ctx.emit("update:modelValue", ((_a = props2.items[props2.items.length - 1]) == null ? void 0 : _a.value) + "");
    }
  }
};
const _hoisted_1$q = { class: "text-xs text-navy" };
const _hoisted_2$e = { class: "flex justify-between" };
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SelectBox = resolveComponent("SelectBox");
  return openBlock(), createElementBlock("div", _hoisted_1$q, [
    createElementVNode("div", _hoisted_2$e, [
      createElementVNode("span", null, [
        renderSlot(_ctx.$slots, "default")
      ]),
      createElementVNode("div", null, [
        createVNode(_component_SelectBox, {
          class: "h-6 w-32",
          "model-value": $props.modelValue,
          items: $props.items,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", $event))
        }, null, 8, ["model-value", "items"])
      ])
    ])
  ]);
}
var SettingSelectBox = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["render", _sfc_render$t]]);
const _sfc_main$s = {
  name: "Canvas",
  components: { FormTransfer, FlowChart, Question: Question$1 },
  props: {
    questions: { type: Array, required: true },
    logic: { type: Array, required: true }
  },
  emits: ["click:goToLogicJump", "update:goToFormTransfer", "update:currentQuestion"],
  data: function() {
    return {
      answersCoordinates: [],
      questionsCoordinates: {},
      questionsToForm: {},
      showFlowChart: false
    };
  },
  computed: {
    kickOffs: function() {
      return this.questions.filter((q) => q.category === QUESTION_CATEGORY_KICK_OFF);
    },
    followUps: function() {
      const questionRows = [];
      let row = 0;
      this.questions.filter((q) => q.category === QUESTION_CATEGORY_FOLLOW_UP).forEach((q) => {
        if (this.questionsToForm[q.id]) {
          row++;
        }
        questionRows[row] = [...questionRows[row] || [], q];
      });
      return questionRows;
    },
    typs: function() {
      return this.questions.filter((q) => q.category === QUESTION_CATEGORY_TYP);
    }
  },
  mounted() {
    this.questionsCoordinates = this.calculateQuestionsCoordinates();
    setTimeout(() => {
      this.questionsCoordinates = this.calculateQuestionsCoordinates();
      this.showFlowChart = true;
    }, 500);
  },
  methods: {
    logicByQuestionId: function(id) {
      return this.logic.filter((l2) => l2.question_id === id) || [];
    },
    handleUpdateAnswersCoordinates: function(qId, coords) {
      const qRef = this.$refs[qId][0];
      this.answersCoordinates = this.answersCoordinates.filter((c2) => c2.qId !== qId);
      coords.forEach(([x2, y2, toId, toForm]) => {
        if (toForm) {
          this.questionsToForm[qId] = toId;
        }
        this.answersCoordinates.push({ x: qRef.offsetLeft + x2, y: qRef.offsetTop + y2, toId, toForm, qId });
      });
    },
    calculateQuestionsCoordinates: function() {
      return Object.fromEntries(
        Object.keys(this.$refs).map((r2) => {
          var _a;
          return [
            r2,
            {
              x1: this.$refs[r2][0].offsetLeft + (r2.indexOf("form") === 0 ? this.$refs[r2][0].parentNode.offsetLeft : 0),
              x2: this.$refs[r2][0].offsetLeft + this.$refs[r2][0].offsetWidth + (r2.indexOf("form") === 0 ? this.$refs[r2][0].parentNode.offsetLeft : 0),
              y: this.$refs[r2][0].offsetTop + 10 + (r2.indexOf("form") === 0 ? this.$refs[r2][0].parentNode.offsetTop : 0),
              index: ((_a = this.questions.find((q) => q.id === r2)) == null ? void 0 : _a.index) || r2
            }
          ];
        })
      );
    },
    getFormId: function(idSting, qId) {
      return parseInt(idSting.replace("form-", "").replace(`${qId}-`, ""));
    }
  }
};
const _hoisted_1$p = { class: "h-full bg-white bg-[#F8F8F8] overflow-y-auto" };
const _hoisted_2$d = { class: "relative z-10 pt-6 pb-8 px-4" };
const _hoisted_3$a = { class: "flex" };
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FlowChart = resolveComponent("FlowChart");
  const _component_Question = resolveComponent("Question");
  const _component_FormTransfer = resolveComponent("FormTransfer");
  return openBlock(), createElementBlock("div", _hoisted_1$p, [
    createElementVNode("div", _hoisted_2$d, [
      withDirectives(createVNode(_component_FlowChart, {
        class: "absolute z-0 left-0 top-0 bottom-0 right-0",
        questions: _ctx.questionsCoordinates,
        answers: _ctx.answersCoordinates
      }, null, 8, ["questions", "answers"]), [
        [vShow, _ctx.showFlowChart]
      ]),
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.kickOffs, (question) => {
        return openBlock(), createElementBlock("div", {
          key: `canvas-question-${question.id}`,
          ref_for: true,
          ref: question.id,
          class: "relative z-10 pr-10 grid grid-cols-2"
        }, [
          createVNode(_component_Question, {
            question,
            logic: $options.logicByQuestionId(question.id),
            questions: $props.questions,
            "first-row": true,
            "onUpdate:answersCoordinates": $options.handleUpdateAnswersCoordinates,
            "onClick:goToLogicJump": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click:goToLogicJump", $event)),
            onClick: ($event) => _ctx.$emit("update:currentQuestion", question)
          }, null, 8, ["question", "logic", "questions", "onUpdate:answersCoordinates", "onClick"]),
          _ctx.questionsToForm[question.id] ? (openBlock(), createElementBlock("div", {
            key: 0,
            ref_for: true,
            ref: _ctx.questionsToForm[question.id]
          }, [
            createVNode(_component_FormTransfer, {
              "question-id": question.id,
              "form-id": $options.getFormId(_ctx.questionsToForm[question.id], question.id),
              "first-row": true,
              "onUpdate:goToFormTransfer": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:goToFormTransfer", $event))
            }, null, 8, ["question-id", "form-id"])
          ], 512)) : createCommentVNode("", true)
        ]);
      }), 128)),
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.followUps, (followUpsQ, i2) => {
        return openBlock(), createElementBlock("div", {
          key: `follow-ups-row-${i2}`
        }, [
          createElementVNode("div", {
            class: normalizeClass({
              grid: followUpsQ.length > 2,
              "grid-cols-2": followUpsQ.length === 4,
              "grid-cols-3": followUpsQ.length > 2 && followUpsQ.length !== 4
            })
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(followUpsQ, (question) => {
              return openBlock(), createElementBlock("div", {
                key: `canvas-question-${question.id}`,
                ref_for: true,
                ref: question.id,
                class: "relative z-10 pr-10 grid grid-cols-2"
              }, [
                createVNode(_component_Question, {
                  question,
                  logic: $options.logicByQuestionId(question.id),
                  questions: $props.questions,
                  "onUpdate:answersCoordinates": $options.handleUpdateAnswersCoordinates,
                  "onClick:goToLogicJump": _cache[2] || (_cache[2] = ($event) => _ctx.$emit("click:goToLogicJump", $event)),
                  onClick: ($event) => _ctx.$emit("update:currentQuestion", question)
                }, null, 8, ["question", "logic", "questions", "onUpdate:answersCoordinates", "onClick"]),
                _ctx.questionsToForm[question.id] ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  ref_for: true,
                  ref: _ctx.questionsToForm[question.id]
                }, [
                  createVNode(_component_FormTransfer, {
                    "question-id": question.id,
                    "form-id": $options.getFormId(_ctx.questionsToForm[question.id], question.id),
                    "onUpdate:goToFormTransfer": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("update:goToFormTransfer", $event))
                  }, null, 8, ["question-id", "form-id"])
                ], 512)) : createCommentVNode("", true)
              ]);
            }), 128))
          ], 2)
        ]);
      }), 128)),
      createElementVNode("div", _hoisted_3$a, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.typs, (question) => {
          return openBlock(), createElementBlock("div", {
            key: `canvas-question-${question.id}`,
            ref_for: true,
            ref: question.id,
            class: "relative z-10 pr-10"
          }, [
            createVNode(_component_Question, {
              question,
              logic: $options.logicByQuestionId(question.id),
              questions: $props.questions,
              "onUpdate:answersCoordinates": $options.handleUpdateAnswersCoordinates,
              "onClick:goToLogicJump": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("click:goToLogicJump", $event)),
              onClick: ($event) => _ctx.$emit("update:currentQuestion", question)
            }, null, 8, ["question", "logic", "questions", "onUpdate:answersCoordinates", "onClick"])
          ]);
        }), 128))
      ])
    ])
  ]);
}
var Canvas = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["render", _sfc_render$s]]);
var CanvasButton_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$r = {
  name: "CanvasButton",
  components: { ChevronDoubleRightIcon: render$7 },
  emits: ["onClick"]
};
const _withScopeId$2 = (n2) => (pushScopeId("data-v-df4251fa"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$o = { class: "flex justify-end absolute top-0 left-0 z-30 w-1/5 bg-white px-1 py-2 whitespace-nowrap canvas-button-shadow rounded" };
const _hoisted_2$c = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("span", { class: "delay-300" }, "Open Canvas", -1));
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ChevronDoubleRightIcon = resolveComponent("ChevronDoubleRightIcon");
  return openBlock(), createElementBlock("div", _hoisted_1$o, [
    createElementVNode("button", {
      class: "flex gap-2 text-txtgray text-xxs",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("onClick"))
    }, [
      _hoisted_2$c,
      createVNode(_component_ChevronDoubleRightIcon, { class: "h-5 w-5 duration-300" })
    ])
  ]);
}
var CanvasButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["render", _sfc_render$r], ["__scopeId", "data-v-df4251fa"]]);
const _sfc_main$q = {
  name: "ArrowDownIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$n = /* @__PURE__ */ createElementVNode("path", {
  id: "Path_36",
  fill: "currentColor",
  d: "M6.7,8.1,2,3.4,3.4,2,6.7,5.3,10,2l1.4,1.4Z",
  transform: "translate(-2 -2)"
}, null, -1);
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 9.4 6.1" }), {
    default: withCtx(() => [
      _hoisted_1$n
    ]),
    _: 1
  }, 16);
}
var ArrowDownIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["render", _sfc_render$q]]);
const _sfc_main$p = {
  name: "DesignThemeIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$m = /* @__PURE__ */ createElementVNode("path", {
  d: "M14.625,31.275c2.67-1.05,2.085-3.945.735-5.775a18.389,18.389,0,0,0-5.04-4.41A14.726,14.726,0,0,1,6.81,18c-.42-.5-1.275-1.41-.405-1.59.885-.18,2.415.69,3.195,1.02a28.213,28.213,0,0,1,3.975,2.01l1.515-2.55a21.2,21.2,0,0,0-8.13-3.315c-1.59-.24-3.27.09-3.81,1.815-.48,1.485.285,2.985,1.155,4.155C6.36,22.29,9.555,23.61,11.94,25.98a6.074,6.074,0,0,1,1.425,1.77c.315.66.24.7-.465.7-1.86,0-4.185-1.455-5.7-2.415L5.685,28.59c2.3,1.41,6.135,3.615,8.94,2.685M31.26,7.875a.833.833,0,0,0,0-1.185L29.31,4.74a.843.843,0,0,0-1.17,0L26.61,6.27l3.12,3.12M16.5,16.38V19.5h3.12l9.225-9.225-3.12-3.12Z",
  transform: "translate(-3.002 -4.504)"
}, null, -1);
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 28.506 26.993" }), {
    default: withCtx(() => [
      _hoisted_1$m
    ]),
    _: 1
  }, 16);
}
var DesignThemeIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["render", _sfc_render$p]]);
const _sfc_main$o = {
  name: "GoogleSheetsIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$l = /* @__PURE__ */ createElementVNode("g", null, [
  /* @__PURE__ */ createElementVNode("path", {
    d: "M21,6l-6-6H5C3.8954306,0,3,0.8954305,3,2v20c0,1.1045704,0.8954306,2,2,2h14c1.1045704,0,2-0.8954296,2-2   V6z",
    fill: "#19B870"
  }),
  /* @__PURE__ */ createElementVNode("linearGradient", {
    id: "SVGID_1_",
    gradientUnits: "userSpaceOnUse",
    x1: "16.80896",
    x2: "22.2063599",
    y1: "4.2216797",
    y2: "9.6190796"
  }, [
    /* @__PURE__ */ createElementVNode("stop", {
      offset: "0",
      style: { "stop-color": "#000000", "stop-opacity": "0.1" }
    }),
    /* @__PURE__ */ createElementVNode("stop", {
      offset: "1",
      style: { "stop-color": "#000000", "stop-opacity": "0" }
    })
  ]),
  /* @__PURE__ */ createElementVNode("path", {
    d: "M17,6c-0.5444336,0-1.0367432-0.2190552-1.3973999-0.5719604L21,10.8254395V6H17z",
    fill: "url(#SVGID_1_)"
  }),
  /* @__PURE__ */ createElementVNode("path", {
    d: "M19,23.75H5c-1.1045532,0-2-0.8954468-2-2V22c0,1.1045532,0.8954468,2,2,2h14c1.1045532,0,2-0.8954468,2-2   v-0.25C21,22.8545532,20.1045532,23.75,19,23.75z",
    opacity: "0.1"
  }),
  /* @__PURE__ */ createElementVNode("path", {
    d: "M15,0v4c0,1.1045694,0.8954306,2,2,2h4L15,0z",
    fill: "#80D8B0"
  }),
  /* @__PURE__ */ createElementVNode("path", {
    d: "M17,5.75c-1.1045532,0-2-0.8954468-2-2V4c0,1.1045532,0.8954468,2,2,2h4l-0.25-0.25H17z",
    opacity: "0.1"
  }),
  /* @__PURE__ */ createElementVNode("path", {
    d: "M15,0H5C3.8954468,0,3,0.8953857,3,2v0.25c0-1.1046143,0.8954468-2,2-2h10",
    fill: "#FFFFFF",
    opacity: "0.2"
  }),
  /* @__PURE__ */ createElementVNode("path", {
    d: "M7,9v10h10V9H7z M16,12h-3.5v-2H16V12z M12.5,13H16v2h-3.5V13z M11.5,15H8v-2h3.5V15z M11.5,10v2H8v-2H11.5   z M8,16h3.5v2H8V16z M12.5,18v-2H16v2H12.5z",
    fill: "#FFFFFF"
  }),
  /* @__PURE__ */ createElementVNode("linearGradient", {
    id: "SVGID_2_",
    gradientUnits: "userSpaceOnUse",
    x1: "0.2100637",
    x2: "22.9961185",
    y1: "7.5385189",
    y2: "18.1638298"
  }, [
    /* @__PURE__ */ createElementVNode("stop", {
      offset: "0",
      style: { "stop-color": "#FFFFFF", "stop-opacity": "0.2" }
    }),
    /* @__PURE__ */ createElementVNode("stop", {
      offset: "1",
      style: { "stop-color": "#FFFFFF", "stop-opacity": "0" }
    })
  ]),
  /* @__PURE__ */ createElementVNode("path", {
    d: "M21,6l-6-6H5C3.8954306,0,3,0.8954305,3,2v20c0,1.1045704,0.8954306,2,2,2h14   c1.1045704,0,2-0.8954296,2-2V6z",
    fill: "url(#SVGID_2_)"
  })
], -1);
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 24 24" }), {
    default: withCtx(() => [
      _hoisted_1$l
    ]),
    _: 1
  }, 16);
}
var GoogleSheetsIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["render", _sfc_render$o]]);
const _sfc_main$n = {
  name: "PreviewIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$k = /* @__PURE__ */ createElementVNode("path", {
  "fill-rule": "evenodd",
  d: "M16,8S13,2.5,8,2.5,0,8,0,8s3,5.5,8,5.5S16,8,16,8ZM1.173,8a13.134,13.134,0,0,0,1.66,2.043A7.451,7.451,0,0,0,8,12.5a7.457,7.457,0,0,0,5.168-2.457A13.134,13.134,0,0,0,14.828,8a13.133,13.133,0,0,0-1.66-2.043A7.459,7.459,0,0,0,8,3.5,7.457,7.457,0,0,0,2.832,5.957,13.133,13.133,0,0,0,1.172,8Z",
  transform: "translate(0 -2.5)"
}, null, -1);
const _hoisted_2$b = /* @__PURE__ */ createElementVNode("path", {
  "fill-rule": "evenodd",
  d: "M8,5.5A2.5,2.5,0,1,0,10.5,8,2.5,2.5,0,0,0,8,5.5ZM4.5,8A3.5,3.5,0,1,1,8,11.5,3.5,3.5,0,0,1,4.5,8Z",
  transform: "translate(0 -2.5)"
}, null, -1);
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 16 11" }), {
    default: withCtx(() => [
      _hoisted_1$k,
      _hoisted_2$b
    ]),
    _: 1
  }, 16);
}
var PreviewIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["render", _sfc_render$n]]);
const _sfc_main$m = {
  name: "PlusIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$j = /* @__PURE__ */ createElementVNode("g", {
  id: "add",
  transform: "translate(1.128 1.13)"
}, [
  /* @__PURE__ */ createElementVNode("path", {
    d: "M0,0v11.46",
    transform: "translate(5.725)",
    fill: "none",
    stroke: "#fff",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-miterlimit": "10",
    "stroke-width": "2.25"
  }),
  /* @__PURE__ */ createElementVNode("path", {
    d: "M11.447,0H0",
    transform: "translate(0 5.725)",
    fill: "none",
    stroke: "#fff",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-miterlimit": "10",
    "stroke-width": "2.25"
  })
], -1);
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 13.7 13.71" }), {
    default: withCtx(() => [
      _hoisted_1$j
    ]),
    _: 1
  }, 16);
}
var PlusIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["render", _sfc_render$m]]);
const _sfc_main$l = {
  name: "SortIcon",
  components: {
    IconBase
  },
  props: iconProps
};
const _hoisted_1$i = /* @__PURE__ */ createElementVNode("path", {
  d: "M3.166,8.809a.521.521,0,0,1-.374-.156L.157,6.019a.522.522,0,0,1-.115-.578.524.524,0,0,1,.491-.329H5.8a.532.532,0,0,1,.376.907L3.542,8.653A.528.528,0,0,1,3.166,8.809ZM5.8,3.7H.533a.524.524,0,0,1-.491-.329.522.522,0,0,1,.115-.578L2.792.156A.521.521,0,0,1,3.166,0a.528.528,0,0,1,.376.156L6.175,2.789A.532.532,0,0,1,5.8,3.7Z",
  transform: "translate(0 0)",
  fill: "currentColor"
}, null, -1);
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_base = resolveComponent("icon-base");
  return openBlock(), createBlock(_component_icon_base, mergeProps(_ctx.$props, { viewBox: "0 0 6.332 8.809" }), {
    default: withCtx(() => [
      _hoisted_1$i
    ]),
    _: 1
  }, 16);
}
var SortIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["render", _sfc_render$l]]);
var ChoiceButton_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$k = {
  name: "ChoiceButton",
  components: {
    CheckCircleIcon: render$a
  },
  props: {
    checked: { type: Boolean, default: false }
  },
  emits: ["click"]
};
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CheckCircleIcon = resolveComponent("CheckCircleIcon");
  return openBlock(), createElementBlock("button", {
    class: normalizeClass(["choice p-4 font-semibold transition-all duration-300 flex justify-between items-center", $props.checked ? ["checked"] : []]),
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true),
    withDirectives(createVNode(_component_CheckCircleIcon, { class: "h-4 fill-green" }, null, 512), [
      [vShow, $props.checked]
    ])
  ], 2);
}
var ChoiceButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["render", _sfc_render$k], ["__scopeId", "data-v-41fd7ef9"]]);
const _sfc_main$j = {
  name: "MultipleChoice",
  components: {
    ChoiceButton
  },
  directives: {
    clickOutside: vClickOutside.directive
  },
  props: {
    properties: { type: Object, required: true },
    initValue: { type: Array, default: () => [] }
  },
  emits: ["update:answer", "update:value"],
  data: function() {
    return {
      checked: (this.initValue || []).map((a2) => a2.id),
      otherValue: "",
      editOther: false
    };
  },
  computed: {
    choices: function() {
      return this.properties.randomize ? shuffle(this.properties.choices) : this.properties.choices;
    }
  },
  watch: {
    checked: {
      deep: true,
      handler: "saveValue"
    },
    otherValue: {
      handler: "saveValue"
    }
  },
  methods: {
    toggleChoice: function(choiceId) {
      this.$data.checked = this.$data.checked.indexOf(choiceId) !== -1 ? this.$data.checked.filter((c2) => c2 !== choiceId) : [...this.$data.checked, choiceId];
    },
    handleClickChoice: function(choiceId) {
      this.toggleChoice(choiceId);
      if (!this.properties.allow_multiple_selection) {
        this.sendAnswer();
      }
    },
    handleClickOther: function() {
      const isChecked = this.$data.checked.indexOf("other") !== -1;
      if (this.editOther && isChecked) {
        return;
      }
      if (!isChecked) {
        this.editOther = true;
        setTimeout(() => this.$refs.other.focus(), 100);
      }
      this.toggleChoice("other");
    },
    stopEditingOther: function() {
      this.editOther = false;
      this.$refs.other.blur();
    },
    handleChangeOther: function(e2) {
      this.otherValue = e2.target.value;
    },
    saveValue: function() {
      this.$emit("update:value", this.getAnswers());
    },
    sendAnswer: function() {
      this.$emit("update:answer", this.getAnswers());
    },
    getAnswers: function() {
      return this.$data.checked.map(
        (id) => id === "other" ? { id: "other", value: this.$data.otherValue } : { id, value: this.choices.find((c2) => c2.id === id).label }
      );
    }
  }
};
const _hoisted_1$h = { class: "flex flex-wrap" };
const _hoisted_2$a = {
  key: 0,
  class: "even:pl-2 odd:pr-2 w-1/2 pb-4"
};
const _hoisted_3$9 = ["disabled", "value"];
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ChoiceButton = resolveComponent("ChoiceButton");
  const _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createElementBlock("div", null, [
    createElementVNode("div", _hoisted_1$h, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.choices, (choice) => {
        return openBlock(), createElementBlock("div", {
          key: choice.id,
          class: "even:pl-2 odd:pr-2 w-1/2 pb-4"
        }, [
          createVNode(_component_ChoiceButton, {
            checked: _ctx.checked.indexOf(choice.id) !== -1,
            class: "w-full",
            onClick: ($event) => $options.handleClickChoice(choice.id)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(choice.label), 1)
            ]),
            _: 2
          }, 1032, ["checked", "onClick"])
        ]);
      }), 128)),
      $props.properties.allow_other_choice ? (openBlock(), createElementBlock("div", _hoisted_2$a, [
        withDirectives((openBlock(), createBlock(_component_ChoiceButton, {
          checked: _ctx.checked.indexOf("other") !== -1,
          class: "w-full",
          onClick: $options.handleClickOther
        }, {
          default: withCtx(() => [
            createElementVNode("input", {
              ref: "other",
              type: "text",
              disabled: !_ctx.editOther,
              class: normalizeClass(["w-full text-left h-6 bg-transparent focus:border-0 border-0 focus:ring-0 outline-none focus:outline-none shadow-none", { "pointer-events-none": !_ctx.editOther }]),
              placeholder: "Enter you answer",
              value: _ctx.otherValue || (_ctx.editOther ? "" : "other"),
              onInput: _cache[0] || (_cache[0] = (...args) => $options.handleChangeOther && $options.handleChangeOther(...args))
            }, null, 42, _hoisted_3$9)
          ]),
          _: 1
        }, 8, ["checked", "onClick"])), [
          [_directive_click_outside, $options.stopEditingOther]
        ])
      ])) : createCommentVNode("", true)
    ])
  ]);
}
var MultipleChoice = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["render", _sfc_render$j]]);
var YesNo_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$i = {
  name: "YesNo",
  components: {
    ChoiceButton
  },
  props: {
    properties: { type: Object, required: true },
    withConfirmation: { type: Boolean, default: false },
    initValue: { type: Object, default: () => [] }
  },
  emits: ["update:answer", "update:value"],
  data: function() {
    var _a;
    return {
      checked: this.initValue && ((_a = this.initValue[0]) == null ? void 0 : _a.id),
      otherValue: "",
      editOther: false
    };
  },
  computed: {
    choices: function() {
      return this.properties.choices;
    }
  },
  methods: {
    toggleChoice: function(choiceId) {
      this.$data.checked = this.$data.checked === choiceId ? null : choiceId;
    },
    handleClickChoice: function(choiceId) {
      this.toggleChoice(choiceId);
      this.$emit(
        this.withConfirmation && choiceId === this.choices[0].id ? "update:value" : "update:answer",
        [{ id: this.$data.checked, value: this.choices.find((c2) => c2.id === this.$data.checked).label }]
      );
    }
  }
};
const _hoisted_1$g = { class: "flex md:gap-4 flex-wrap" };
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ChoiceButton = resolveComponent("ChoiceButton");
  return openBlock(), createElementBlock("div", null, [
    createElementVNode("div", _hoisted_1$g, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($options.choices, (choice) => {
        return openBlock(), createElementBlock("div", {
          key: choice.id,
          class: "even:pl-2 odd:pr-2 w-1/2 pb-4 md:pr-0 md:w-auto"
        }, [
          createVNode(_component_ChoiceButton, {
            checked: _ctx.checked === choice.id,
            class: "w-full choice",
            onClick: ($event) => $options.handleClickChoice(choice.id)
          }, {
            default: withCtx(() => [
              createElementVNode("span", null, toDisplayString(choice.label), 1)
            ]),
            _: 2
          }, 1032, ["checked", "onClick"])
        ]);
      }), 128))
    ])
  ]);
}
var YesNo = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["render", _sfc_render$i], ["__scopeId", "data-v-9f4b6f9a"]]);
var Open_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$h = {
  name: "Open",
  props: {
    properties: { type: Object, required: true },
    initValue: { type: Array, default: () => [] }
  },
  emits: ["update:value"],
  data: function() {
    return { answer: this.initValue[0] && this.initValue[0].value || "" };
  },
  methods: {
    handleChangeAnswer: function(e2) {
      this.$emit("update:value", [{ value: e2.target.innerText }]);
    }
  }
};
const _hoisted_1$f = ["placeholder"];
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    createElementVNode("div", {
      class: "border-b-2 border-red-700 text-2xl leading-8 py-3 text-input",
      contenteditable: "true",
      placeholder: $props.properties.placeholder,
      onInput: _cache[0] || (_cache[0] = (...args) => $options.handleChangeAnswer && $options.handleChangeAnswer(...args))
    }, toDisplayString(_ctx.answer), 41, _hoisted_1$f)
  ]);
}
var Open = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["render", _sfc_render$h], ["__scopeId", "data-v-c288c81a"]]);
var RatingScore_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$g = {
  name: "RatingScore",
  components: {
    StarIcon: render$1,
    PlusIcon: render$f,
    MinusIcon: render$g
  },
  props: {
    properties: { type: Object, required: true },
    initValue: { type: Array, default: () => [] },
    isMobile: { type: Boolean, default: false }
  },
  emits: ["update:value"],
  data: function() {
    var _a;
    return {
      score: this.initValue && ((_a = this.initValue[0]) == null ? void 0 : _a.value),
      hoverScore: 0
    };
  },
  computed: {
    amountOfRatingBlocks: function() {
      return this.properties.to - this.properties.from + 1;
    }
  },
  watch: {
    score: function() {
      this.$emit("update:value", [{ value: this.score }]);
    }
  },
  methods: {
    handleIncrementScore: function(incrementedValue) {
      let newScore = this.score + incrementedValue;
      if (newScore < this.properties.from) {
        newScore = this.properties.from;
      }
      if (newScore > this.properties.to) {
        newScore = this.properties.to;
      }
      this.score = newScore;
    },
    handleSetScore: function(newScore) {
      this.score = newScore;
    },
    handleHoverRating: function(i2) {
      this.hoverScore = i2;
    }
  }
};
const _hoisted_1$e = { class: "relative w-full stars-block" };
const _hoisted_2$9 = { class: "flex gap-2 sm:gap-4" };
const _hoisted_3$8 = { class: "absolute left-0 top-0 bottom-0 right-0" };
const _hoisted_4$6 = { class: "rating-overlay flex gap-2 sm:gap-4" };
const _hoisted_5$6 = ["onMouseenter", "onClick"];
const _hoisted_6$5 = ["onMouseenter", "onClick"];
const _hoisted_7$4 = { class: "flex gap-2 increment-buttons" };
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_MinusIcon = resolveComponent("MinusIcon");
  const _component_StarIcon = resolveComponent("StarIcon");
  const _component_PlusIcon = resolveComponent("PlusIcon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["flex flex-col lg:flex-row gap-4 mx-auto lg:mx-0 lg:items-start question", [$props.isMobile ? `width-mobile` : ""]])
  }, [
    createElementVNode("div", {
      class: "increment-button hidden lg:flex items-center justify-center",
      onClick: _cache[0] || (_cache[0] = ($event) => $options.handleIncrementScore(-0.5))
    }, [
      createVNode(_component_MinusIcon, { class: "increment-button-icon" })
    ]),
    createElementVNode("div", _hoisted_1$e, [
      createElementVNode("div", _hoisted_2$9, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.amountOfRatingBlocks, (i2) => {
          return openBlock(), createElementBlock("div", {
            key: `rating-score-star${i2}`,
            class: "rating-button relative"
          }, [
            createVNode(_component_StarIcon, { class: "absolute rating-button-star" })
          ]);
        }), 128))
      ]),
      createElementVNode("div", _hoisted_3$8, [
        createElementVNode("div", _hoisted_4$6, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.amountOfRatingBlocks, (i2) => {
            return openBlock(), createElementBlock("div", {
              key: `rating-overlay-score-star${i2}`,
              class: "rating-overlay-star-container flex"
            }, [
              createElementVNode("div", {
                class: normalizeClass([[_ctx.score >= i2 - 0.5 && "show", _ctx.hoverScore >= i2 - 0.5 && "show-new-rating"], "rating-button overflow-hidden"]),
                onMouseenter: ($event) => $options.handleHoverRating(i2 - 0.5),
                onClick: ($event) => $options.handleSetScore(i2 - 0.5)
              }, [
                createVNode(_component_StarIcon, { class: "rating-button-star" })
              ], 42, _hoisted_5$6),
              createElementVNode("div", {
                class: normalizeClass(["rating-button overflow-hidden", [_ctx.score >= i2 && "show", _ctx.hoverScore >= i2 && "show-new-rating"]]),
                onMouseenter: ($event) => $options.handleHoverRating(i2),
                onClick: ($event) => $options.handleSetScore(i2)
              }, [
                createVNode(_component_StarIcon, { class: "rating-button-star" })
              ], 42, _hoisted_6$5)
            ]);
          }), 128))
        ])
      ])
    ]),
    createElementVNode("div", _hoisted_7$4, [
      createElementVNode("div", {
        class: "increment-button lg:hidden flex items-center justify-center",
        onClick: _cache[1] || (_cache[1] = ($event) => $options.handleIncrementScore(-0.5))
      }, [
        createVNode(_component_MinusIcon, { class: "increment-button-icon mx-auto" })
      ]),
      createElementVNode("div", {
        class: "increment-button flex items-center justify-center",
        onClick: _cache[2] || (_cache[2] = ($event) => $options.handleIncrementScore(0.5))
      }, [
        createVNode(_component_PlusIcon, { class: "increment-button-icon mx-auto" })
      ])
    ])
  ], 2);
}
var RatingScore = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["render", _sfc_render$g], ["__scopeId", "data-v-539bb0ce"]]);
var TimeDelay_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$f = {
  name: "TimeDelay",
  components: { ChevronDownIcon: render$6 },
  directives: {
    clickOutside: vClickOutside.directive
  },
  props: {
    properties: { type: Object, required: true },
    initValue: { type: Array, default: () => [] }
  },
  emits: ["update:answer", "update:error", "update:value"],
  data: function() {
    var _a, _b;
    return {
      delay: ((_a = this.initValue[0]) == null ? void 0 : _a.value) || "",
      period: ((_b = this.initValue[1]) == null ? void 0 : _b.value) || this.properties.period[0],
      periodSelection: false,
      error: false
    };
  },
  computed: {
    periodsForSelector: function() {
      return this.properties.period.filter((p2) => p2 !== this.period);
    }
  },
  methods: {
    handleChangeDelay: function(e2) {
      const newDelay = parseInt(e2.target.value.replace(/[^0-9.]/g, ""));
      if (this.properties.restrict_delay) {
        let newDelayInDays = newDelay;
        if (this.period !== "days") {
          newDelayInDays = this.period === "weeks" ? newDelay * 7 : newDelay * 30;
        }
        this.$emit("update:error", newDelayInDays > this.properties.max_delay ? "Maximum delay value can be " + this.properties.max_delay + " days" : null);
      }
      this.$emit("update:value", [{ value: newDelay }, { value: this.period }]);
      this.delay = newDelay;
    },
    handleClickPeriodSelector() {
      this.periodSelection = !this.periodSelection;
    },
    hidePeriodSelection() {
      this.periodSelection = false;
    },
    handleChangePeriod: function(p2) {
      this.hidePeriodSelection();
      this.period = p2;
    }
  }
};
const _hoisted_1$d = { class: "flex gap-2 items-center" };
const _hoisted_2$8 = { class: "absolute left-0 top-full bg-white right-0" };
const _hoisted_3$7 = ["onClick"];
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ChevronDownIcon = resolveComponent("ChevronDownIcon");
  const _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createElementBlock("div", null, [
    createElementVNode("div", _hoisted_1$d, [
      createElementVNode("div", null, [
        withDirectives(createElementVNode("input", {
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.delay = $event),
          type: "number",
          min: "0",
          class: "time-delay-input focus:outline-none focus:ring-0 px-0",
          placeholder: "7",
          style: normalizeStyle({ width: (("" + _ctx.delay).length || 1) * 18 + "px" }),
          onInput: _cache[1] || (_cache[1] = (...args) => $options.handleChangeDelay && $options.handleChangeDelay(...args))
        }, null, 36), [
          [vModelText, _ctx.delay]
        ])
      ]),
      withDirectives((openBlock(), createElementBlock("div", {
        class: normalizeClass(["time-delay-period relative", $props.properties.period.length > 1 ? ["cursor-pointer"] : []])
      }, [
        createElementVNode("div", {
          class: "flex items-center gap-1",
          onClick: _cache[2] || (_cache[2] = (...args) => $options.handleClickPeriodSelector && $options.handleClickPeriodSelector(...args))
        }, [
          createElementVNode("div", null, toDisplayString(_ctx.period), 1),
          $props.properties.period.length > 1 ? (openBlock(), createBlock(_component_ChevronDownIcon, {
            key: 0,
            class: "h-6"
          })) : createCommentVNode("", true)
        ]),
        withDirectives(createElementVNode("div", _hoisted_2$8, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.periodsForSelector, (p2) => {
            return openBlock(), createElementBlock("div", {
              key: `time-delay-period-selector=${p2}`,
              class: "hover:text-gray-700",
              onClick: ($event) => $options.handleChangePeriod(p2)
            }, toDisplayString(p2), 9, _hoisted_3$7);
          }), 128))
        ], 512), [
          [vShow, _ctx.periodSelection]
        ])
      ], 2)), [
        [_directive_click_outside, $options.hidePeriodSelection]
      ])
    ])
  ]);
}
var TimeDelay = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["render", _sfc_render$f], ["__scopeId", "data-v-04776b71"]]);
const _sfc_main$e = {
  name: "PurchasedItemsChoice",
  components: { MultipleChoice },
  props: {
    withConfirmation: { type: Boolean, default: false },
    orderItems: { type: Array, required: true },
    initValue: { type: Array, default: () => [] },
    properties: { type: Object, default: () => ({}) }
  },
  computed: {
    items: function() {
      return this.orderItems.map((i2) => ({ ...i2, id: i2.external_product_id, label: i2.name }));
    }
  }
};
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_MultipleChoice = resolveComponent("MultipleChoice");
  return openBlock(), createBlock(_component_MultipleChoice, {
    properties: { choices: $options.items, allow_multiple_selection: true },
    "init-value": $props.initValue
  }, null, 8, ["properties", "init-value"]);
}
var PurchasedItemsChoice = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["render", _sfc_render$e]]);
function mergeTags(string, tags) {
  return string && string.replace(/{{ .+? }}/g, (match) => {
    return tags[match.replace(/[{} ]/g, "")] || "";
  });
}
function recallInfo(string, answers) {
  return string && string.replace(/\[Recall info = answer to [K|F]OQ-(\d+)\]|{{.+?}}/g, (match, questionIndex) => {
    var _a, _b;
    let indexIncrementor = 0;
    return ((_b = (_a = answers.filter((a2) => {
      if (validate(a2.questionId)) {
        return true;
      }
      indexIncrementor++;
      return false;
    }).filter((a2) => a2.index - indexIncrementor + 1 === parseInt(questionIndex)).slice(-1)[0]) == null ? void 0 : _a.answers) == null ? void 0 : _b.map((a2) => a2.value).join(" ")) || "";
  });
}
var forms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  mergeTags,
  recallInfo
}, Symbol.toStringTag, { value: "Module" }));
var ErrorMessage_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$d = {
  name: "ErrorMessage"
};
const _hoisted_1$c = { class: "error-message py-3 text-xl" };
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$c, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ]);
}
var ErrorMessage = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["render", _sfc_render$d], ["__scopeId", "data-v-2b9f9dbb"]]);
const _sfc_main$c = {
  name: "UploadFiles",
  components: { TrashIcon, AddMediaIcon },
  props: {
    initValue: { type: Array, default: () => [] }
  },
  emits: ["upload:file", "update:value"],
  data: function() {
    return {
      error: null,
      files: this.initValue.map((a2) => a2.value)
    };
  },
  mounted() {
    this.$emit("update:value", [{}]);
  },
  methods: {
    handleUploadFile: function(e2) {
      this.$emit(
        "upload:file",
        {
          files: e2.target.files,
          cb: function(files, error) {
            if (error) {
              this.error = error;
            }
            this.files = [...this.files, ...files];
            this.$emit("update:value", this.files.map((value) => ({ value })));
          }.bind(this)
        }
      );
    },
    handleClickDelete: function(file) {
      this.files = this.files.filter((f2) => f2 !== file);
      this.$emit("update:value", this.files.map((value) => ({ value })));
    }
  }
};
const _hoisted_1$b = { class: "pt-2" };
const _hoisted_2$7 = { class: "block border-2 border-dashed border-gray-400 p-5 rounded-2xl text-center cursor-pointer relative z-10" };
const _hoisted_3$6 = /* @__PURE__ */ createElementVNode("div", { class: "text-gray-600 font-semibold pt-3" }, " Drop your images or video file here, or click to browse (max. 35MB) ", -1);
const _hoisted_4$5 = /* @__PURE__ */ createElementVNode("div", { class: "text-gray-400 text-md" }, " Supports JPEG, PNG, MP4, and MOV ", -1);
const _hoisted_5$5 = {
  key: 0,
  class: "mt-4 border border-gray-300 rounded"
};
const _hoisted_6$4 = { class: "w-full" };
const _hoisted_7$3 = { class: "flex justify-between" };
const _hoisted_8$2 = { class: "font-semibold" };
const _hoisted_9$1 = /* @__PURE__ */ createElementVNode("div", { class: "text-gray-500 text-xs" }, " Uploaded ", -1);
const _hoisted_10$1 = /* @__PURE__ */ createElementVNode("div", { class: "bg-red-600 h-2 rounded-2xl mt-1" }, null, -1);
const _hoisted_11$1 = { class: "bg-gray-200 rounded px-2 py-1" };
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AddMediaIcon = resolveComponent("AddMediaIcon");
  const _component_TrashIcon = resolveComponent("TrashIcon");
  return openBlock(), createElementBlock("div", _hoisted_1$b, [
    createElementVNode("label", _hoisted_2$7, [
      createVNode(_component_AddMediaIcon, {
        "icon-color": "#ccc",
        height: "25",
        width: "32"
      }),
      _hoisted_3$6,
      _hoisted_4$5,
      createElementVNode("input", {
        type: "file",
        class: "opacity-0 absolute z-10 top-0 left-0 right-0 bottom-0",
        accept: "image/*, video/*",
        multiple: "",
        onChange: _cache[0] || (_cache[0] = (...args) => $options.handleUploadFile && $options.handleUploadFile(...args))
      }, null, 32)
    ]),
    _ctx.files.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_5$5, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.files, (file) => {
        return openBlock(), createElementBlock("div", {
          key: `file-upload-${file}`,
          class: "px-3 py-2 flex gap-4 border-b last:border-0 text-sm"
        }, [
          createElementVNode("div", _hoisted_6$4, [
            createElementVNode("div", _hoisted_7$3, [
              createElementVNode("div", _hoisted_8$2, toDisplayString(file.slice(file.lastIndexOf("/") + 1)), 1),
              _hoisted_9$1
            ]),
            _hoisted_10$1
          ]),
          createElementVNode("div", _hoisted_11$1, [
            createVNode(_component_TrashIcon, {
              "icon-color": "#888",
              height: "16",
              width: "13",
              onClick: ($event) => $options.handleClickDelete(file)
            }, null, 8, ["onClick"])
          ])
        ]);
      }), 128))
    ])) : createCommentVNode("", true)
  ]);
}
var UploadFiles = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["render", _sfc_render$c]]);
var Question_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$b = {
  components: { ErrorMessage, PhotographIcon: render$3 },
  props: {
    question: { type: Object, required: true },
    tags: { type: Object, default: () => ({}) },
    formProgress: { type: Array, required: true },
    formCategory: { type: String, required: true },
    orderItems: { type: Array, default: () => [] },
    theme: { type: Object, default: () => ({}) },
    orderItem: { type: Object, default: void 0 },
    isMobile: { type: Boolean, default: false },
    isLastQuestion: { type: Boolean, default: false }
  },
  emits: ["update:answer", "clickBack", "upload:file"],
  data: function() {
    return {
      error: null,
      value: null
    };
  },
  computed: {
    showBack: function() {
      return this.question.index !== 0 && this.question.category !== QUESTION_CATEGORY_TYP;
    },
    componentQuestionTypeMap: function() {
      return {
        [QUESTION_TYPE_MULTIPLE_CHOICE]: MultipleChoice,
        [QUESTION_TYPE_YES_NO]: YesNo,
        [QUESTION_TYPE_OPEN]: Open,
        [QUESTION_TYPE_RATING_SCORE]: RatingScore,
        [QUESTION_TYPE_DELAY]: TimeDelay,
        [QUESTION_TYPE_PURCHASED_ITEMS_CHOICE]: PurchasedItemsChoice,
        [QUESTION_TYPE_UPLOAD_FILES]: UploadFiles
      }[this.question.type] || null;
    },
    title: function() {
      return recallInfo(mergeTags(this.question.title, this.tags), this.formProgress);
    },
    description: function() {
      return recallInfo(mergeTags(this.question.description, this.tags), this.formProgress);
    },
    withConfirmation: function() {
      return this.question.category === QUESTION_CATEGORY_KICK_OFF && this.formCategory === FORM_CATEGORY_PRE_REVIEW;
    },
    initValue: function() {
      var _a;
      return ((_a = this.formProgress.find((a2) => {
        var _a2;
        return (a2.orderItem ? a2.orderItem === ((_a2 = this.orderItem) == null ? void 0 : _a2.external_product_id) : true) && a2.questionId === this.question.id;
      })) == null ? void 0 : _a.answers) || [];
    },
    nextButtonText: function() {
      return this.isLastQuestion ? "Submit my answers" : "Next question";
    }
  },
  mounted() {
    var _a;
    const storedValue = (_a = this.formProgress.find((a2) => a2.questionId === this.question.id)) == null ? void 0 : _a.answers;
    storedValue && (this.value = storedValue);
  },
  methods: {
    handleError: function(errorMessage) {
      this.error = errorMessage;
    },
    handleUpdateValue: function(value) {
      this.value = value;
    },
    sendAnswer: function() {
      if (!this.value) {
        return;
      }
      this.$emit("update:answer", this.value);
    }
  }
};
const _hoisted_1$a = { class: "w-full" };
const _hoisted_2$6 = {
  key: 1,
  class: "flex"
};
const _hoisted_3$5 = { class: "max-w-md w-full rounded overflow-hidden bg-gray-400 media-container relative" };
const _hoisted_4$4 = { class: "absolute flex left-0 right-0 bottom-0 top-0 items-center justify-center z-0" };
const _hoisted_5$4 = ["src"];
const _hoisted_6$3 = { class: "py-4" };
const _hoisted_7$2 = { class: "pt-7 flex gap-6" };
const _hoisted_8$1 = ["disabled"];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c, _d, _e2;
  const _component_PhotographIcon = resolveComponent("PhotographIcon");
  const _component_ErrorMessage = resolveComponent("ErrorMessage");
  return openBlock(), createElementBlock("div", _hoisted_1$a, [
    createElementVNode("div", {
      class: "title",
      style: normalizeStyle({ color: (_a = $props.theme) == null ? void 0 : _a.questions })
    }, toDisplayString($options.title), 5),
    $options.description ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "description pb-2",
      style: normalizeStyle({ color: (_b = $props.theme) == null ? void 0 : _b.descriptions })
    }, toDisplayString($options.description), 5)) : createCommentVNode("", true),
    $props.question.attachments && $props.question.attachments.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_2$6, [
      createElementVNode("div", _hoisted_3$5, [
        createElementVNode("div", _hoisted_4$4, [
          createVNode(_component_PhotographIcon, { class: "h-12 w-12 text-white" })
        ]),
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.question.attachments, (a2) => {
          return openBlock(), createElementBlock("img", {
            key: a2.src,
            class: "w-full z-10 relative",
            src: `/storage/${a2.src}`,
            alt: ""
          }, null, 8, _hoisted_5$4);
        }), 128))
      ])
    ])) : createCommentVNode("", true),
    createElementVNode("div", _hoisted_6$3, [
      (openBlock(), createBlock(resolveDynamicComponent($options.componentQuestionTypeMap), {
        key: $props.question.id + ($props.orderItem || ""),
        properties: $props.question.properties,
        "with-confirmation": $options.withConfirmation,
        "question-category": $props.question.category,
        "order-items": $props.orderItems,
        "init-value": $options.initValue,
        "is-mobile": $props.isMobile,
        "onUpdate:answer": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:answer", $event)),
        "onUpdate:error": $options.handleError,
        "onUpdate:value": $options.handleUpdateValue,
        "onUpload:file": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("upload:file", $event))
      }, null, 40, ["properties", "with-confirmation", "question-category", "order-items", "init-value", "is-mobile", "onUpdate:error", "onUpdate:value"])),
      _ctx.error ? (openBlock(), createBlock(_component_ErrorMessage, { key: 0 }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.error), 1)
        ]),
        _: 1
      })) : createCommentVNode("", true),
      createElementVNode("div", _hoisted_7$2, [
        _ctx.value && _ctx.value.length > 0 ? (openBlock(), createElementBlock("button", {
          key: 0,
          disabled: !!_ctx.error,
          class: "bg-buttonRed text-white rounded py-2.5 px-5 font-bold disabled:opacity-75",
          style: normalizeStyle({ background: (_c = $props.theme) == null ? void 0 : _c.buttons, color: (_d = $props.theme) == null ? void 0 : _d.button_text }),
          onClick: _cache[2] || (_cache[2] = (...args) => $options.sendAnswer && $options.sendAnswer(...args))
        }, toDisplayString($options.nextButtonText), 13, _hoisted_8$1)) : createCommentVNode("", true),
        $options.showBack ? (openBlock(), createElementBlock("button", {
          key: 1,
          class: "text-red-600 font-semibold",
          style: normalizeStyle({ color: (_e2 = $props.theme) == null ? void 0 : _e2.buttons }),
          onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("clickBack"))
        }, " Back ", 4)) : createCommentVNode("", true)
      ])
    ])
  ]);
}
var Question = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["render", _sfc_render$b], ["__scopeId", "data-v-1b3b278a"]]);
var PreviewQuestion_vue_vue_type_style_index_0_scoped_true_lang$1 = "";
const _sfc_main$a = {
  name: "PreviewQuestion",
  components: {
    Question
  },
  props: {
    question: { type: Object, default: null },
    formCategory: { type: String, required: true },
    mobilePreview: { type: Boolean, default: false }
  }
};
const _hoisted_1$9 = { class: "flex h-full" };
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Question = resolveComponent("Question");
  return openBlock(), createElementBlock("div", _hoisted_1$9, [
    withDirectives(createElementVNode("div", {
      class: normalizeClass(["left-side py-5 lg:py-16 px-4 h-full", { "w-1/2": !$props.mobilePreview }])
    }, null, 2), [
      [vShow, !$props.mobilePreview]
    ]),
    createElementVNode("div", {
      class: normalizeClass([[$props.mobilePreview ? "px-5 w-full" : "w-1/2 px-16"], "py-16 flex flex-col justify-center"])
    }, [
      createVNode(_component_Question, {
        question: $props.question,
        "form-progress": [],
        "form-category": $props.formCategory,
        "is-mobile": $props.mobilePreview
      }, null, 8, ["question", "form-category", "is-mobile"])
    ], 2)
  ]);
}
var PreviewQuestion$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["render", _sfc_render$a], ["__scopeId", "data-v-94e5a5bc"]]);
var FormProgress_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$9 = {
  name: "FormProgress",
  components: {
    ArrowNarrowRightIcon: render$m
  },
  props: {
    questions: { type: Array, required: true },
    currentQuestionId: { type: String, default: void 0 },
    tags: { type: Object, required: true }
  },
  computed: {
    indexOfCurrentQuestion: function() {
      return this.questions.findIndex((q) => q.id === this.currentQuestionId);
    }
  },
  methods: {
    mergeTags,
    recallInfo
  }
};
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ArrowNarrowRightIcon = resolveComponent("ArrowNarrowRightIcon");
  return openBlock(), createElementBlock("div", null, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.questions, (q, i2) => {
      return openBlock(), createElementBlock("div", {
        key: `form-progress-question-${q.id}`,
        class: normalizeClass(["question py-2 flex gap-3 items-center", [{ current: $options.indexOfCurrentQuestion === i2, passed: $options.indexOfCurrentQuestion > i2 }]])
      }, [
        createElementVNode("div", null, toDisplayString($options.recallInfo($options.mergeTags(q.title, $props.tags), [])), 1),
        $options.indexOfCurrentQuestion === i2 ? (openBlock(), createBlock(_component_ArrowNarrowRightIcon, {
          key: 0,
          class: "h-5"
        })) : createCommentVNode("", true)
      ], 2);
    }), 128))
  ]);
}
var FormProgress = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-2eb1017c"]]);
var LeftSide_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$8 = {
  name: "LeftSide",
  components: {
    FormProgress,
    ChevronUpIcon: render$5,
    ChevronDownIcon: render$6
  },
  props: {
    formName: { type: String, required: true },
    formCategory: { type: String, required: true },
    questions: { type: Array, default: () => [] },
    orderItem: { type: Object, default: null },
    currentQuestionId: { type: String, default: null },
    tags: { type: Object, required: true },
    isMobile: { type: Boolean, required: true }
  },
  data() {
    return {
      show: !this.isMobile
    };
  },
  computed: {
    indexOfCurrentQuestion: function() {
      return this.questions.findIndex((q) => q.id === this.currentQuestionId);
    }
  },
  watch: {
    isMobile: function() {
      this.show = !this.isMobile;
    }
  },
  methods: {
    toggle: function() {
      this.show = this.isMobile ? !this.show : true;
    }
  }
};
const _hoisted_1$8 = { key: "left-side-form-header" };
const _hoisted_2$5 = {
  key: 0,
  class: "form-pre-name text-center"
};
const _hoisted_3$4 = { class: "form-name" };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FormProgress = resolveComponent("FormProgress");
  const _component_ChevronDownIcon = resolveComponent("ChevronDownIcon");
  const _component_ChevronUpIcon = resolveComponent("ChevronUpIcon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["left-side flex flex-col items-center text-white h-10 px-4 overflow-y-auto", { "justify-between": $props.orderItem, "justify-center": !$props.orderItem, "py-16": $data.show, "h-full": $data.show, "lg:h-full py-5 lg:py-16": !$props.isMobile }]),
    onClick: _cache[0] || (_cache[0] = (...args) => $options.toggle && $options.toggle(...args))
  }, [
    createVNode(TransitionGroup, {
      "enter-active-class": "transition ease-out duration-300",
      "enter-from-class": "transform opacity-0 scale-50",
      "enter-to-class": "transform opacity-100 scale-100",
      "leave-active-class": "transition ease-in duration-150",
      "leave-from-class": "transform opacity-100 scale-100",
      "leave-to-class": "transform opacity-0 scale-50"
    }, {
      default: withCtx(() => [
        withDirectives(createElementVNode("div", _hoisted_1$8, [
          $props.orderItem ? (openBlock(), createElementBlock("div", _hoisted_2$5, " Review the ")) : createCommentVNode("", true),
          createElementVNode("div", _hoisted_3$4, toDisplayString($props.orderItem ? $props.orderItem.name : $props.formName), 1)
        ], 512), [
          [vShow, $data.show]
        ]),
        $props.orderItem && $data.show ? (openBlock(), createBlock(_component_FormProgress, {
          key: "left-side-form-progress",
          questions: $props.questions,
          "current-question-id": $props.currentQuestionId,
          tags: $props.tags
        }, null, 8, ["questions", "current-question-id", "tags"])) : createCommentVNode("", true)
      ]),
      _: 1
    }),
    createElementVNode("div", null, [
      $props.orderItem ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["text-center step font-medium absolute duration-300 left-0 right-0 lg:static", [$data.show ? "bottom-16" : "bottom-2"]])
      }, " Question " + toDisplayString($options.indexOfCurrentQuestion + 1) + " of " + toDisplayString($props.questions.length), 3)) : createCommentVNode("", true)
    ]),
    $props.isMobile ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["absolute right-2 duration-300", [$data.show ? "bottom-16" : "bottom-2"]])
    }, [
      $data.show ? (openBlock(), createBlock(_component_ChevronDownIcon, {
        key: 0,
        class: "h-8"
      })) : (openBlock(), createBlock(_component_ChevronUpIcon, {
        key: 1,
        class: "h-8"
      }))
    ], 2)) : createCommentVNode("", true)
  ], 2);
}
var LeftSide = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-22882994"]]);
var Form_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$7 = {
  components: {
    LeftSide,
    Question
  },
  props: {
    form: { type: Object, required: true },
    theme: { type: Object, default: () => ({}) },
    order: { type: Object, required: true },
    formProgress: { type: Array, required: true },
    chosenOrderItems: { type: Array, default: () => [] },
    isMobile: { type: Boolean, default: false },
    isPreview: { type: Boolean, default: false }
  },
  emits: ["update:progress", "update:orderItems", "update:goToForm", "uploadFile"],
  data: function() {
    return {
      currentQuestion: null,
      noQuestion: true
    };
  },
  computed: {
    formType: function() {
      return this.form.type;
    },
    formCategory: function() {
      return this.form.category;
    },
    tags: function() {
      return {
        ...this.order.data.customer,
        ...this.orderItem ? { product_name: this.orderItem.name } : {}
      };
    },
    orderItems: function() {
      return this.order.data.line_items;
    },
    kickOffsAndFollowUps: function() {
      return [
        ...this.form.data.kick_offs.map((q) => ({ ...q, category: QUESTION_CATEGORY_KICK_OFF })),
        ...this.form.data.follow_ups.map((q) => ({ ...q, category: QUESTION_CATEGORY_FOLLOW_UP }))
      ];
    },
    questions: function() {
      return [
        ...this.formType === FORM_TYPE_PRODUCT && this.formCategory === FORM_CATEGORY_REVIEW ? [PURCHASED_ITEMS_CHOICE_QUESTION] : [],
        ...this.chosenOrderItems.length > 0 ? this.chosenOrderItems.reduce((acc, i2) => [
          ...acc,
          ...this.kickOffsAndFollowUps.map((q) => ({ ...q, order_item_id: i2 })),
          ...this.form.data.allow_users_files ? [uploadFilesQuestion(i2)] : []
        ], []) : this.kickOffsAndFollowUps,
        ...this.form.data.typs.map((q) => ({ ...q, category: QUESTION_CATEGORY_TYP }))
      ].map((q, index2) => ({ ...q, index: index2 }));
    },
    answers: function() {
      return this.formProgress.map((a2) => {
        var _a;
        return { ...a2, index: (_a = this.questions.find((q) => q.id === a2.questionId)) == null ? void 0 : _a.index };
      });
    },
    orderItem: function() {
      var _a;
      return ((_a = this.currentQuestion) == null ? void 0 : _a.order_item_id) && this.orderItems.find((i2) => i2.external_product_id === this.currentQuestion.order_item_id);
    },
    isLastQuestion: function() {
      var _a;
      return ((_a = this.questions[this.currentQuestion.index + 1]) == null ? void 0 : _a.category) === QUESTION_CATEGORY_TYP;
    }
  },
  watch: {
    chosenOrderItems: {
      deep: true,
      handler: function() {
        if (this.currentQuestion) {
          this.setNextQuestion(this.formProgress);
        }
      }
    }
  },
  mounted() {
    if (this.formProgress && this.formProgress.length > 0) {
      this.setNextQuestion(this.formProgress);
    } else {
      this.currentQuestion = this.questions[0];
    }
    this.noQuestion = false;
  },
  methods: {
    handleAnswer: function(answers) {
      const currentAnswerIndex = this.formProgress.findIndex((a2) => a2.questionId === this.currentQuestion.id && (a2.orderItem ? this.orderItem.external_product_id === a2.orderItem : true));
      const answer = { questionId: this.currentQuestion.id, answers, ...this.orderItem ? { orderItem: this.orderItem.external_product_id } : {} };
      const formProgress = currentAnswerIndex === -1 ? [...this.formProgress, answer] : [...this.formProgress.slice(0, currentAnswerIndex), answer];
      this.$emit("update:progress", formProgress);
      if (this.currentQuestion.id === QUESTION_TYPE_PURCHASED_ITEMS_CHOICE) {
        this.$emit("update:orderItems", answers.map((i2) => i2.id));
      }
      this.setNextQuestion(formProgress);
    },
    setNextQuestion: function(formProgress) {
      const lastAnswer = formProgress[formProgress.length - 1];
      const lastAnswerIndex = this.questions.findIndex((q) => q.id === lastAnswer.questionId && (lastAnswer.orderItem ? q.order_item_id === (lastAnswer == null ? void 0 : lastAnswer.orderItem) : true));
      const questionLogic = this.form.data.logic.filter((l2) => l2.question_id === lastAnswer.questionId);
      if (questionLogic.length === 0) {
        this.currentQuestion = this.questions[lastAnswerIndex + 1];
        return;
      }
      const nextQuestionId = this.nextQuestionConsideringLogic(questionLogic, lastAnswer.answers);
      this.currentQuestion = nextQuestionId ? this.questions[this.questions.findIndex((q) => {
        if (q.id !== nextQuestionId) {
          return false;
        }
        return q.order_item_id ? !formProgress.find((a2) => a2.orderItem === q.order_item_id && a2.questionId === q.id) : true;
      })] : this.questions[lastAnswerIndex + 1];
    },
    nextQuestionConsideringLogic: function(logics, answers) {
      var _a, _b;
      for (const l2 of logics) {
        let isTrue = false;
        for (const condition of l2.conditions || []) {
          if (condition.logic_op === "AND" && !isTrue) {
            break;
          }
          if (!condition.op || !((_a = condition.compare_with) == null ? void 0 : _a.id) && !((_b = condition.compare_with) == null ? void 0 : _b.value)) {
            continue;
          }
          switch (condition.op) {
            case "==":
              isTrue = !!answers.find((a2) => {
                var _a2;
                return ((_a2 = condition.compare_with) == null ? void 0 : _a2.id) ? a2.id === condition.compare_with.id : a2.value === condition.compare_with.value;
              });
              break;
            case "!=":
              isTrue = !!answers.find((a2) => {
                var _a2;
                return ((_a2 = condition.compare_with) == null ? void 0 : _a2.id) ? a2.id !== condition.compare_with.id : a2.value !== condition.compare_with.value;
              });
              break;
            case ">":
              isTrue = !!answers.find((a2) => {
                var _a2;
                return a2.value > ((_a2 = condition.compare_with) == null ? void 0 : _a2.value);
              });
              break;
            case "<":
              isTrue = !!answers.find((a2) => {
                var _a2;
                return a2.value < ((_a2 = condition.compare_with) == null ? void 0 : _a2.value);
              });
              break;
            case ">=":
              isTrue = !!answers.find((a2) => {
                var _a2;
                return a2.value >= ((_a2 = condition.compare_with) == null ? void 0 : _a2.value);
              });
              break;
            case "<=":
              isTrue = !!answers.find((a2) => {
                var _a2;
                return a2.value <= ((_a2 = condition.compare_with) == null ? void 0 : _a2.value);
              });
              break;
          }
        }
        if (isTrue && l2.goto) {
          if (l2.type === "form") {
            this.noQuestion = true;
            this.$emit("update:goToForm", l2.goto);
            return;
          }
          return l2.goto;
        }
      }
      if (logics[0].otherwise) {
        return logics[0].otherwise;
      }
    },
    backToThePreviousAnswer: function() {
      const currAnswerIndex = this.answers.findIndex((a2) => a2.questionId === this.currentQuestion.id);
      this.currentQuestion = this.questions.find((q) => q.id === this.answers[currAnswerIndex === -1 ? this.answers.length - 1 : currAnswerIndex - 1].questionId);
    }
  }
};
const _withScopeId$1 = (n2) => (pushScopeId("data-v-6fd4dbc7"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$7 = { class: "flex justify-between" };
const _hoisted_2$4 = { class: "text-xl font-bold" };
const _hoisted_3$3 = {
  key: 0,
  class: "order-item p-4"
};
const _hoisted_4$3 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("div", { class: "order-item-reviewing" }, " Reviewing ", -1));
const _hoisted_5$3 = { class: "font-semibold" };
const _hoisted_6$2 = {
  key: 0,
  class: "flex-grow flex items-center"
};
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b;
  const _component_LeftSide = resolveComponent("LeftSide");
  const _component_Question = resolveComponent("Question");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(_component_LeftSide, {
      class: normalizeClass(["fixed bottom-0 left-0 right-0 z-10", {
        "lg:relative lg:w-1/2": !$props.isMobile,
        "absolute": $props.isPreview && $props.isMobile,
        "fixed": !$props.isPreview && $props.isMobile
      }]),
      "form-name": $props.form.name,
      "order-item": $options.orderItem,
      questions: $options.kickOffsAndFollowUps,
      "form-category": $options.formCategory,
      "current-question-id": (_a = _ctx.currentQuestion) == null ? void 0 : _a.id,
      tags: $options.tags,
      "is-mobile": $props.isMobile
    }, null, 8, ["class", "form-name", "order-item", "questions", "form-category", "current-question-id", "tags", "is-mobile"]),
    createElementVNode("div", {
      class: normalizeClass(["flex flex-col py-16 px-5 overflow-y-auto h-full w-full", { "lg:w-1/2 lg:px-16": !$props.isMobile }]),
      style: normalizeStyle({ backgroundColor: (_b = $props.theme) == null ? void 0 : _b.background })
    }, [
      createElementVNode("div", _hoisted_1$7, [
        createElementVNode("div", _hoisted_2$4, toDisplayString($props.order.store.domain), 1),
        $options.orderItem ? (openBlock(), createElementBlock("div", _hoisted_3$3, [
          _hoisted_4$3,
          createElementVNode("div", _hoisted_5$3, toDisplayString($options.orderItem.name), 1)
        ])) : createCommentVNode("", true)
      ]),
      !_ctx.noQuestion && _ctx.currentQuestion ? (openBlock(), createElementBlock("div", _hoisted_6$2, [
        (openBlock(), createBlock(_component_Question, {
          key: _ctx.currentQuestion.id,
          question: _ctx.currentQuestion,
          tags: $options.tags,
          "form-progress": $options.answers,
          "form-category": $props.form.category,
          "order-items": $options.orderItems,
          theme: $props.theme,
          "order-item": $options.orderItem,
          "is-mobile": $props.isMobile,
          "is-last-question": $options.isLastQuestion,
          "onUpdate:answer": $options.handleAnswer,
          "onUpload:file": _cache[0] || (_cache[0] = ($event) => _ctx.$emit("uploadFile", $event)),
          onClickBack: $options.backToThePreviousAnswer
        }, null, 8, ["question", "tags", "form-progress", "form-category", "order-items", "theme", "order-item", "is-mobile", "is-last-question", "onUpdate:answer", "onClickBack"]))
      ])) : createCommentVNode("", true)
    ], 6)
  ], 64);
}
var Form = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["render", _sfc_render$7], ["__scopeId", "data-v-6fd4dbc7"]]);
const _sfc_main$6 = {
  name: "PreviewForm",
  components: {
    Form
  },
  props: {
    form: { type: Object, required: true },
    mobilePreview: { type: Boolean, default: false },
    formName: { type: String, required: true },
    formCategory: { type: String, required: true }
  },
  data: function() {
    return {
      formData: {
        name: this.formName,
        data: this.form,
        category: this.formCategory
      },
      formProgress: [],
      order: {
        data: {
          customer: { first_name: "New", last_name: "Customer" },
          line_items: [{
            external_product_id: 666,
            name: "Product"
          }]
        },
        store: { domain: "ramaroo.com" }
      }
    };
  }
};
const _hoisted_1$6 = { class: "flex h-full relative" };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Form = resolveComponent("Form");
  return openBlock(), createElementBlock("div", _hoisted_1$6, [
    createVNode(_component_Form, {
      form: _ctx.formData,
      "form-progress": _ctx.formProgress,
      order: _ctx.order,
      "is-mobile": $props.mobilePreview,
      "is-preview": true,
      theme: $props.form.theme
    }, null, 8, ["form", "form-progress", "order", "is-mobile", "theme"])
  ]);
}
var PreviewForm$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["render", _sfc_render$6]]);
var Preview_vue_vue_type_style_index_0_scoped_true_lang = "";
const DESKTOP_HEIGHT = 800;
const MOBILE_HEIGHT = 812;
const _sfc_main$5 = {
  name: "Preview",
  components: {
    PreviewForm: PreviewForm$1,
    PreviewQuestion: PreviewQuestion$1,
    XIcon: render$d
  },
  props: {
    question: { type: Object, default: null },
    formCategory: { type: String, required: true },
    form: { type: Object, default: null },
    type: { type: String, required: true },
    formName: { type: String, required: true }
  },
  emits: ["click:close"],
  data: function() {
    return {
      mobilePreview: false,
      PREVIEW_TYPE_QUESTION,
      PREVIEW_TYPE_FORM,
      previewWindowHeight: 800,
      previewWindowWidth: 1280
    };
  },
  computed: {
    scale() {
      return this.previewWindowHeight / (this.mobilePreview ? MOBILE_HEIGHT : DESKTOP_HEIGHT);
    },
    previewWindowStyle() {
      return {
        "--scale": this.scale
      };
    }
  },
  unmounted() {
    removeEventListener("resize", this.handleResize);
  },
  mounted() {
    addEventListener("resize", this.handleResize);
    this.countPreviewWindowSize();
  },
  methods: {
    setMobilePreview: function(val) {
      this.mobilePreview = val;
    },
    handleResize: function() {
      this.countPreviewWindowSize();
    },
    countPreviewWindowSize: function() {
      this.previewWindowHeight = this.$refs.previewWindow.clientHeight;
      this.previewWindowWidth = this.$refs.previewWindow.clientWidth;
    }
  }
};
const _withScopeId = (n2) => (pushScopeId("data-v-6531c4af"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$5 = { class: "fixed left-0 top-0 bottom-0 right-0 z-50 bg-gray-200 flex flex-col gap-4" };
const _hoisted_2$3 = { class: "shadow p-3 text-gray-500 flex bg-white" };
const _hoisted_3$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("div", { class: "font-semibold flex-grow text-center" }, " Live Preview ", -1));
const _hoisted_4$2 = {
  ref: "previewWindow",
  class: "overflow-hidden"
};
const _hoisted_5$2 = { class: "pb-5 text-white text-sm text-center" };
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_XIcon = resolveComponent("XIcon");
  const _component_PreviewQuestion = resolveComponent("PreviewQuestion");
  const _component_PreviewForm = resolveComponent("PreviewForm");
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    createElementVNode("div", _hoisted_2$3, [
      _hoisted_3$2,
      createElementVNode("button", {
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click:close"))
      }, [
        createVNode(_component_XIcon, { class: "h-6 w-6 hover:text-blue-600" })
      ])
    ]),
    createElementVNode("div", _hoisted_4$2, [
      createElementVNode("div", {
        class: normalizeClass(["mx-auto preview-window shadow-lg rounded bg-white overflow-y-auto", { mobile: _ctx.mobilePreview }]),
        style: normalizeStyle($options.previewWindowStyle)
      }, [
        $props.type === _ctx.PREVIEW_TYPE_QUESTION ? (openBlock(), createBlock(_component_PreviewQuestion, {
          key: 0,
          question: $props.question,
          "form-category": $props.formCategory,
          "mobile-preview": _ctx.mobilePreview
        }, null, 8, ["question", "form-category", "mobile-preview"])) : createCommentVNode("", true),
        $props.type === _ctx.PREVIEW_TYPE_FORM ? (openBlock(), createBlock(_component_PreviewForm, {
          key: 1,
          form: $props.form,
          "form-name": $props.formName,
          "form-category": $props.formCategory,
          "mobile-preview": _ctx.mobilePreview
        }, null, 8, ["form", "form-name", "form-category", "mobile-preview"])) : createCommentVNode("", true)
      ], 6)
    ], 512),
    createElementVNode("div", _hoisted_5$2, [
      createElementVNode("button", {
        class: normalizeClass(["px-5 py-1.5 rounded-l", [_ctx.mobilePreview ? "bg-blue-800" : "bg-blue-600"]]),
        onClick: _cache[1] || (_cache[1] = ($event) => $options.setMobilePreview(false))
      }, " Desktop ", 2),
      createElementVNode("button", {
        class: normalizeClass(["px-5 py-1.5 rounded-r", [_ctx.mobilePreview ? "bg-blue-600" : "bg-blue-800"]]),
        onClick: _cache[2] || (_cache[2] = ($event) => $options.setMobilePreview(true))
      }, " Mobile ", 2)
    ])
  ]);
}
var Preview = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-6531c4af"]]);
const _sfc_main$4 = {
  name: "PreviewForm",
  components: {
    Form
  },
  props: {
    form: { type: Object, required: true },
    mobilePreview: { type: Boolean, default: false },
    formName: { type: String, required: true },
    formCategory: { type: String, required: true }
  },
  data: function() {
    return {
      formData: {
        name: this.formName,
        data: this.form,
        category: this.formCategory
      },
      formProgress: [],
      order: {
        data: {
          customer: { first_name: "New", last_name: "Customer" },
          line_items: [{
            external_product_id: 666,
            name: "Product"
          }]
        },
        store: { domain: "ramaroo.com" }
      }
    };
  }
};
const _hoisted_1$4 = { class: "flex h-full relative" };
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Form = resolveComponent("Form");
  return openBlock(), createElementBlock("div", _hoisted_1$4, [
    createVNode(_component_Form, {
      form: _ctx.formData,
      "form-progress": _ctx.formProgress,
      order: _ctx.order,
      "is-mobile": $props.mobilePreview,
      "is-preview": true,
      theme: $props.form.theme
    }, null, 8, ["form", "form-progress", "order", "is-mobile", "theme"])
  ]);
}
var PreviewForm = /* @__PURE__ */ _export_sfc$1(_sfc_main$4, [["render", _sfc_render$4]]);
var PreviewQuestion_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$3 = {
  name: "PreviewQuestion",
  components: {
    Question
  },
  props: {
    question: { type: Object, default: null },
    formCategory: { type: String, required: true },
    mobilePreview: { type: Boolean, default: false }
  }
};
const _hoisted_1$3 = { class: "flex h-full" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Question = resolveComponent("Question");
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    withDirectives(createElementVNode("div", {
      class: normalizeClass(["left-side py-5 lg:py-16 px-4 h-full", { "w-1/2": !$props.mobilePreview }])
    }, null, 2), [
      [vShow, !$props.mobilePreview]
    ]),
    createElementVNode("div", {
      class: normalizeClass([[$props.mobilePreview ? "px-5 w-full" : "w-1/2 px-16"], "py-16 flex flex-col justify-center"])
    }, [
      createVNode(_component_Question, {
        question: $props.question,
        "form-progress": [],
        "form-category": $props.formCategory,
        "is-mobile": $props.mobilePreview
      }, null, 8, ["question", "form-category", "is-mobile"])
    ], 2)
  ]);
}
var PreviewQuestion = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-f9dad5fc"]]);
const _sfc_main$2 = {
  name: "GoogleSheetsConnection",
  components: { Modal, GoogleSheetsIcon },
  props: {
    formId: { type: Number, required: true },
    storeId: { type: Number, required: true },
    hasGoogleIdentity: { type: Boolean, default: false },
    hasGoogleSheetConnection: { type: Boolean, default: false }
  },
  data: function() {
    return {
      error: null,
      saving: false,
      connected: this.hasGoogleSheetConnection
    };
  },
  computed: {
    buttonText: function() {
      if (this.connected) {
        return "Connected to";
      }
      return this.saving ? "Connecting" : "Connect to";
    }
  },
  methods: {
    handleClick: function(e2) {
      if (!this.hasGoogleIdentity) {
        return;
      }
      e2.preventDefault();
      !this.connected && this.save();
    },
    save: async function() {
      var _a, _b;
      if (this.saving) {
        return;
      }
      this.saving = true;
      try {
        await axios.post(
          route("api.google-sheets.create", this.formId),
          {},
          { headers: { "X-Store-Id": this.storeId } }
        );
        this.connected = true;
      } catch (e2) {
        this.error = ((_b = (_a = e2.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message) || e2.message;
      }
      await delay(1e3);
      this.saving = false;
    },
    clearError: function() {
      this.error = null;
    }
  }
};
const _hoisted_1$2 = ["href"];
const _hoisted_2$2 = { class: "pb-4" };
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GoogleSheetsIcon = resolveComponent("GoogleSheetsIcon");
  const _component_Modal = resolveComponent("Modal");
  return openBlock(), createElementBlock(Fragment, null, [
    createElementVNode("a", {
      href: $props.hasGoogleIdentity || _ctx.connected ? "" : _ctx.route("auth.google.redirect", $props.formId),
      class: normalizeClass(["text-sm border rounded text-[#47c080] px-4 py-1 font-semibold duration-300 flex items-center", [_ctx.connected ? "border-white cursor-default" : "border-[#47c080] hover:bg-green-50"]]),
      onClick: _cache[0] || (_cache[0] = (...args) => $options.handleClick && $options.handleClick(...args))
    }, [
      createElementVNode("div", null, toDisplayString($options.buttonText) + "\xA0", 1),
      createVNode(_component_GoogleSheetsIcon, { class: "h-5 w-5" })
    ], 10, _hoisted_1$2),
    _ctx.error ? (openBlock(), createBlock(_component_Modal, {
      key: 0,
      onClose: $options.clearError
    }, {
      default: withCtx(() => [
        createElementVNode("div", _hoisted_2$2, toDisplayString(_ctx.error), 1),
        createElementVNode("button", {
          class: "px-8 py-1 bg-blue-500 rounded text-white font-bold",
          onClick: _cache[1] || (_cache[1] = (...args) => $options.clearError && $options.clearError(...args))
        }, " Ok ")
      ]),
      _: 1
    }, 8, ["onClose"])) : createCommentVNode("", true)
  ], 64);
}
var GoogleSheetsConnection = /* @__PURE__ */ _export_sfc$1(_sfc_main$2, [["render", _sfc_render$2]]);
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a2, b2) {
  return Object.prototype.hasOwnProperty.call(a2, b2);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k2;
    for (k2 in obj) {
      if (hasOwnProp(obj, k2)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined(input) {
  return input === void 0;
}
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map(arr, fn3) {
  var res = [], i2, arrLen = arr.length;
  for (i2 = 0; i2 < arrLen; ++i2) {
    res.push(fn3(arr[i2], i2));
  }
  return res;
}
function extend(a2, b2) {
  for (var i2 in b2) {
    if (hasOwnProp(b2, i2)) {
      a2[i2] = b2[i2];
    }
  }
  if (hasOwnProp(b2, "toString")) {
    a2.toString = b2.toString;
  }
  if (hasOwnProp(b2, "valueOf")) {
    a2.valueOf = b2.valueOf;
  }
  return a2;
}
function createUTC(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m2) {
  if (m2._pf == null) {
    m2._pf = defaultParsingFlags();
  }
  return m2._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t2 = Object(this), len = t2.length >>> 0, i2;
    for (i2 = 0; i2 < len; i2++) {
      if (i2 in t2 && fun.call(this, t2[i2], i2, t2)) {
        return true;
      }
    }
    return false;
  };
}
function isValid(m2) {
  if (m2._isValid == null) {
    var flags = getParsingFlags(m2), parsedParts = some.call(flags.parsedDateParts, function(i2) {
      return i2 != null;
    }), isNowValid = !isNaN(m2._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m2._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
    if (Object.isFrozen == null || !Object.isFrozen(m2)) {
      m2._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m2._isValid;
}
function createInvalid(flags) {
  var m2 = createUTC(NaN);
  if (flags != null) {
    extend(getParsingFlags(m2), flags);
  } else {
    getParsingFlags(m2).userInvalidated = true;
  }
  return m2;
}
var momentProperties = hooks.momentProperties = [], updateInProgress = false;
function copyConfig(to2, from2) {
  var i2, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined(from2._isAMomentObject)) {
    to2._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined(from2._i)) {
    to2._i = from2._i;
  }
  if (!isUndefined(from2._f)) {
    to2._f = from2._f;
  }
  if (!isUndefined(from2._l)) {
    to2._l = from2._l;
  }
  if (!isUndefined(from2._strict)) {
    to2._strict = from2._strict;
  }
  if (!isUndefined(from2._tzm)) {
    to2._tzm = from2._tzm;
  }
  if (!isUndefined(from2._isUTC)) {
    to2._isUTC = from2._isUTC;
  }
  if (!isUndefined(from2._offset)) {
    to2._offset = from2._offset;
  }
  if (!isUndefined(from2._pf)) {
    to2._pf = getParsingFlags(from2);
  }
  if (!isUndefined(from2._locale)) {
    to2._locale = from2._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i2 = 0; i2 < momentPropertiesLen; i2++) {
      prop = momentProperties[i2];
      val = from2[prop];
      if (!isUndefined(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config) {
  copyConfig(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn3) {
  var firstTime = true;
  return extend(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i2, key, argLen = arguments.length;
      for (i2 = 0; i2 < argLen; i2++) {
        arg = "";
        if (typeof arguments[i2] === "object") {
          arg += "\n[" + i2 + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i2];
        }
        args.push(arg);
      }
      warn(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn3.apply(this, arguments);
  }, fn3);
}
var deprecations = {};
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set(config) {
  var prop, i2;
  for (i2 in config) {
    if (hasOwnProp(config, i2)) {
      prop = config[i2];
      if (isFunction(prop)) {
        this[i2] = prop;
      } else {
        this["_" + i2] = prop;
      }
    }
  }
  this._config = config;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
        res[prop] = {};
        extend(res[prop], parentConfig[prop]);
        extend(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
      res[prop] = extend({}, res[prop]);
    }
  }
  return res;
}
function Locale(config) {
  if (config != null) {
    this.set(config);
  }
}
var keys;
if (Object.keys) {
  keys = Object.keys;
} else {
  keys = function(obj) {
    var i2, res = [];
    for (i2 in obj) {
      if (hasOwnProp(obj, i2)) {
        res.push(i2);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func.apply(this, arguments),
        token2
      );
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array = format2.match(formattingTokens), i2, length;
  for (i2 = 0, length = array.length; i2 < length; i2++) {
    if (formatTokenFunctions[array[i2]]) {
      array[i2] = formatTokenFunctions[array[i2]];
    } else {
      array[i2] = removeFormattingTokens(array[i2]);
    }
  }
  return function(mom) {
    var output = "", i3;
    for (i3 = 0; i3 < length; i3++) {
      output += isFunction(array[i3]) ? array[i3].call(mom, format2) : array[i3];
    }
    return output;
  };
}
function formatMoment(m2, format2) {
  if (!m2.isValid()) {
    return m2.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m2.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m2);
}
function expandFormat(format2, locale2) {
  var i2 = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i2 >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i2 -= 1;
  }
  return format2;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
}
var aliases = {};
function addUnitAlias(unit, shorthand) {
  var lowerCase = unit.toLowerCase();
  aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {};
function addUnitPriority(unit, priority) {
  priorities[unit] = priority;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u2;
  for (u2 in unitsObj) {
    if (hasOwnProp(unitsObj, u2)) {
      units.push({ unit: u2, priority: priorities[u2] });
    }
  }
  units.sort(function(a2, b2) {
    return a2.priority - b2.priority;
  });
  return units;
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get(this, unit);
    }
  };
}
function get(mom, unit) {
  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
}
function set$1(mom, unit, value) {
  if (mom.isValid() && !isNaN(value)) {
    if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
      value = toInt(value);
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
        value,
        mom.month(),
        daysInMonth(value, mom.month())
      );
    } else {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
  }
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
    for (i2 = 0; i2 < prioritizedLen; i2++) {
      this[prioritized[i2].unit](units[prioritized[i2].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
regexes = {};
function addRegexToken(token2, regex2, strictRegex) {
  regexes[token2] = isFunction(regex2) ? regex2 : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex2;
  };
}
function getParseRegexForToken(token2, config) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config._strict, config._locale);
}
function unescapeFormat(s2) {
  return regexEscape(
    s2.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape(s2) {
  return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var tokens = {};
function addParseToken(token2, callback) {
  var i2, func = callback, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber(callback)) {
    func = function(input, array) {
      array[callback] = toInt(input);
    };
  }
  tokenLen = token2.length;
  for (i2 = 0; i2 < tokenLen; i2++) {
    tokens[token2[i2]] = func;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input, array, config, token3) {
    config._w = config._w || {};
    callback(input, config._w, config, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config._a, config, token2);
  }
}
var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
function mod(n2, x2) {
  return (n2 % x2 + x2) % x2;
}
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o2) {
    var i2;
    for (i2 = 0; i2 < this.length; ++i2) {
      if (this[i2] === o2) {
        return i2;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format2) {
  return this.localeData().monthsShort(this, format2);
});
addFormatToken("MMMM", 0, 0, function(format2) {
  return this.localeData().months(this, format2);
});
addUnitAlias("month", "M");
addUnitPriority("month", 8);
addRegexToken("M", match1to2);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array) {
  array[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
  var month = config._locale.monthsParse(input, token2, config._strict);
  if (month != null) {
    array[MONTH] = month;
  } else {
    getParsingFlags(config).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
function localeMonths(m2, format2) {
  if (!m2) {
    return isArray(this._months) ? this._months : this._months["standalone"];
  }
  return isArray(this._months) ? this._months[m2.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m2.month()];
}
function localeMonthsShort(m2, format2) {
  if (!m2) {
    return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray(this._monthsShort) ? this._monthsShort[m2.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m2.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i2, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i2 = 0; i2 < 12; ++i2) {
      mom = createUTC([2e3, i2]);
      this._shortMonthsParse[i2] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i2, mom, regex2;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    if (strict && !this._longMonthsParse[i2]) {
      this._longMonthsParse[i2] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i2] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i2]) {
      regex2 = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i2] = new RegExp(regex2.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
      return i2;
    } else if (!strict && this._monthsParse[i2].test(monthName)) {
      return i2;
    }
  }
}
function setMonth(mom, value) {
  var dayOfMonth;
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a2, b2) {
    return b2.length - a2.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
  for (i2 = 0; i2 < 12; i2++) {
    mom = createUTC([2e3, i2]);
    shortPieces.push(this.monthsShort(mom, ""));
    longPieces.push(this.months(mom, ""));
    mixedPieces.push(this.months(mom, ""));
    mixedPieces.push(this.monthsShort(mom, ""));
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i2 = 0; i2 < 12; i2++) {
    shortPieces[i2] = regexEscape(shortPieces[i2]);
    longPieces[i2] = regexEscape(longPieces[i2]);
  }
  for (i2 = 0; i2 < 24; i2++) {
    mixedPieces[i2] = regexEscape(mixedPieces[i2]);
  }
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
addFormatToken("Y", 0, 0, function() {
  var y2 = this.year();
  return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addUnitAlias("year", "y");
addUnitPriority("year", 1);
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array) {
  array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array) {
  array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array) {
  array[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function createDate(y2, m2, d2, h2, M2, s2, ms) {
  var date;
  if (y2 < 100 && y2 >= 0) {
    date = new Date(y2 + 400, m2, d2, h2, M2, s2, ms);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y2);
    }
  } else {
    date = new Date(y2, m2, d2, h2, M2, s2, ms);
  }
  return date;
}
function createUTCDate(y2) {
  var date, args;
  if (y2 < 100 && y2 >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y2 + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y2);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addUnitAlias("week", "w");
addUnitAlias("isoWeek", "W");
addUnitPriority("week", 5);
addUnitPriority("isoWeek", 5);
addRegexToken("w", match1to2);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(
  ["w", "ww", "W", "WW"],
  function(input, week, config, token2) {
    week[token2.substr(0, 1)] = toInt(input);
  }
);
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  doy: 6
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format2) {
  return this.localeData().weekdaysMin(this, format2);
});
addFormatToken("ddd", 0, 0, function(format2) {
  return this.localeData().weekdaysShort(this, format2);
});
addFormatToken("dddd", 0, 0, function(format2) {
  return this.localeData().weekdays(this, format2);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addUnitAlias("day", "d");
addUnitAlias("weekday", "e");
addUnitAlias("isoWeekday", "E");
addUnitPriority("day", 11);
addUnitPriority("weekday", 11);
addUnitPriority("isoWeekday", 11);
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
  var weekday = config._locale.weekdaysParse(input, token2, config._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
  week[token2] = toInt(input);
});
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n2) {
  return ws.slice(n2, 7).concat(ws.slice(0, n2));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m2, format2) {
  var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m2 && m2 !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m2 === true ? shiftWeekdays(weekdays, this._week.dow) : m2 ? weekdays[m2.day()] : weekdays;
}
function localeWeekdaysShort(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m2 ? this._weekdaysShort[m2.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m2) {
  return m2 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m2 ? this._weekdaysMin[m2.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i2 = 0; i2 < 7; ++i2) {
      mom = createUTC([2e3, 1]).day(i2);
      this._minWeekdaysParse[i2] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i2] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i2, mom, regex2;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    if (strict && !this._fullWeekdaysParse[i2]) {
      this._fullWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i2] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i2]) {
      regex2 = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i2] = new RegExp(regex2.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
      return i2;
    } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
      return i2;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a2, b2) {
    return b2.length - a2.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
  for (i2 = 0; i2 < 7; i2++) {
    mom = createUTC([2e3, 1]).day(i2);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
meridiem("a", true);
meridiem("A", false);
addUnitAlias("hour", "h");
addUnitPriority("hour", 13);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2);
addRegexToken("h", match1to2);
addRegexToken("k", match1to2);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array, config) {
  var kInput = toInt(input);
  array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array, config) {
  config._isPm = config._locale.isPM(input);
  config._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array, config) {
  array[HOUR] = toInt(input);
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config).bigHour = true;
});
addParseToken("Hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {}, localeFamilies = {}, globalLocale;
function commonPrefix(arr1, arr2) {
  var i2, minl = Math.min(arr1.length, arr2.length);
  for (i2 = 0; i2 < minl; i2 += 1) {
    if (arr1[i2] !== arr2[i2]) {
      return i2;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i2 = 0, j2, next, locale2, split;
  while (i2 < names.length) {
    split = normalizeLocale(names[i2]).split("-");
    j2 = split.length;
    next = normalizeLocale(names[i2 + 1]);
    next = next ? next.split("-") : null;
    while (j2 > 0) {
      locale2 = loadLocale(split.slice(0, j2).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j2 && commonPrefix(split, next) >= j2 - 1) {
        break;
      }
      j2--;
    }
    i2++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return name.match("^[^/\\\\]*$") != null;
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e2) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values) {
  var data2;
  if (key) {
    if (isUndefined(values)) {
      data2 = getLocale(key);
    } else {
      data2 = defineLocale(key, values);
    }
    if (data2) {
      globalLocale = data2;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config) {
  if (config !== null) {
    var locale2, parentConfig = baseConfig;
    config.abbr = name;
    if (locales[name] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name]._config;
    } else if (config.parentLocale != null) {
      if (locales[config.parentLocale] != null) {
        parentConfig = locales[config.parentLocale]._config;
      } else {
        locale2 = loadLocale(config.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config.parentLocale]) {
            localeFamilies[config.parentLocale] = [];
          }
          localeFamilies[config.parentLocale].push({
            name,
            config
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x2) {
        defineLocale(x2.name, x2.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config) {
  if (config != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs(parentConfig, config);
      if (tmpLocale == null) {
        config.abbr = name;
      }
      locale2 = new Locale(config);
      locale2.parentLocale = locales[name];
      locales[name] = locale2;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys(locales);
}
function checkOverflow(m2) {
  var overflow, a2 = m2._a;
  if (a2 && getParsingFlags(m2).overflow === -2) {
    overflow = a2[MONTH] < 0 || a2[MONTH] > 11 ? MONTH : a2[DATE] < 1 || a2[DATE] > daysInMonth(a2[YEAR], a2[MONTH]) ? DATE : a2[HOUR] < 0 || a2[HOUR] > 24 || a2[HOUR] === 24 && (a2[MINUTE] !== 0 || a2[SECOND] !== 0 || a2[MILLISECOND] !== 0) ? HOUR : a2[MINUTE] < 0 || a2[MINUTE] > 59 ? MINUTE : a2[SECOND] < 0 || a2[SECOND] > 59 ? SECOND : a2[MILLISECOND] < 0 || a2[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m2)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m2)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m2)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m2).overflow = overflow;
  }
  return m2;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
], isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config) {
  var i2, l2, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match) {
    getParsingFlags(config).iso = true;
    for (i2 = 0, l2 = isoDatesLen; i2 < l2; i2++) {
      if (isoDates[i2][1].exec(match[1])) {
        dateFormat = isoDates[i2][0];
        allowTime = isoDates[i2][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match[3]) {
      for (i2 = 0, l2 = isoTimesLen; i2 < l2; i2++) {
        if (isoTimes[i2][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes[i2][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config);
  } else {
    config._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s2) {
  return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m2 = hm % 100, h2 = (hm - m2) / 100;
    return h2 * 60 + m2;
  }
}
function configFromRFC2822(config) {
  var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
  if (match) {
    parsedArray = extractFromRFC2822Strings(
      match[4],
      match[3],
      match[2],
      match[5],
      match[6],
      match[7]
    );
    if (!checkWeekday(match[1], parsedArray, config)) {
      return;
    }
    config._a = parsedArray;
    config._tzm = calculateOffset(match[8], match[9], match[10]);
    config._d = createUTCDate.apply(null, config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    getParsingFlags(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}
function configFromString(config) {
  var matched = aspNetJsonRegex.exec(config._i);
  if (matched !== null) {
    config._d = new Date(+matched[1]);
    return;
  }
  configFromISO(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  configFromRFC2822(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  if (config._strict) {
    config._isValid = false;
  } else {
    hooks.createFromInputFallback(config);
  }
}
hooks.createFromInputFallback = deprecate(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(config) {
    config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
  }
);
function defaults(a2, b2, c2) {
  if (a2 != null) {
    return a2;
  }
  if (b2 != null) {
    return b2;
  }
  return c2;
}
function currentDateArray(config) {
  var nowValue = new Date(hooks.now());
  if (config._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config) {
  var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
  if (config._d) {
    return;
  }
  currentDate = currentDateArray(config);
  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config);
  }
  if (config._dayOfYear != null) {
    yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags(config)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config._dayOfYear);
    config._a[MONTH] = date.getUTCMonth();
    config._a[DATE] = date.getUTCDate();
  }
  for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
    config._a[i2] = input[i2] = currentDate[i2];
  }
  for (; i2 < 7; i2++) {
    config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
  }
  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
    config._nextDay = true;
    config._a[HOUR] = 0;
  }
  config._d = (config._useUTC ? createUTCDate : createDate).apply(
    null,
    input
  );
  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }
  if (config._nextDay) {
    config._a[HOUR] = 24;
  }
  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
    getParsingFlags(config).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config) {
  var w2, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w2 = config._w;
  if (w2.GG != null || w2.W != null || w2.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults(
      w2.GG,
      config._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults(w2.W, 1);
    weekday = defaults(w2.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults(w2.gg, config._a[YEAR], curWeek.year);
    week = defaults(w2.w, curWeek.week);
    if (w2.d != null) {
      weekday = w2.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w2.e != null) {
      weekday = w2.e + dow;
      if (w2.e < 0 || w2.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config) {
  if (config._f === hooks.ISO_8601) {
    configFromISO(config);
    return;
  }
  if (config._f === hooks.RFC_2822) {
    configFromRFC2822(config);
    return;
  }
  config._a = [];
  getParsingFlags(config).empty = true;
  var string = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i2 = 0; i2 < tokenLen; i2++) {
    token2 = tokens2[i2];
    parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config).unusedInput.push(skipped);
      }
      string = string.slice(
        string.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config).empty = false;
      } else {
        getParsingFlags(config).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags(config).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config).unusedInput.push(string);
  }
  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
    getParsingFlags(config).bigHour = void 0;
  }
  getParsingFlags(config).parsedDateParts = config._a.slice(0);
  getParsingFlags(config).meridiem = config._meridiem;
  config._a[HOUR] = meridiemFixWrap(
    config._locale,
    config._a[HOUR],
    config._meridiem
  );
  era = getParsingFlags(config).era;
  if (era !== null) {
    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
  }
  configFromArray(config);
  checkOverflow(config);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config) {
  var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
  if (configfLen === 0) {
    getParsingFlags(config).invalidFormat = true;
    config._d = new Date(NaN);
    return;
  }
  for (i2 = 0; i2 < configfLen; i2++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i2];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend(config, bestMoment || tempConfig);
}
function configFromObject(config) {
  if (config._d) {
    return;
  }
  var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
  config._a = map(
    [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config);
}
function createFromConfig(config) {
  var res = new Moment(checkOverflow(prepareConfig(config)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config) {
  var input = config._i, format2 = config._f;
  config._locale = config._locale || getLocale(config._l);
  if (input === null || format2 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config._i = input = config._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate(input)) {
    config._d = input;
  } else if (isArray(format2)) {
    configFromStringAndArray(config);
  } else if (format2) {
    configFromStringAndFormat(config);
  } else {
    configFromInput(config);
  }
  if (!isValid(config)) {
    config._d = null;
  }
  return config;
}
function configFromInput(config) {
  var input = config._i;
  if (isUndefined(input)) {
    config._d = new Date(hooks.now());
  } else if (isDate(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config);
  } else if (isArray(input)) {
    config._a = map(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config);
  } else if (isObject(input)) {
    configFromObject(config);
  } else if (isNumber(input)) {
    config._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config);
  }
}
function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
  var c2 = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
    input = void 0;
  }
  c2._isAMomentObject = true;
  c2._useUTC = c2._isUTC = isUTC;
  c2._l = locale2;
  c2._i = input;
  c2._f = format2;
  c2._strict = strict;
  return createFromConfig(c2);
}
function createLocal(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, false);
}
var prototypeMin = deprecate(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }
), prototypeMax = deprecate(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
function pickBy(fn3, moments) {
  var res, i2;
  if (moments.length === 1 && isArray(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i2 = 1; i2 < moments.length; ++i2) {
    if (!moments[i2].isValid() || moments[i2][fn3](res)) {
      res = moments[i2];
    }
  }
  return res;
}
function min() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
var now = function() {
  return Date.now ? Date.now() : +new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m2) {
  var key, unitHasDecimal = false, i2, orderLen = ordering.length;
  for (key in m2) {
    if (hasOwnProp(m2, key) && !(indexOf.call(ordering, key) !== -1 && (m2[key] == null || !isNaN(m2[key])))) {
      return false;
    }
  }
  for (i2 = 0; i2 < orderLen; ++i2) {
    if (m2[ordering[i2]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m2[ordering[i2]]) !== toInt(m2[ordering[i2]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
  for (i2 = 0; i2 < len; i2++) {
    if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array, config) {
  config._useUTC = true;
  config._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string) {
  var matches2 = (string || "").match(matcher), chunk, parts, minutes2;
  if (matches2 === null) {
    return null;
  }
  chunk = matches2[matches2.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m2) {
  return -Math.round(m2._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input - offset2, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c2 = {}, other;
  copyConfig(c2, this);
  c2 = prepareConfig(c2);
  if (c2._a) {
    other = c2._isUTC ? createUTC(c2._a) : createLocal(c2._a);
    this._isDSTShifted = this.isValid() && compareArrays(c2._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration = input, match = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match = aspNetRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match[DATE]) * sign2,
      h: toInt(match[HOUR]) * sign2,
      m: toInt(match[MINUTE]) * sign2,
      s: toInt(match[SECOND]) * sign2,
      ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
    };
  } else if (match = isoRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match[2], sign2),
      M: parseIso(match[3], sign2),
      w: parseIso(match[4], sign2),
      d: parseIso(match[5], sign2),
      h: parseIso(match[6], sign2),
      m: parseIso(match[7], sign2),
      s: parseIso(match[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(
      createLocal(duration.from),
      createLocal(duration.to)
    );
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name,
        "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
function isString(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i2, property, propertyLen = properties.length;
  for (i2 = 0; i2 < propertyLen; i2 += 1) {
    property = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber(item) && isString(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i2, property;
  for (i2 = 0; i2 < properties.length; i2 += 1) {
    property = properties[i2];
    propertyTest = propertyTest || hasOwnProp(input, property);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = void 0;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
  return this.format(
    output || this.localeData().calendar(format2, this, createLocal(now2))
  );
}
function clone() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to2, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a2, b2) {
  if (a2.date() < b2.date()) {
    return -monthDiff(b2, a2);
  }
  var wholeMonthDiff = (b2.year() - a2.year()) * 12 + (b2.month() - a2.month()), anchor = a2.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b2 - anchor < 0) {
    anchor2 = a2.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b2 - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a2.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b2 - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString2() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m2 = utc ? this.clone().utc() : this;
  if (m2.year() < 0 || m2.year() > 9999) {
    return formatMoment(
      m2,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m2, "Z"));
    }
  }
  return formatMoment(
    m2,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  }
);
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y2, m2, d2) {
  if (y2 < 100 && y2 >= 0) {
    return new Date(y2 + 400, m2, d2) - MS_PER_400_YEARS;
  } else {
    return new Date(y2, m2, d2).valueOf();
  }
}
function utcStartOfDate(y2, m2, d2) {
  if (y2 < 100 && y2 >= 0) {
    return Date.UTC(y2 + 400, m2, d2) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y2, m2, d2);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray2() {
  var m2 = this;
  return [
    m2.year(),
    m2.month(),
    m2.date(),
    m2.hour(),
    m2.minute(),
    m2.second(),
    m2.millisecond()
  ];
}
function toObject() {
  var m2 = this;
  return {
    years: m2.year(),
    months: m2.month(),
    date: m2.date(),
    hours: m2.hours(),
    minutes: m2.minutes(),
    seconds: m2.seconds(),
    milliseconds: m2.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(input, array, config, token2) {
    var era = config._locale.erasParse(input, token2, config._strict);
    if (era) {
      getParsingFlags(config).era = era;
    } else {
      getParsingFlags(config).invalidEra = input;
    }
  }
);
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array, config, token2) {
  var match;
  if (config._locale._eraYearOrdinalRegex) {
    match = input.match(config._locale._eraYearOrdinalRegex);
  }
  if (config._locale.eraYearOrdinalParse) {
    array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
  } else {
    array[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m2, format2) {
  var i2, l2, date, eras = this._eras || getLocale("en")._eras;
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    switch (typeof eras[i2].since) {
      case "string":
        date = hooks(eras[i2].since).startOf("day");
        eras[i2].since = date.valueOf();
        break;
    }
    switch (typeof eras[i2].until) {
      case "undefined":
        eras[i2].until = Infinity;
        break;
      case "string":
        date = hooks(eras[i2].until).startOf("day").valueOf();
        eras[i2].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i2, l2, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    name = eras[i2].name.toUpperCase();
    abbr = eras[i2].abbr.toUpperCase();
    narrow = eras[i2].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i2];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i2];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i2];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i2];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].name;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].narrow;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i2, l2, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until) {
      return eras[i2].abbr;
    }
    if (eras[i2].until <= val && val <= eras[i2].since) {
      return eras[i2].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i2, l2, dir, val, eras = this.localeData().eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    dir = eras[i2].since <= eras[i2].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
      return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l2, eras = this.eras();
  for (i2 = 0, l2 = eras.length; i2 < l2; ++i2) {
    namePieces.push(regexEscape(eras[i2].name));
    abbrPieces.push(regexEscape(eras[i2].abbr));
    narrowPieces.push(regexEscape(eras[i2].narrow));
    mixedPieces.push(regexEscape(eras[i2].name));
    mixedPieces.push(regexEscape(eras[i2].abbr));
    mixedPieces.push(regexEscape(eras[i2].narrow));
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addUnitAlias("weekYear", "gg");
addUnitAlias("isoWeekYear", "GG");
addUnitPriority("weekYear", 1);
addUnitPriority("isoWeekYear", 1);
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(input, week, config, token2) {
    week[token2.substr(0, 2)] = toInt(input);
  }
);
addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
  week[token2] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addUnitAlias("quarter", "Q");
addUnitPriority("quarter", 7);
addRegexToken("Q", match1);
addParseToken("Q", function(input, array) {
  array[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addUnitAlias("date", "D");
addUnitPriority("date", 9);
addRegexToken("D", match1to2);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array) {
  array[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addUnitAlias("dayOfYear", "DDD");
addUnitPriority("dayOfYear", 4);
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array, config) {
  config._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addUnitAlias("minute", "m");
addUnitPriority("minute", 14);
addRegexToken("m", match1to2);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addUnitAlias("second", "s");
addUnitPriority("second", 15);
addRegexToken("s", match1to2);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addUnitAlias("millisecond", "ms");
addUnitPriority("millisecond", 16);
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token, getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add;
proto.calendar = calendar$1;
proto.clone = clone;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray2;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON;
proto.toString = toString2;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate(
  "dates accessor is deprecated. Use date instead.",
  getSetDayOfMonth
);
proto.months = deprecate(
  "months accessor is deprecated. Use month instead",
  getSetMonth
);
proto.years = deprecate(
  "years accessor is deprecated. Use year instead",
  getSetYear
);
proto.zone = deprecate(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  getSetZone
);
proto.isDSTShifted = deprecate(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  isDaylightSavingTimeShifted
);
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string) {
  return string;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1(format2, index2, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index2);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index2, field) {
  if (isNumber(format2)) {
    index2 = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index2 != null) {
    return get$1(format2, index2, field, "month");
  }
  var i2, out = [];
  for (i2 = 0; i2 < 12; i2++) {
    out[i2] = get$1(format2, i2, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index2, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format2)) {
      index2 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index2 = format2;
    localeSorted = false;
    if (isNumber(format2)) {
      index2 = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
  if (index2 != null) {
    return get$1(format2, (index2 + shift) % 7, field, "day");
  }
  for (i2 = 0; i2 < 7; i2++) {
    out[i2] = get$1(format2, (i2 + shift) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index2) {
  return listMonthsImpl(format2, index2, "months");
}
function listMonthsShort(format2, index2) {
  return listMonthsImpl(format2, index2, "monthsShort");
}
function listWeekdays(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index2) {
  return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b2 = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
    return number + output;
  }
});
hooks.lang = deprecate(
  "moment.lang is deprecated. Use moment.locale instead.",
  getSetGlobalLocale
);
hooks.langData = deprecate(
  "moment.langData is deprecated. Use moment.localeData instead.",
  getLocale
);
var mathAbs = Math.abs;
function abs() {
  var data2 = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data2.milliseconds = mathAbs(data2.milliseconds);
  data2.seconds = mathAbs(data2.seconds);
  data2.minutes = mathAbs(data2.minutes);
  data2.hours = mathAbs(data2.hours);
  data2.months = mathAbs(data2.months);
  data2.years = mathAbs(data2.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data2 = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data2.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data2.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data2.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data2.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data2.days = days2;
  data2.months = months2;
  data2.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function valueOf$1() {
  if (!this.isValid()) {
    return NaN;
  }
  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
function clone$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round = Math.round, thresholds = {
  ss: 44,
  s: 45,
  m: 45,
  h: 22,
  d: 26,
  w: null,
  M: 11
};
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a2 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a2 = a2 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a2 = a2 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a2[2] = withoutSuffix;
  a2[3] = +posNegDuration > 0;
  a2[4] = locale2;
  return substituteTimeAgo.apply(null, a2);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign(x2) {
  return (x2 > 0) - (x2 < 0) || +x2;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  toISOString$1
);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array, config) {
  config._d = new Date(parseFloat(input) * 1e3);
});
addParseToken("x", function(input, array, config) {
  config._d = new Date(toInt(input));
});
//! moment.js
hooks.version = "2.29.4";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min;
hooks.max = max;
hooks.now = now;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  DATE: "YYYY-MM-DD",
  TIME: "HH:mm",
  TIME_SECONDS: "HH:mm:ss",
  TIME_MS: "HH:mm:ss.SSS",
  WEEK: "GGGG-[W]WW",
  MONTH: "YYYY-MM"
};
const _sfc_main$1 = {
  name: "PerRespondent",
  props: {
    questions: { type: Array, required: true },
    answers: { type: Array, required: true }
  },
  data() {
    return {
      currentAnswer: null
    };
  },
  computed: {
    currentAnswers: function() {
      var _a;
      return (_a = this.answers[this.currentAnswer]) == null ? void 0 : _a.answers;
    }
  },
  methods: {
    moment: hooks,
    handleClickRespondent: function(index2) {
      this.currentAnswer = index2;
    },
    question: function(id) {
      if (id === QUESTION_TYPE_PURCHASED_ITEMS_CHOICE) {
        return PURCHASED_ITEMS_CHOICE_QUESTION;
      }
      return this.questions.find((q) => q.id === id);
    }
  }
};
const _hoisted_1$1 = { class: "flex h-full relative overflow-hidden" };
const _hoisted_2$1 = ["onClick"];
const _hoisted_3$1 = { class: "text-sm text-gray-600 font-normal" };
const _hoisted_4$1 = { class: "w-10/12 absolute top-0 bottom-0 right-0 bg-white py-5 px-6 shadow-lg overflow-y-auto" };
const _hoisted_5$1 = { class: "flex gap-4" };
const _hoisted_6$1 = { class: "bg-kick_off px-4 py-1 rounded font-bold" };
const _hoisted_7$1 = { class: "py-1 border-b border-gray-100" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    createElementVNode("div", {
      class: normalizeClass(["overflow-y-auto w-full duration-300", { "bg-gray-100": $data.currentAnswer !== null }])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.answers, (a2, i2) => {
        return openBlock(), createElementBlock("div", {
          key: `results-answers-${a2.form_uuid}-${a2.order_uuid}`,
          class: normalizeClass(["border-b border-gray-200 py-3 px-5 duration-200", [$data.currentAnswer === i2 ? "bg-blue-100 font-bold" : "hover:bg-gray-300 cursor-pointer"]]),
          onClick: ($event) => $options.handleClickRespondent(i2)
        }, [
          createElementVNode("div", null, toDisplayString($options.moment(a2.created_at).format("DD MMM")) + " #" + toDisplayString(a2.order.external_id), 1),
          createElementVNode("div", _hoisted_3$1, toDisplayString(a2.order.store.domain), 1)
        ], 10, _hoisted_2$1);
      }), 128))
    ], 2),
    createVNode(Transition, {
      "enter-active-class": "transition ease-out duration-200",
      "enter-from-class": "transform translate-x-full",
      "enter-to-class": "transform translate-x-0",
      "leave-active-class": "transition ease-in duration-75",
      "leave-from-class": "transform translate-x-0",
      "leave-to-class": "transform translate-x-full"
    }, {
      default: withCtx(() => [
        withDirectives(createElementVNode("div", _hoisted_4$1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.currentAnswers, (a2, index2) => {
            var _a;
            return openBlock(), createElementBlock("div", {
              key: `results-answers-answer-${a2.questionId}`
            }, [
              createElementVNode("div", _hoisted_5$1, [
                createElementVNode("div", null, [
                  createElementVNode("div", _hoisted_6$1, " Q" + toDisplayString(index2 + 1), 1)
                ]),
                createElementVNode("div", _hoisted_7$1, [
                  createElementVNode("div", null, toDisplayString((_a = $options.question(a2.questionId)) == null ? void 0 : _a.title), 1),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(a2.answers, (answer) => {
                    return openBlock(), createElementBlock("div", {
                      key: `results-answers-answer-variant-${answer.id}`,
                      class: "py-3 font-bold"
                    }, toDisplayString(answer.value), 1);
                  }), 128))
                ])
              ])
            ]);
          }), 128))
        ], 512), [
          [vShow, $data.currentAnswer !== null]
        ])
      ]),
      _: 1
    })
  ]);
}
var PerRespondent = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["render", _sfc_render$1]]);
const MAX_VARIANTS_NUMBER = 10;
const _sfc_main = {
  props: {
    form: { type: Object, required: true },
    summary: { type: Object, required: true }
  },
  computed: {
    questions: function() {
      return [...this.form.data.kick_offs, ...this.form.data.follow_ups];
    },
    sortedSummary: function() {
      const result = {};
      for (const q in this.summary) {
        result[q] = Object.entries({ ...this.questionChoices(q), ...this.summary[q] }).sort(([, a2], [, b2]) => b2 - a2);
        if (result[q].length > MAX_VARIANTS_NUMBER) {
          result[q] = [
            ...result[q].slice(0, MAX_VARIANTS_NUMBER),
            ["others", result[q].slice(MAX_VARIANTS_NUMBER).reduce((sum, r2) => sum + r2[1], 0)]
          ];
        }
      }
      return result;
    },
    countedSummary: function() {
      const s2 = {};
      for (const itemKey in this.sortedSummary) {
        const amount = Object.values(this.summary[itemKey]).reduce((sum, a2) => sum + a2, 0);
        s2[itemKey] = {
          amount,
          percentage: this.sortedSummary[itemKey].reduce((r2, i2) => ({
            ...r2,
            [i2[0]]: (i2[1] / amount * 100).toFixed(0)
          }), {})
        };
      }
      return s2;
    }
  },
  methods: {
    questionChoices: function(id) {
      var _a, _b, _c;
      return Object.fromEntries(((_c = (_b = (_a = this.questions.find((q) => q.id === id)) == null ? void 0 : _a.properties) == null ? void 0 : _b.choices) == null ? void 0 : _c.map((c2) => [c2.label, 0])) || []);
    }
  }
};
const _hoisted_1 = { class: "flex gap-5" };
const _hoisted_2 = { class: "w-1/12" };
const _hoisted_3 = { class: "bg-kick_off px-4 py-1 rounded font-bold inline-block" };
const _hoisted_4 = { class: "pt-1 pb-4 border-b border-gray-200 w-11/12" };
const _hoisted_5 = { class: "text-lg font-bold" };
const _hoisted_6 = { class: "text-gray-400 pb-4" };
const _hoisted_7 = { class: "py-4" };
const _hoisted_8 = { class: "flex gap-2 justify-between" };
const _hoisted_9 = { class: "flex items-center gap-4 text-gray-400" };
const _hoisted_10 = { class: "text-sm" };
const _hoisted_11 = { class: "font-bold text-gray-500" };
const _hoisted_12 = { class: "h-6 bg-gray-100 rounded overflow-hidden mt-2" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.questions, (question, index2) => {
      var _a;
      return openBlock(), createElementBlock("div", {
        key: question.id
      }, [
        createElementVNode("div", _hoisted_1, [
          createElementVNode("div", _hoisted_2, [
            createElementVNode("div", _hoisted_3, " Q" + toDisplayString(index2 + 1), 1)
          ]),
          createElementVNode("div", _hoisted_4, [
            createElementVNode("div", _hoisted_5, toDisplayString(question.title), 1),
            createElementVNode("div", _hoisted_6, toDisplayString(((_a = $options.countedSummary[question.id]) == null ? void 0 : _a.amount) || 0) + " people answered this question ", 1),
            createElementVNode("div", _hoisted_7, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($options.sortedSummary[question.id], (variant) => {
                var _a2, _b;
                return openBlock(), createElementBlock("div", {
                  key: `variant-${question.id}-${variant.id}`,
                  class: "pb-4"
                }, [
                  createElementVNode("div", _hoisted_8, [
                    createElementVNode("div", null, toDisplayString(variant.label || variant[0]), 1),
                    createElementVNode("div", _hoisted_9, [
                      createElementVNode("div", _hoisted_10, toDisplayString($props.summary[question.id] && $props.summary[question.id][variant.label || variant[0]] || 0) + " resp. ", 1),
                      createElementVNode("div", _hoisted_11, toDisplayString(((_a2 = $options.countedSummary[question.id]) == null ? void 0 : _a2.percentage[variant.label || variant[0]]) || 0) + "% ", 1)
                    ])
                  ]),
                  createElementVNode("div", _hoisted_12, [
                    createElementVNode("div", {
                      class: "h-full bg-cyan-700",
                      style: normalizeStyle({ width: `${((_b = $options.countedSummary[question.id]) == null ? void 0 : _b.percentage[variant.label || variant[0]]) || 0}%` })
                    }, null, 4)
                  ])
                ]);
              }), 128))
            ])
          ])
        ])
      ]);
    }), 128))
  ]);
}
var Summary = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["render", _sfc_render]]);
const components = {
  Accordion,
  ApplicationLogo,
  Button,
  Checkbox,
  CustomButton,
  Dropdown,
  Input,
  InputError,
  Label,
  Modal,
  Pagination,
  PaginationButton,
  RadioButton,
  SelectBox,
  Switch,
  Tabs,
  ValidationErrors,
  ActionButtons,
  AddEmoji,
  CentralPartHeader,
  CentralPartView,
  DesignTheme,
  Error: Error$1,
  FormEdit,
  FormTransfer: FormTransfer$1,
  Hyperlink,
  ListOfQuestions,
  ListOfQuestionsItem,
  LogicJump,
  LogicJumpCondition,
  MediaManager,
  MenuBar,
  MergeTags,
  QuestionAddingButton,
  QuestionAddingPopup,
  QuestionCategoryAndType,
  QuestionContextMenu,
  QuestionErrors,
  QuestionLabel,
  QuestionMultipleChoice,
  QuestionNav,
  QuestionOpen,
  QuestionRatingScore,
  QuestionSettings,
  QuestionTimeDelay,
  QuestionView,
  QuestionYesNo,
  RecallInfo,
  SettingCheckboxes,
  SettingInput,
  SettingInputNumber,
  SettingSelectBox,
  SettingSwitch,
  StoreAnswer,
  TextField,
  TextFieldMark,
  TextFieldWithMarks,
  Canvas,
  CanvasButton,
  AddEmojyIcon,
  AddMediaIcon,
  ArrowDownIcon,
  ArrowLeftIcon,
  ArrowLeftSquareIcon,
  ArrowRightIcon,
  ClockIcon,
  CollectionIcon,
  ContrastIcon,
  ControlsIcon,
  DesignThemeIcon,
  DuplicateIcon,
  EditIcon,
  ExitSignIcon,
  GearIcon,
  GoogleSheetsIcon,
  HandshakeIcon,
  IconBase,
  JumpIcon,
  LinkIcon,
  MultipleChoiceIcon,
  PlusIcon,
  PreviewIcon,
  QuestionAddIcon,
  QuestionIcon,
  SaveAllIcon,
  SortIcon,
  StopIcon,
  TYPIcon,
  TagIcon,
  TrashIcon,
  Preview,
  PreviewForm,
  PreviewQuestion,
  ChoiceButton,
  ErrorMessage,
  Form,
  FormProgress,
  LeftSide,
  MultipleChoice,
  Open,
  PurchasedItemsChoice,
  Question,
  RatingScore,
  TimeDelay,
  UploadFiles,
  YesNo,
  GoogleSheetsConnection,
  PerRespondent,
  Summary
};
function install(Vue) {
  for (const component in components) {
    Vue.component(components[component].name, components[component]);
  }
}
var index = { install };
export { Accordion, ActionButtons, AddEmoji, AddEmojyIcon, AddMediaIcon, ApplicationLogo, ArrowDownIcon, ArrowLeftIcon, ArrowLeftSquareIcon, ArrowRightIcon, Button, Canvas, CanvasButton, CentralPartHeader, CentralPartView, Checkbox, ChoiceButton, ClockIcon, CollectionIcon, ContrastIcon, ControlsIcon, CustomButton, DesignTheme, DesignThemeIcon, Dropdown, DuplicateIcon, EditIcon, Error$1 as Error, ErrorMessage, ExitSignIcon, Form, FormEdit, FormProgress, FormTransfer$1 as FormTransfer, GearIcon, GoogleSheetsConnection, GoogleSheetsIcon, HandshakeIcon, Hyperlink, IconBase, Input, InputError, JumpIcon, Label, LeftSide, LinkIcon, ListOfQuestions, ListOfQuestionsItem, LogicJump, LogicJumpCondition, MediaManager, MenuBar, MergeTags, Modal, MultipleChoice, MultipleChoiceIcon, Open, Pagination, PaginationButton, PerRespondent, PlusIcon, Preview, PreviewForm, PreviewIcon, PreviewQuestion, PurchasedItemsChoice, Question, QuestionAddIcon, QuestionAddingButton, QuestionAddingPopup, QuestionCategoryAndType, QuestionContextMenu, QuestionErrors, QuestionIcon, QuestionLabel, QuestionMultipleChoice, QuestionNav, QuestionOpen, QuestionRatingScore, QuestionSettings, QuestionTimeDelay, QuestionView, QuestionYesNo, RadioButton, RatingScore, RecallInfo, SaveAllIcon, SelectBox, SettingCheckboxes, SettingInput, SettingInputNumber, SettingSelectBox, SettingSwitch, SortIcon, StopIcon, StoreAnswer, Summary, Switch, TYPIcon, Tabs, TagIcon, TextField, TextFieldMark, TextFieldWithMarks, TimeDelay, TrashIcon, UploadFiles, ValidationErrors, YesNo, centralPartViews, cursor, index as default, form, forms, functions, logicJump, messages, questions };
